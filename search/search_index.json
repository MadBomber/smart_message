{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SmartMessage Documentation","text":"SmartMessage is a powerful Ruby framework that transforms ordinary messages into intelligent, self-aware entities capable of routing themselves, validating their contents, and executing business logic. By abstracting away the complexities of transport mechanisms (Redis, RabbitMQ, Kafka) and serialization formats (JSON, MessagePack), SmartMessage lets you focus on what matters: your business logic.  Think of SmartMessage as ActiveRecord for messaging - just as ActiveRecord frees you from database-specific SQL, SmartMessage liberates your messages from transport-specific implementations. Each message knows how to validate itself, where it came from, where it's going, and what to do when it arrives. With built-in support for filtering, versioning, deduplication, and concurrent processing, SmartMessage provides enterprise-grade messaging capabilities with the simplicity Ruby developers love."},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start</li> <li>Basic Usage Examples</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Architecture Overview</li> <li>Property System</li> <li>Entity Addressing</li> <li>Message Filtering</li> <li>Message Processing</li> <li>Dispatcher &amp; Routing</li> </ul>"},{"location":"#transports","title":"Transports","text":"<ul> <li>Transport Layer</li> <li>Multi-Transport Publishing</li> <li>Redis Transport</li> <li>Redis Transport Comparison</li> <li>Memory Transport</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Examples &amp; Use Cases</li> <li>Architecture Overview</li> <li>Transport Configuration</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Serializers</li> <li>Logging System</li> <li>Dead Letter Queue</li> <li>Message Deduplication</li> <li>Proc Handlers</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Troubleshooting</li> <li>Ideas &amp; Roadmap</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>New to SmartMessage? Start with Quick Start</li> <li>Need examples? Check out Examples</li> <li>Understanding the architecture? Read Architecture Overview</li> <li>Having issues? Visit Troubleshooting</li> </ul>"},{"location":"#version","title":"Version","text":"<p>This documentation is for SmartMessage v0.0.8.</p> <p>For older versions, please check the git tags and corresponding documentation.</p>"},{"location":"core-concepts/addressing/","title":"Entity Addressing","text":"<p>SmartMessage supports entity-to-entity addressing through built-in FROM/TO/REPLY_TO fields in message headers. This enables sophisticated messaging patterns including point-to-point communication, broadcast messaging, and request-reply workflows.</p>"},{"location":"core-concepts/addressing/#overview","title":"Overview","text":"<p>Entity addressing in SmartMessage provides:</p> <ul> <li>Sender Identification: Required <code>from</code> field identifies the sending entity</li> <li>Recipient Targeting: Optional <code>to</code> field for point-to-point messaging  </li> <li>Response Routing: Optional <code>reply_to</code> field for request-reply patterns</li> <li>Broadcast Support: Omitting <code>to</code> field enables broadcast to all subscribers</li> <li>Dual-Level Configuration: Class and instance-level addressing configuration</li> </ul>"},{"location":"core-concepts/addressing/#address-fields","title":"Address Fields","text":""},{"location":"core-concepts/addressing/#from-required","title":"FROM (Required)","text":"<p>The <code>from</code> field identifies the entity sending the message. This is required for all messages.</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  from 'order-service'  # Required sender identity\n\n  property :data\nend\n</code></pre>"},{"location":"core-concepts/addressing/#to-optional","title":"TO (Optional)","text":"<p>The <code>to</code> field specifies the intended recipient entity. When present, creates point-to-point messaging. When <code>nil</code>, the message is broadcast to all subscribers.</p> <pre><code># Point-to-point messaging\nclass DirectMessage &lt; SmartMessage::Base\n  from 'sender-service'\n  to 'recipient-service'  # Specific target\n\n  property :content\nend\n\n# Broadcast messaging\nclass AnnouncementMessage &lt; SmartMessage::Base\n  from 'admin-service'\n  # No 'to' field = broadcast to all subscribers\n\n  property :announcement\nend\n</code></pre>"},{"location":"core-concepts/addressing/#reply_to-optional","title":"REPLY_TO (Optional)","text":"<p>The <code>reply_to</code> field specifies where responses should be sent. Defaults to the <code>from</code> entity if not specified.</p> <pre><code>class RequestMessage &lt; SmartMessage::Base\n  from 'client-service'\n  to 'api-service'\n  reply_to 'client-callback-service'  # Responses go here\n\n  property :request_data\nend\n</code></pre>"},{"location":"core-concepts/addressing/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"core-concepts/addressing/#class-level-configuration","title":"Class-Level Configuration","text":"<p>Set default addressing for all instances of a message class using three different approaches:</p>"},{"location":"core-concepts/addressing/#method-1-direct-class-methods","title":"Method 1: Direct Class Methods","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # Class-level addressing using direct methods\n  from 'payment-service'\n  to 'bank-gateway'\n  reply_to 'payment-service'\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n</code></pre>"},{"location":"core-concepts/addressing/#method-2-header-block-dsl","title":"Method 2: Header Block DSL","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # Class-level addressing using header block\n  header do\n    from 'payment-service'\n    to 'bank-gateway'\n    reply_to 'payment-service'\n  end\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n</code></pre>"},{"location":"core-concepts/addressing/#method-3-mixed-approach","title":"Method 3: Mixed Approach","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # You can mix approaches if needed\n  header do\n    from 'payment-service'\n    to 'bank-gateway'\n  end\n\n  # Additional addressing outside the block\n  reply_to 'payment-service'\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n\n# All instances inherit class addressing\npayment = PaymentMessage.new(amount: 100.00, account_id: \"ACCT-123\")\nputs payment._sm_header.from     # =&gt; 'payment-service'\nputs payment._sm_header.to       # =&gt; 'bank-gateway'\nputs payment._sm_header.reply_to # =&gt; 'payment-service'\n</code></pre>"},{"location":"core-concepts/addressing/#instance-level-overrides","title":"Instance-Level Overrides","text":"<p>Override addressing for specific message instances using multiple approaches:</p>"},{"location":"core-concepts/addressing/#method-chaining","title":"Method Chaining","text":"<pre><code>class FlexibleMessage &lt; SmartMessage::Base\n  header do\n    from 'service-a'\n    to 'service-b'\n  end\n\n  property :data\nend\n\n# Override addressing using method chaining\nmessage = FlexibleMessage.new(data: \"test\")\nmessage.from('different-sender')\n       .to('different-recipient')\n       .reply_to('different-reply-service')\n\nputs message.from     # =&gt; 'different-sender'\nputs message.to       # =&gt; 'different-recipient' \nputs message.reply_to # =&gt; 'different-reply-service'\n</code></pre>"},{"location":"core-concepts/addressing/#setter-methods","title":"Setter Methods","text":"<pre><code># Override addressing using setter syntax\nmessage = FlexibleMessage.new(data: \"test\")\nmessage.from = 'different-sender'\nmessage.to = 'different-recipient'\nmessage.reply_to = 'different-reply-service'\n</code></pre>"},{"location":"core-concepts/addressing/#accessing-addressing-values","title":"Accessing Addressing Values","text":"<pre><code># Three ways to access addressing values\n\n# 1. Direct shortcut methods\nputs message.from      # =&gt; 'different-sender'\nputs message.to        # =&gt; 'different-recipient'\nputs message.reply_to  # =&gt; 'different-reply-service'\n\n# 2. Via header object\nputs message._sm_header.from      # =&gt; 'different-sender'\nputs message._sm_header.to        # =&gt; 'different-recipient'\nputs message._sm_header.reply_to  # =&gt; 'different-reply-service'\n\n# 3. Class defaults remain unchanged\nputs FlexibleMessage.from # =&gt; 'service-a'\nputs FlexibleMessage.to   # =&gt; 'service-b'\n</code></pre>"},{"location":"core-concepts/addressing/#messaging-patterns","title":"Messaging Patterns","text":""},{"location":"core-concepts/addressing/#point-to-point-messaging","title":"Point-to-Point Messaging","text":"<p>Direct communication between two specific entities:</p> <pre><code>class OrderProcessingMessage &lt; SmartMessage::Base\n  from 'order-service'\n  to 'inventory-service'  # Direct target\n  reply_to 'order-service'\n\n  property :order_id, required: true\n  property :items, required: true\nend\n\n# Message goes directly to inventory-service\norder = OrderProcessingMessage.new(\n  order_id: \"ORD-123\", \n  items: [\"widget-1\", \"widget-2\"]\n)\norder.publish  # Only inventory-service receives this\n</code></pre>"},{"location":"core-concepts/addressing/#broadcast-messaging","title":"Broadcast Messaging","text":"<p>Send message to all subscribers by omitting the <code>to</code> field:</p> <pre><code>class SystemMaintenanceMessage &lt; SmartMessage::Base\n  from 'admin-service'\n  # No 'to' field = broadcast\n\n  property :message, required: true\n  property :scheduled_time, required: true\nend\n\n# Message goes to all subscribers\nmaintenance = SystemMaintenanceMessage.new(\n  message: \"System maintenance tonight at 2 AM\",\n  scheduled_time: Time.parse(\"2024-01-15 02:00:00\")\n)\nmaintenance.publish  # All subscribers receive this\n</code></pre>"},{"location":"core-concepts/addressing/#request-reply-pattern","title":"Request-Reply Pattern","text":"<p>Structured request-response communication:</p> <pre><code># Request message\nclass UserLookupRequest &lt; SmartMessage::Base\n  from 'web-service'\n  to 'user-service'\n  reply_to 'web-service'  # Responses come back here\n\n  property :user_id, required: true\n  property :request_id, required: true  # For correlation\nend\n\n# Response message  \nclass UserLookupResponse &lt; SmartMessage::Base\n  from 'user-service'\n  # 'to' will be set to the original 'reply_to' value\n\n  property :user_id, required: true\n  property :request_id, required: true  # Correlation ID\n  property :user_data\n  property :success, default: true\nend\n\n# Send request\nrequest = UserLookupRequest.new(\n  user_id: \"USER-123\",\n  request_id: SecureRandom.uuid\n)\nrequest.publish\n\n# In user-service handler:\nclass UserLookupRequest\n  def self.process(decoded_message)\n    # Process lookup...\n    user_data = UserService.find(decoded_message.user_id)\n\n    # Send response back to reply_to address\n    response = UserLookupResponse.new(\n      user_id: decoded_message.user_id,\n      request_id: decoded_message.request_id,\n      user_data: user_data\n    )\n    response.to(decoded_message._sm_header.reply_to)  # Send to original reply_to\n    response.publish\n  end\nend\n</code></pre>"},{"location":"core-concepts/addressing/#gateway-pattern","title":"Gateway Pattern","text":"<p>Forward messages between different transports/formats:</p> <pre><code>class GatewayMessage &lt; SmartMessage::Base\n  from 'gateway-service'\n\n  property :original_message\n  property :source_format\n  property :target_format\nend\n\n# Receive from one transport/format\nincoming = SomeMessage.new(data: \"from system A\")\n\n# Forward to different system with different addressing\ngateway_msg = GatewayMessage.new(\n  original_message: incoming.to_h,\n  source_format: 'json',\n  target_format: 'xml'\n)\n\n# Override transport and addressing for forwarding\ngateway_msg.config do\n  transport DifferentTransport.new\n  serializer DifferentSerializer.new\nend\ngateway_msg.to('system-b')\ngateway_msg.publish\n</code></pre>"},{"location":"core-concepts/addressing/#address-validation","title":"Address Validation","text":"<p>The <code>from</code> field is required and validated automatically:</p> <pre><code>class InvalidMessage &lt; SmartMessage::Base\n  # No 'from' specified - will fail validation\n  property :data\nend\n\nmessage = InvalidMessage.new(data: \"test\")\nmessage.publish  # Raises SmartMessage::Errors::ValidationError\n# =&gt; \"The property 'from' From entity ID is required for message routing and replies\"\n</code></pre>"},{"location":"core-concepts/addressing/#checking-address-configuration","title":"Checking Address Configuration","text":"<pre><code>class ValidatedMessage &lt; SmartMessage::Base\n  header do\n    from 'my-service'\n    to 'target-service'\n  end\n\n  property :data\nend\n\n# Class-level checks\nputs ValidatedMessage.from_configured?     # =&gt; true\nputs ValidatedMessage.to_configured?       # =&gt; true\nputs ValidatedMessage.reply_to_configured? # =&gt; false\nputs ValidatedMessage.reply_to_missing?    # =&gt; true\n\n# Instance-level checks\nmessage = ValidatedMessage.new(data: \"test\")\nputs message.from_configured?     # =&gt; true\nputs message.to_missing?          # =&gt; false\n\n# Reset addressing\nmessage.reset_from\nputs message.from_configured?     # =&gt; false\nputs message.from                 # =&gt; nil\n</code></pre>"},{"location":"core-concepts/addressing/#header-access","title":"Header Access","text":"<p>Access addressing information from message headers:</p> <pre><code>class SampleMessage &lt; SmartMessage::Base\n  # Using header block for configuration\n  header do\n    from 'sample-service'\n    to 'target-service'\n    reply_to 'callback-service'\n  end\n\n  property :content\nend\n\nmessage = SampleMessage.new(content: \"Hello\")\n\n# Access via shortcut methods (recommended)\nputs message.from      # =&gt; 'sample-service'\nputs message.to        # =&gt; 'target-service'  \nputs message.reply_to  # =&gt; 'callback-service'\n\n# Access via header object\nheader = message._sm_header\nputs header.from      # =&gt; 'sample-service'\nputs header.to        # =&gt; 'target-service'  \nputs header.reply_to  # =&gt; 'callback-service'\nputs header.uuid      # =&gt; Generated UUID\nputs header.message_class  # =&gt; 'SampleMessage'\n\n# Headers automatically sync with instance changes\nmessage.to = 'new-target'\nputs message.to           # =&gt; 'new-target'\nputs header.to            # =&gt; 'new-target' (automatically updated)\n</code></pre>"},{"location":"core-concepts/addressing/#integration-with-dispatcher","title":"Integration with Dispatcher","text":"<p>The dispatcher can use addressing metadata for advanced routing logic:</p> <pre><code># Future enhancement: Dispatcher filtering by recipient\n# dispatcher.route(message_header, payload) do |header|\n#   if header.to.nil?\n#     # Broadcast to all subscribers\n#     route_to_all_subscribers(header.message_class)\n#   else\n#     # Route only to specific recipient\n#     route_to_entity(header.to, header.message_class)\n#   end\n# end\n</code></pre>"},{"location":"core-concepts/addressing/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/addressing/#entity-naming","title":"Entity Naming","text":"<p>Use consistent, descriptive entity identifiers:</p> <pre><code># Good: Descriptive service names\nfrom 'order-management-service'\nto 'inventory-tracking-service'\nreply_to 'order-status-service'\n\n# Avoid: Generic or unclear names\nfrom 'service1'\nto 'app'\n</code></pre>"},{"location":"core-concepts/addressing/#address-consistency","title":"Address Consistency","text":"<p>Maintain consistent addressing patterns across your application:</p> <pre><code># Consistent pattern for microservices\nclass OrderMessage &lt; SmartMessage::Base\n  from 'order-service'\n  to 'fulfillment-service'\n  reply_to 'order-service'\nend\n\nclass PaymentMessage &lt; SmartMessage::Base  \n  from 'payment-service'\n  to 'billing-service'\n  reply_to 'payment-service'\nend\n</code></pre>"},{"location":"core-concepts/addressing/#gateway-configuration","title":"Gateway Configuration","text":"<p>For gateway patterns, use instance-level overrides:</p> <pre><code># Class defines default routing\nclass APIMessage &lt; SmartMessage::Base\n  from 'api-gateway'\n  to 'internal-service'\nend\n\n# Override for external routing\nmessage = APIMessage.new(data: \"external request\")\nmessage.to('external-partner-service')\nmessage.config do\n  transport ExternalTransport.new\n  serializer SecureSerializer.new\nend\nmessage.publish\n</code></pre>"},{"location":"core-concepts/addressing/#future-enhancements","title":"Future Enhancements","text":"<p>The addressing system provides the foundation for advanced features:</p> <ul> <li>Dispatcher Filtering: Route messages based on recipient targeting</li> <li>Security Integration: Entity-based authentication and authorization</li> <li>Audit Trails: Track message flow between entities</li> <li>Load Balancing: Distribute messages across entity instances</li> <li>Circuit Breakers: Per-entity failure handling</li> </ul> <p>Entity addressing enables sophisticated messaging architectures while maintaining the simplicity and flexibility that makes SmartMessage powerful.</p>"},{"location":"core-concepts/architecture/","title":"SmartMessage Architecture","text":"<p>SmartMessage follows a plugin-based architecture that cleanly separates message concerns from transport and serialization mechanisms.</p>"},{"location":"core-concepts/architecture/#design-philosophy","title":"Design Philosophy","text":"<p>SmartMessage is designed around the principle that messages should be independent of their delivery mechanism. Just as ActiveRecord abstracts database operations from business logic, SmartMessage abstracts message delivery from message content.</p>"},{"location":"core-concepts/architecture/#core-principles","title":"Core Principles","text":"<ol> <li>Separation of Concerns: Message content, transport, and serialization are independent</li> <li>Plugin Architecture: Pluggable transports</li> <li>Dual Configuration: Both class-level and instance-level configuration</li> <li>Thread Safety: Concurrent message processing with thread pools</li> <li>Gateway Support: Messages can flow between different transports</li> </ol>"},{"location":"core-concepts/architecture/#architecture-overview","title":"Architecture Overview","text":""},{"location":"core-concepts/architecture/#core-components","title":"Core Components","text":""},{"location":"core-concepts/architecture/#1-smartmessagebase","title":"1. SmartMessage::Base","text":"<p>The foundation class that all messages inherit from, built on <code>Hashie::Dash</code>.</p> <p>Key Responsibilities: - Property management and validation - Plugin configuration (transport, logger) - Message lifecycle management - Header generation and management</p> <p>Location: <code>lib/smart_message/base.rb:17-199</code></p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  description \"Handles custom message processing for my application\"\n\n  property :data\n\n  config do\n    transport MyTransport.new\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#2-transport-layer","title":"2. Transport Layer","text":"<p>Handles message delivery and routing between systems.</p> <p>Key Responsibilities: - Message publishing and receiving - Subscription management - Connection handling - Transport-specific configuration</p> <p>Location: <code>lib/smart_message/transport/</code></p> <pre><code># Transport interface\nclass CustomTransport &lt; SmartMessage::Transport::Base\n  def do_publish(message_class, serialized_message)\n    # Send message via your transport\n  end\n\n  def subscribe(message_class, process_method, filter_options = {})\n    # Set up subscription via dispatcher\n    @dispatcher.add(message_class, process_method, filter_options)\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#3-serializer-system","title":"3. Serializer System","text":"<p>Handles encoding and decoding of message content.</p> <p>Key Responsibilities: - Message encoding (Ruby object \u2192 wire format) - Message decoding (wire format \u2192 Ruby object) - Format-specific handling</p> <p>Location: <code>lib/smart_message/serializer/</code></p> <pre><code>class CustomSerializer &lt; SmartMessage::Serializer::Base\n  def do_encode(message_instance)\n    # Convert message instance to wire format\n    # Default implementation uses message_instance.to_h\n  end\n\n  def do_decode(payload)\n    # Convert from wire format back to hash\n    # Must return hash compatible with message initialization\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#4-dispatcher","title":"4. Dispatcher","text":"<p>Routes incoming messages to appropriate handlers using concurrent processing with integrated deduplication.</p> <p>Key Responsibilities: - Message routing based on class - Thread pool management - Subscription catalog management - Handler-scoped DDQ management - Message filtering and statistics collection</p> <p>Location: <code>lib/smart_message/dispatcher.rb</code></p> <pre><code>dispatcher = SmartMessage::Dispatcher.new\ndispatcher.add(\"MyMessage\", \"MyMessage.process\")\ndispatcher.route(decoded_message)\n\n# DDQ integration is automatic when enabled\nMyMessage.enable_deduplication!\n</code></pre>"},{"location":"core-concepts/architecture/#5-deduplication-queue-ddq","title":"5. Deduplication Queue (DDQ)","text":"<p>Handler-scoped message deduplication system preventing duplicate processing.</p> <p>Key Responsibilities: - UUID-based duplicate detection - Handler isolation (each handler gets own DDQ) - Memory and Redis storage backends - O(1) performance with hybrid Array + Set data structure</p> <p>Architecture:</p> <p></p> <p>Location: <code>lib/smart_message/deduplication.rb</code>, <code>lib/smart_message/ddq/</code></p> <p>Key Features: - Handler-scoped deduplication (each handler gets its own DDQ) - UUID-based duplicate detection - Multiple storage backends (Memory, Redis) - O(1) performance with hybrid Array + Set data structure - Thread-safe operations with mutex locks</p>"},{"location":"core-concepts/architecture/#6-message-headers","title":"6. Message Headers","text":"<p>Standard metadata attached to every message with entity addressing support.</p> <p>Key Responsibilities: - Message identification (UUID) - Routing information (message class, version) - Tracking data (timestamps, process IDs) - Entity addressing (from, to, reply_to)</p> <p>Location: <code>lib/smart_message/header.rb</code></p> <pre><code>header = message._sm_header\nputs header.uuid          # \"550e8400-e29b-41d4-a716-446655440000\"\nputs header.message_class # \"MyMessage\"\nputs header.published_at  # 2025-08-17 10:30:00 UTC\nputs header.publisher_pid # 12345\nputs header.from          # \"payment-service\"\nputs header.to            # \"order-service\"\nputs header.reply_to      # \"payment-service\" (defaults to from)\nputs header.version       # 1\n</code></pre>"},{"location":"core-concepts/architecture/#message-lifecycle","title":"Message Lifecycle","text":""},{"location":"core-concepts/architecture/#1-definition-phase","title":"1. Definition Phase","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:memory)\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#2-subscription-phase","title":"2. Subscription Phase","text":"<pre><code># Basic subscription\nOrderMessage.subscribe\n\n# Subscription with filtering\nOrderMessage.subscribe(from: /^payment-.*/, to: 'order-service')\nOrderMessage.subscribe('PaymentService.process', broadcast: true)\n\n# Each subscription gets its own DDQ automatically\n# DDQ Key: \"OrderMessage:OrderMessage.process\"\n# DDQ Key: \"OrderMessage:PaymentService.process\"\n</code></pre>"},{"location":"core-concepts/architecture/#3-publishing-phase","title":"3. Publishing Phase","text":"<pre><code>order = OrderMessage.new(order_id: \"123\", amount: 99.99)\norder.from(\"order-service\").to(\"payment-service\")\norder.publish\n# 1. Creates header with UUID, timestamp, addressing\n# 2. Encodes message via transport's serializer  \n# 3. Sends via transport\n# 4. Circuit breaker monitors for failures\n</code></pre>"},{"location":"core-concepts/architecture/#4-receiving-phase","title":"4. Receiving Phase","text":"<pre><code># Transport receives serialized message\ntransport.receive(message_class, serialized_message)\n# 1. Decodes message using transport's serializer\n# 2. Routes decoded message to dispatcher\n# 3. Dispatcher checks DDQ for duplicates per handler\n# 4. Applies message filters (from/to/broadcast)\n# 5. Spawns thread for processing matching handlers\n# 6. Marks UUID as processed in handler's DDQ after successful processing\n</code></pre>"},{"location":"core-concepts/architecture/#5-message-handler-processing","title":"5. Message Handler Processing","text":"<p>SmartMessage supports multiple handler types, routed through the dispatcher:</p> <pre><code># Default handler (self.process method) - receives decoded message instance\ndef self.process(decoded_message)\n  order = decoded_message  # Already a fully decoded OrderMessage instance\n  fulfill_order(order)\nend\n\n# Block handler (inline processing) - receives decoded message instance\nOrderMessage.subscribe do |decoded_message|\n  quick_processing(decoded_message)\nend\n\n# Proc handler (reusable across message types) - receives decoded message instance\naudit_proc = proc do |decoded_message|\n  AuditService.log_message(decoded_message.class.name, decoded_message)\nend\nOrderMessage.subscribe(audit_proc)\n\n# Method handler (service class processing) - receives decoded message instance\nclass OrderService\n  def self.process_order(decoded_message)\n    complex_business_logic(decoded_message)\n  end\nend\nOrderMessage.subscribe(\"OrderService.process_order\")\n</code></pre> <p>Handler Routing Process: 1. Dispatcher receives decoded message instance 2. Looks up all registered handlers for message class 3. For each handler that matches filters:    - Checks DDQ for duplicates (handler-scoped)    - String handlers: Resolves to class method via constantize    - Proc handlers: Calls proc directly from registry 4. Executes handlers in parallel threads with circuit breaker protection 5. Marks UUID as processed in handler's DDQ after successful completion 6. Collects statistics and handles errors</p>"},{"location":"core-concepts/architecture/#plugin-system-architecture","title":"Plugin System Architecture","text":""},{"location":"core-concepts/architecture/#dual-level-configuration","title":"Dual-Level Configuration","text":"<p>SmartMessage supports configuration at both class and instance levels:</p> <pre><code># Class-level (default for all instances)\nclass PaymentMessage &lt; SmartMessage::Base\n  config do\n    transport ProductionTransport.new\n  end\nend\n\n# Instance-level (overrides class configuration)\ntest_payment = PaymentMessage.new(amount: 1.00)\ntest_payment.config do\n  transport TestTransport.new  # Override for this instance\nend\n</code></pre> <p>This enables sophisticated gateway patterns where messages can be: - Received from one transport (e.g., RabbitMQ) - Processed with business logic - Republished to another transport (e.g., Kafka)</p>"},{"location":"core-concepts/architecture/#plugin-registration","title":"Plugin Registration","text":"<p>Transports are registered in a central registry:</p> <pre><code># Register custom transport\nSmartMessage::Transport.register(:redis, RedisTransport)\n\n# Use registered transport\nMyMessage.config do\n  transport SmartMessage::Transport.create(:redis, url: \"redis://localhost\")\nend\n</code></pre>"},{"location":"core-concepts/architecture/#thread-safety-concurrency","title":"Thread Safety &amp; Concurrency","text":""},{"location":"core-concepts/architecture/#thread-pool-management","title":"Thread Pool Management","text":"<p>The dispatcher uses <code>Concurrent::CachedThreadPool</code> for processing:</p> <pre><code># Each message processing happens in its own thread with circuit breaker protection\n@router_pool.post do\n  circuit_result = circuit(:message_processor).wrap do\n    if proc_handler?(message_processor)\n      SmartMessage::Base.call_proc_handler(message_processor, decoded_message)\n    else\n      target_class.constantize.method(class_method).call(decoded_message)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#thread-safety-considerations","title":"Thread Safety Considerations","text":"<ol> <li>Message Instances: Each message is processed in isolation</li> <li>Shared State: Avoid shared mutable state in message classes</li> <li>Statistics: Thread-safe statistics collection via <code>SimpleStats</code></li> <li>Graceful Shutdown: Automatic cleanup on process exit</li> </ol>"},{"location":"core-concepts/architecture/#monitoring-thread-pools","title":"Monitoring Thread Pools","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\nstatus = dispatcher.status\n\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\n</code></pre>"},{"location":"core-concepts/architecture/#error-handling-architecture","title":"Error Handling Architecture","text":""},{"location":"core-concepts/architecture/#exception-isolation","title":"Exception Isolation","text":"<p>Processing exceptions are isolated to prevent cascade failures:</p> <pre><code>circuit_result = circuit(:message_processor).wrap do\n  # Handler execution with circuit breaker protection\nend\n\n# Handle circuit breaker fallback responses\nif circuit_result.is_a?(Hash) &amp;&amp; circuit_result[:circuit_breaker]\n  handle_circuit_breaker_fallback(circuit_result, decoded_message, message_processor)\nend\n</code></pre>"},{"location":"core-concepts/architecture/#custom-error-types","title":"Custom Error Types","text":"<p>SmartMessage defines specific error types for different failure modes:</p> <pre><code>module SmartMessage::Errors\n  class TransportNotConfigured &lt; RuntimeError; end\n  class SerializerNotConfigured &lt; RuntimeError; end\n  class NotImplemented &lt; RuntimeError; end\n  class ReceivedMessageNotSubscribed &lt; RuntimeError; end\n  class UnknownMessageClass &lt; RuntimeError; end\n  class ValidationError &lt; RuntimeError; end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#reliability-fault-tolerance","title":"Reliability &amp; Fault Tolerance","text":""},{"location":"core-concepts/architecture/#circuit-breaker-integration","title":"Circuit Breaker Integration","text":"<p>SmartMessage integrates BreakerMachines for production-grade reliability:</p> <pre><code># Circuit breakers are automatically configured for all transports\nclass MyTransport &lt; SmartMessage::Transport::Base\n  # Inherits circuit breaker configuration:\n  # - :transport_publish for publishing operations\n  # - :transport_subscribe for subscription operations\n  # - Automatic DLQ fallback for failed publishes\nend\n</code></pre> <p>Circuit Breaker States: - Closed: Normal operation, requests pass through - Open: Threshold exceeded, requests fail fast - Half-Open: Testing if service recovered</p>"},{"location":"core-concepts/architecture/#dead-letter-queue","title":"Dead Letter Queue","text":"<p>Failed messages are automatically captured in the Dead Letter Queue:</p> <pre><code># Automatic capture when circuit breaker trips\nmessage.publish  # If transport fails, goes to DLQ\n\n# Manual capture for business logic failures\ndlq = SmartMessage::DeadLetterQueue.default\ndlq.enqueue(decoded_message, error: \"Validation failed\", transport: \"manual\")\n</code></pre> <p>DLQ Architecture:</p> <p></p> <p>DLQ Features: - JSON Lines format for efficient append operations - FIFO queue operations with thread safety - Replay capabilities with transport override - Administrative tools for filtering and analysis</p>"},{"location":"core-concepts/architecture/#statistics-monitoring","title":"Statistics &amp; Monitoring","text":""},{"location":"core-concepts/architecture/#built-in-statistics","title":"Built-in Statistics","text":"<p>SmartMessage automatically collects processing statistics including DDQ metrics:</p> <pre><code># Statistics are collected for:\nSS.add(message_class, 'publish')\nSS.add(message_class, process_method, 'routed')\n\n# Access statistics\nputs SS.stat\nputs SS.get(\"MyMessage\", \"publish\")\n\n# DDQ-specific statistics\nstats = OrderMessage.ddq_stats\nputs \"DDQ utilization: #{stats[:utilization]}%\"\nputs \"Current count: #{stats[:current_count]}\"\n</code></pre>"},{"location":"core-concepts/architecture/#monitoring-points","title":"Monitoring Points","text":"<ol> <li>Message Publishing: Count of published messages per class</li> <li>Message Routing: Count of routed messages per processor</li> <li>Thread Pool: Queue length, completed tasks, running status</li> <li>Transport Status: Connection status, message counts</li> <li>DDQ Metrics: Utilization, duplicate detection rates, memory usage</li> <li>Message Filtering: Filter match rates, entity-aware routing statistics</li> </ol>"},{"location":"core-concepts/architecture/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"core-concepts/architecture/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<ol> <li>Class-level defaults: Set via <code>MyMessage.config</code></li> <li>Instance-level overrides: Set via <code>message.config</code></li> <li>Runtime configuration: Dynamic plugin switching</li> </ol>"},{"location":"core-concepts/architecture/#configuration-objects","title":"Configuration Objects","text":"<p>Configuration uses method-based DSL:</p> <pre><code>config do\n  transport MyTransport.new(option1: value1)\n  logger MyLogger.new(level: :debug)\nend\n</code></pre>"},{"location":"core-concepts/architecture/#plugin-resolution","title":"Plugin Resolution","text":"<p>When a message needs a plugin:</p> <ol> <li>Check instance-level configuration</li> <li>Fall back to class-level configuration</li> <li>Raise error if not configured</li> </ol> <pre><code>def transport\n  @transport || self.class.class_variable_get(:@@transport) || raise(Errors::TransportNotConfigured)\nrescue NameError\n  raise(Errors::TransportNotConfigured)\nend\n</code></pre> <p>This architecture provides flexibility while maintaining clear fallback behavior.</p>"},{"location":"core-concepts/dispatcher/","title":"Dispatcher &amp; Message Routing","text":"<p>The dispatcher is the heart of SmartMessage's message routing system. It manages subscriptions, routes incoming messages to appropriate handlers, and coordinates concurrent processing using thread pools.</p>"},{"location":"core-concepts/dispatcher/#overview","title":"Overview","text":"<p>The dispatcher handles: - Subscription Management: Tracking which classes want to receive which messages - Message Routing: Directing incoming messages to registered handlers - Concurrent Processing: Using thread pools for parallel message processing - Statistics Collection: Tracking message processing metrics - Error Isolation: Preventing individual message failures from affecting the system</p>"},{"location":"core-concepts/dispatcher/#core-components","title":"Core Components","text":""},{"location":"core-concepts/dispatcher/#smartmessagedispatcher","title":"SmartMessage::Dispatcher","text":"<p>Located at <code>lib/smart_message/dispatcher.rb:11-147</code>, the dispatcher is the central routing engine.</p> <p>Key Features: - Thread-safe subscription management - Concurrent message processing via <code>Concurrent::CachedThreadPool</code> - Automatic thread pool lifecycle management - Built-in statistics collection - Graceful shutdown handling</p>"},{"location":"core-concepts/dispatcher/#subscription-management","title":"Subscription Management","text":""},{"location":"core-concepts/dispatcher/#adding-subscriptions","title":"Adding Subscriptions","text":"<p>SmartMessage supports multiple subscription patterns:</p> <pre><code># 1. Default handler - uses self.process method\nMyMessage.subscribe\n# Registers \"MyMessage.process\" as the handler\n\n# 2. Custom method handler\nMyMessage.subscribe(\"MyService.handle_message\")\n# Registers \"MyService.handle_message\" as the handler\n\n# 3. Block handler (NEW!)\nhandler_id = MyMessage.subscribe do |header, payload|\n  puts \"Processing: #{JSON.parse(payload)}\"\nend\n# Registers a proc handler with generated ID like \"MyMessage.proc_abc123\"\n\n# 4. Proc handler (NEW!)\nmy_proc = proc { |header, payload| log_message(payload) }\nproc_id = MyMessage.subscribe(my_proc)\n# Registers the proc with generated ID\n\n# 5. Lambda handler (NEW!)\nmy_lambda = lambda { |header, payload| validate_message(payload) }\nlambda_id = MyMessage.subscribe(my_lambda)\n\n# Multiple handlers for the same message\nMyMessage.subscribe(\"MyMessage.audit\")\nMyMessage.subscribe(\"MyMessage.notify\")\nMyMessage.subscribe { |h,p| puts \"Quick log\" }\n# All handlers will receive the message\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-filtering-new","title":"Message Filtering (NEW!)","text":"<p>SmartMessage supports advanced message filtering using exact strings, regular expressions, or arrays for precise message routing:</p> <pre><code># Basic string filtering (exact match)\nMyMessage.subscribe(from: 'payment-service')\nMyMessage.subscribe(to: 'order-processor')\n\n# Regular expression filtering\nMyMessage.subscribe(from: /^payment-.*/)        # All payment services\nMyMessage.subscribe(to: /^(dev|staging)-.*/)    # Development environments\n\n# Array filtering (multiple options)\nMyMessage.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed exact and pattern matching\nMyMessage.subscribe(from: ['admin', /^system-.*/, 'legacy-service'])\n\n# Combined filtering\nMyMessage.subscribe(\n  from: /^admin-.*/, \n  to: ['order-service', /^fulfillment-.*/]\n)\n\n# Broadcast + directed filtering\nMyMessage.subscribe(broadcast: true, to: 'api-service')\n</code></pre>"},{"location":"core-concepts/dispatcher/#filter-types","title":"Filter Types","text":"<p>String Filters (Exact Match) <pre><code># Subscribe only to messages from specific sender\nOrderMessage.subscribe(from: 'payment-service')\n\n# Subscribe only to messages directed to specific recipient\nOrderMessage.subscribe(to: 'order-processor')\n</code></pre></p> <p>Regular Expression Filters (Pattern Match) <pre><code># Environment-based routing\nDevService.subscribe(to: /^(dev|staging)-.*/)\nProdService.subscribe(to: /^prod-.*/)\n\n# Service pattern routing\nPaymentProcessor.subscribe(from: /^payment-.*/)\nApiService.subscribe(from: /^(web|mobile|api)-.*/)\n</code></pre></p> <p>Array Filters (Multiple Options) <pre><code># Multiple specific services\nAdminService.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed patterns and exact matches\nAlertService.subscribe(from: ['admin', /^system-.*/, 'security'])\n</code></pre></p> <p>Combined Filters <pre><code># Complex multi-criteria filtering\nOrderMessage.subscribe(\n  from: /^(admin|system)-.*/, \n  to: ['order-service', /^fulfillment-.*/]\n)\n\n# Admin services to production only\nAdminMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)\n</code></pre></p>"},{"location":"core-concepts/dispatcher/#filter-validation","title":"Filter Validation","text":"<p>Filters are validated at subscription time:</p> <pre><code># Valid filters\nMyMessage.subscribe(from: 'service')           # String\nMyMessage.subscribe(from: /^service-.*/)       # Regexp  \nMyMessage.subscribe(from: ['a', /^b-.*/])      # Array of String/Regexp\n\n# Invalid filters (raise ArgumentError)\nMyMessage.subscribe(from: 123)                 # Invalid type\nMyMessage.subscribe(from: ['valid', 123])      # Invalid array element\n</code></pre>"},{"location":"core-concepts/dispatcher/#removing-subscriptions","title":"Removing Subscriptions","text":"<pre><code># Remove specific method handler\nMyMessage.unsubscribe(\"MyMessage.custom_handler\")\n\n# Remove specific proc/block handler using returned ID\nblock_id = MyMessage.subscribe { |h,p| puts p }\nMyMessage.unsubscribe(block_id)  # Cleans up proc from registry too\n\n# Remove ALL handlers for a message class\nMyMessage.unsubscribe!\n\n# Remove all subscriptions (useful for testing)\ndispatcher = SmartMessage::Dispatcher.new\ndispatcher.drop_all!\n</code></pre>"},{"location":"core-concepts/dispatcher/#viewing-subscriptions","title":"Viewing Subscriptions","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# View all subscriptions\nputs dispatcher.subscribers\n# =&gt; {\"MyMessage\" =&gt; [\"MyMessage.process\", \"MyMessage.audit\"]}\n\n# Check specific message subscriptions\nputs dispatcher.subscribers[\"MyMessage\"]\n# =&gt; [\"MyMessage.process\", \"MyMessage.audit\"]\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-routing-process","title":"Message Routing Process","text":""},{"location":"core-concepts/dispatcher/#1-message-reception","title":"1. Message Reception","text":"<p>When a transport receives a message, it calls the dispatcher:</p> <pre><code># Transport receives serialized message and routes it\ntransport.receive(message_class, serialized_message)\n# This internally decodes the message and calls:\ndispatcher.route(decoded_message)\n</code></pre>"},{"location":"core-concepts/dispatcher/#2-subscription-lookup","title":"2. Subscription Lookup","text":"<p>The dispatcher finds all registered handlers:</p> <pre><code>def route(decoded_message)\n  message_klass = decoded_message._sm_header.message_class\n  return nil if @subscribers[message_klass].empty?\n\n  @subscribers[message_klass].each do |subscription|\n    # Process each handler with filters\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#3-concurrent-processing","title":"3. Concurrent Processing","text":"<p>Each handler is processed in its own thread, with support for both method and proc handlers:</p> <pre><code>@subscribers[message_klass].each do |subscription|\n  message_processor = subscription[:process_method]\n  SS.add(message_klass, message_processor, 'routed')\n\n  @router_pool.post do\n    # This runs in a separate thread with circuit breaker protection\n    circuit_result = circuit(:message_processor).wrap do\n      # Check if this is a proc handler or a regular method call\n      if proc_handler?(message_processor)\n        # Call the proc handler via SmartMessage::Base\n        SmartMessage::Base.call_proc_handler(message_processor, decoded_message)\n      else\n        # Original method call logic\n        parts = message_processor.split('.')\n        target_klass = parts[0]  # \"MyMessage\" \n        class_method = parts[1]  # \"process\"\n\n        target_klass.constantize\n                    .method(class_method)\n                    .call(decoded_message)\n      end\n    end\n\n    # Handle circuit breaker fallback if triggered\n    if circuit_result.is_a?(Hash) &amp;&amp; circuit_result[:circuit_breaker]\n      handle_circuit_breaker_fallback(circuit_result, decoded_message, message_processor)\n    end\n  end\nend\n</code></pre> <p>Handler Types Processed: - Method handlers: <code>\"ClassName.method_name\"</code> \u2192 resolved via constantize - Proc handlers: <code>\"ClassName.proc_abc123\"</code> \u2192 looked up in proc registry - Block handlers: <code>\"ClassName.proc_def456\"</code> \u2192 treated as proc handlers - Lambda handlers: <code>\"ClassName.proc_ghi789\"</code> \u2192 treated as proc handlers</p>"},{"location":"core-concepts/dispatcher/#thread-pool-management","title":"Thread Pool Management","text":""},{"location":"core-concepts/dispatcher/#thread-pool-configuration","title":"Thread Pool Configuration","text":"<p>The dispatcher uses <code>Concurrent::CachedThreadPool</code> which automatically manages thread creation and destruction:</p> <pre><code>def initialize\n  @router_pool = Concurrent::CachedThreadPool.new\n\n  # Automatic cleanup on exit\n  at_exit do\n    shutdown_thread_pool\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#monitoring-thread-pool-status","title":"Monitoring Thread Pool Status","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# Get comprehensive status\nstatus = dispatcher.status\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Scheduled tasks: #{status[:scheduled_task_count]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\nputs \"Current threads: #{status[:length]}\"\n\n# Individual status methods\nputs dispatcher.running?              # Is the pool active?\nputs dispatcher.queue_length          # How many tasks are waiting?\nputs dispatcher.scheduled_task_count  # Total tasks scheduled\nputs dispatcher.completed_task_count  # Total tasks completed\nputs dispatcher.current_length        # Current number of threads\n</code></pre>"},{"location":"core-concepts/dispatcher/#thread-pool-lifecycle","title":"Thread Pool Lifecycle","text":"<pre><code># Automatic shutdown handling\nat_exit do\n  print \"Shutting down the dispatcher's thread pool...\"\n  @router_pool.shutdown\n\n  while @router_pool.shuttingdown?\n    print '.'\n    sleep 1\n  end\n\n  puts \" done.\"\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-processing-patterns","title":"Message Processing Patterns","text":""},{"location":"core-concepts/dispatcher/#standard-processing","title":"Standard Processing","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :items\n\n  # Standard process method\n  def self.process(message_header, message_payload)\n    # 1. Decode the message\n    data = JSON.parse(message_payload)\n    order = new(data)\n\n    # 2. Execute business logic\n    fulfill_order(order)\n\n    # 3. Optional: publish follow-up messages\n    ShippingMessage.new(\n      order_id: order.order_id,\n      address: get_shipping_address(order.customer_id)\n    ).publish\n  end\n\n  private\n\n  def self.fulfill_order(order)\n    # Business logic here\n  end\nend\n\n# Subscribe to receive messages\nOrderMessage.subscribe\n</code></pre>"},{"location":"core-concepts/dispatcher/#multiple-handlers","title":"Multiple Handlers","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  property :payment_id\n  property :amount\n  property :customer_id\n\n  # Primary payment processing\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    process_payment(payment)\n  end\n\n  # Audit logging handler\n  def self.audit(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    log_payment_attempt(payment)\n  end\n\n  # Fraud detection handler\n  def self.fraud_check(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    if suspicious_payment?(payment)\n      flag_for_review(payment)\n    end\n  end\nend\n\n# Register all handlers\nPaymentMessage.subscribe(\"PaymentMessage.process\")\nPaymentMessage.subscribe(\"PaymentMessage.audit\")\nPaymentMessage.subscribe(\"PaymentMessage.fraud_check\")\n</code></pre>"},{"location":"core-concepts/dispatcher/#error-handling-in-processors","title":"Error Handling in Processors","text":"<pre><code>class RobustMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    begin\n      data = JSON.parse(message_payload)\n      message = new(data)\n\n      # Main processing logic\n      process_business_logic(message)\n\n    rescue JSON::ParserError =&gt; e\n      # Handle malformed messages\n      log_error(\"Invalid message format\", message_header, e)\n\n    rescue BusinessLogicError =&gt; e\n      # Handle business logic failures\n      log_error(\"Business logic failed\", message_header, e)\n\n      # Optionally republish to error queue\n      ErrorMessage.new(\n        original_message: message_payload,\n        error: e.message,\n        retry_count: get_retry_count(message_header)\n      ).publish\n\n    rescue =&gt; e\n      # Handle unexpected errors\n      log_error(\"Unexpected error\", message_header, e)\n      raise  # Re-raise to trigger dispatcher error handling\n    end\n  end\n\n  private\n\n  def self.log_error(type, header, error)\n    puts \"#{type}: #{error.message}\"\n    puts \"Message class: #{header.message_class}\"\n    puts \"Message UUID: #{header.uuid}\"\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#advanced-routing-patterns","title":"Advanced Routing Patterns","text":""},{"location":"core-concepts/dispatcher/#conditional-processing","title":"Conditional Processing","text":"<pre><code>class ConditionalMessage &lt; SmartMessage::Base\n  property :environment\n  property :data\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Route based on message content\n    case message.environment\n    when 'production'\n      production_handler(message)\n    when 'staging'\n      staging_handler(message)\n    when 'development'\n      development_handler(message)\n    else\n      default_handler(message)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-transformation-and-republishing","title":"Message Transformation and Republishing","text":"<pre><code>class TransformMessage &lt; SmartMessage::Base\n  property :raw_data\n  property :format\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Transform the message\n    case message.format\n    when 'csv'\n      transformed = transform_csv(message.raw_data)\n    when 'xml'\n      transformed = transform_xml(message.raw_data)\n    else\n      transformed = message.raw_data\n    end\n\n    # Republish as a different message type\n    ProcessedMessage.new(\n      original_id: message_header.uuid,\n      processed_data: transformed,\n      processed_at: Time.now\n    ).publish\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#fan-out-processing","title":"Fan-out Processing","text":"<pre><code>class EventMessage &lt; SmartMessage::Base\n  property :event_type\n  property :user_id\n  property :data\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    event = new(data)\n\n    # Fan out to multiple specialized handlers\n    case event.event_type\n    when 'user_signup'\n      WelcomeEmailMessage.new(user_id: event.user_id).publish\n      AnalyticsMessage.new(event: 'signup', user_id: event.user_id).publish\n      AuditMessage.new(action: 'user_created', user_id: event.user_id).publish\n\n    when 'purchase'\n      InventoryMessage.new(items: event.data['items']).publish\n      ReceiptMessage.new(user_id: event.user_id, total: event.data['total']).publish\n      LoyaltyMessage.new(user_id: event.user_id, points: calculate_points(event.data)).publish\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#statistics-and-monitoring","title":"Statistics and Monitoring","text":""},{"location":"core-concepts/dispatcher/#built-in-statistics","title":"Built-in Statistics","text":"<p>The dispatcher automatically collects statistics via the <code>SimpleStats</code> (<code>SS</code>) system:</p> <pre><code># Statistics are automatically collected for:\n# - Message publishing: SS.add(message_class, 'publish')\n# - Message routing: SS.add(message_class, process_method, 'routed')\n\n# View all statistics\nputs SS.stat\n\n# Get specific statistics\npublish_count = SS.get(\"MyMessage\", \"publish\")\nprocess_count = SS.get(\"MyMessage\", \"MyMessage.process\", \"routed\")\n\n# Reset statistics\nSS.reset  # Clear all\nSS.reset(\"MyMessage\", \"publish\")  # Clear specific stat\n</code></pre>"},{"location":"core-concepts/dispatcher/#custom-monitoring","title":"Custom Monitoring","text":"<pre><code>class MonitoredMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    start_time = Time.now\n\n    begin\n      # Process the message\n      data = JSON.parse(message_payload)\n      message = new(data)\n\n      process_business_logic(message)\n\n      # Record success metrics\n      record_processing_time(Time.now - start_time)\n      increment_success_counter\n\n    rescue =&gt; e\n      # Record failure metrics\n      record_error(e)\n      increment_failure_counter\n      raise\n    end\n  end\n\n  private\n\n  def self.record_processing_time(duration)\n    SS.add(\"MonitoredMessage\", \"processing_time\", how_many: duration)\n  end\n\n  def self.increment_success_counter\n    SS.add(\"MonitoredMessage\", \"success\")\n  end\n\n  def self.increment_failure_counter\n    SS.add(\"MonitoredMessage\", \"failure\")\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#performance-considerations","title":"Performance Considerations","text":""},{"location":"core-concepts/dispatcher/#thread-pool-sizing","title":"Thread Pool Sizing","text":"<p>The <code>CachedThreadPool</code> automatically manages thread creation, but you can influence behavior:</p> <pre><code># For high-throughput scenarios, consider a custom thread pool\nclass CustomDispatcher &lt; SmartMessage::Dispatcher\n  def initialize(min_threads: 5, max_threads: 50)\n    @router_pool = Concurrent::ThreadPoolExecutor.new(\n      min_threads: min_threads,\n      max_threads: max_threads,\n      max_queue: 1000,\n      fallback_policy: :caller_runs\n    )\n\n    # Rest of initialization\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#processing-optimization","title":"Processing Optimization","text":"<pre><code>class OptimizedMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    # Parse once, use multiple times\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Batch operations when possible\n    batch_operations(message)\n\n    # Use connection pooling for database operations\n    connection_pool.with do |conn|\n      save_to_database(message, conn)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#testing-dispatcher-behavior","title":"Testing Dispatcher Behavior","text":""},{"location":"core-concepts/dispatcher/#dispatcher-testing","title":"Dispatcher Testing","text":"<pre><code>RSpec.describe SmartMessage::Dispatcher do\n  let(:dispatcher) { SmartMessage::Dispatcher.new }\n\n  before do\n    dispatcher.drop_all!  # Clear subscriptions\n  end\n\n  describe \"subscription management\" do\n    it \"adds subscriptions\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n\n      expect(dispatcher.subscribers[\"TestMessage\"]).to include(\"TestMessage.process\")\n    end\n\n    it \"removes subscriptions\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n      dispatcher.drop(\"TestMessage\", \"TestMessage.process\")\n\n      expect(dispatcher.subscribers[\"TestMessage\"]).not_to include(\"TestMessage.process\")\n    end\n  end\n\n  describe \"message routing\" do\n    let(:header) { double(\"header\", message_class: \"TestMessage\") }\n    let(:payload) { '{\"data\": \"test\"}' }\n\n    before do\n      # Mock the message class\n      stub_const(\"TestMessage\", Class.new do\n        def self.process(header, payload)\n          @processed_messages ||= []\n          @processed_messages &lt;&lt; [header, payload]\n        end\n\n        def self.processed_messages\n          @processed_messages || []\n        end\n      end)\n    end\n\n    it \"routes messages to subscribers\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n      dispatcher.route(header, payload)\n\n      # Wait for async processing\n      sleep 0.1\n\n      expect(TestMessage.processed_messages).to have(1).message\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-processing-testing","title":"Message Processing Testing","text":"<pre><code>RSpec.describe \"Message Processing\" do\n  let(:transport) { SmartMessage::Transport.create(:memory, auto_process: true) }\n\n  before do\n    TestMessage.config do\n      transport transport\n      serializer SmartMessage::Serializer::Json.new\n    end\n\n    TestMessage.subscribe\n  end\n\n  it \"processes published messages\" do\n    expect(TestMessage).to receive(:process).once\n\n    TestMessage.new(data: \"test\").publish\n\n    # Wait for async processing\n    sleep 0.1\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#next-steps","title":"Next Steps","text":"<ul> <li>Troubleshooting - Common dispatcher issues</li> </ul>"},{"location":"core-concepts/message-filtering/","title":"Message Filtering","text":"<p>SmartMessage provides powerful message filtering capabilities that allow subscribers to receive only messages that match specific criteria. This enables sophisticated routing patterns for microservices architectures, environment-based deployment, and fine-grained message processing control.</p>"},{"location":"core-concepts/message-filtering/#overview","title":"Overview","text":"<p>Message filtering works at the subscription level, allowing you to specify criteria that incoming messages must match before being routed to your handlers. Filters support:</p> <ul> <li>Exact string matching for precise service identification</li> <li>Regular expression patterns for flexible service groups and environments</li> <li>Arrays combining strings and regexps for complex matching scenarios</li> <li>Multi-criteria filtering using both <code>from</code> and <code>to</code> constraints</li> </ul>"},{"location":"core-concepts/message-filtering/#filter-dimensions","title":"Filter Dimensions","text":"<p>Messages can be filtered on two main dimensions:</p>"},{"location":"core-concepts/message-filtering/#from-message-sender-filtering","title":"<code>from:</code> - Message Sender Filtering","text":"<p>Filter messages based on who sent them:</p> <pre><code># Exact sender\nPaymentService.subscribe(from: 'payment-gateway')\n\n# Pattern matching for sender groups\nPaymentService.subscribe(from: /^payment-.*/)\n\n# Multiple specific senders\nAdminService.subscribe(from: ['admin', 'system', 'monitoring'])\n</code></pre>"},{"location":"core-concepts/message-filtering/#to-message-recipient-filtering","title":"<code>to:</code> - Message Recipient Filtering","text":"<p>Filter messages based on their intended recipient:</p> <pre><code># Exact recipient\nOrderService.subscribe(to: 'order-processor')\n\n# Environment-based routing\nDevService.subscribe(to: /^(dev|staging)-.*/)\nProdService.subscribe(to: /^prod-.*/)\n\n# Multiple target patterns\nApiService.subscribe(to: [/^api-.*/, /^web-.*/, 'gateway'])\n</code></pre>"},{"location":"core-concepts/message-filtering/#broadcast-broadcast-message-filtering","title":"<code>broadcast:</code> - Broadcast Message Filtering","text":"<p>Filter for broadcast messages (messages with <code>to: nil</code>):</p> <pre><code># Only broadcast messages\nNotificationService.subscribe(broadcast: true)\n\n# Broadcast OR directed messages (OR logic)\nAlertService.subscribe(broadcast: true, to: 'alert-service')\n</code></pre>"},{"location":"core-concepts/message-filtering/#filter-types","title":"Filter Types","text":""},{"location":"core-concepts/message-filtering/#string-filters-exact-match","title":"String Filters (Exact Match)","text":"<p>String filters match exactly:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  # Configure message\nend\n\n# Subscribe to messages from exactly 'payment-service'\nOrderMessage.subscribe(from: 'payment-service')\n\n# Subscribe to messages directed to exactly 'order-processor'\nOrderMessage.subscribe(to: 'order-processor')\n\n# Combined exact matching\nOrderMessage.subscribe(from: 'admin', to: 'order-service')\n</code></pre>"},{"location":"core-concepts/message-filtering/#regular-expression-filters-pattern-match","title":"Regular Expression Filters (Pattern Match)","text":"<p>Regex filters provide flexible pattern matching:</p> <pre><code># Environment-based routing\nOrderMessage.subscribe(to: /^(dev|staging)-.*/)  # dev-api, staging-worker, etc.\nOrderMessage.subscribe(to: /^prod-.*/)           # prod-api, prod-worker, etc.\n\n# Service type routing  \nOrderMessage.subscribe(from: /^payment-.*/)      # payment-gateway, payment-processor\nOrderMessage.subscribe(from: /^(api|web)-.*/)    # api-server, web-frontend\n\n# Complex patterns\nOrderMessage.subscribe(from: /^admin-(dev|staging)-.+/)  # admin-dev-panel, admin-staging-api\n</code></pre>"},{"location":"core-concepts/message-filtering/#array-filters-multiple-options","title":"Array Filters (Multiple Options)","text":"<p>Arrays allow combining exact strings and regex patterns:</p> <pre><code># Multiple exact matches\nOrderMessage.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed strings and patterns\nOrderMessage.subscribe(from: [\n  'admin',              # Exact match\n  /^system-.*/, # Pattern match\n  'legacy-service'      # Another exact match\n])\n\n# Multiple patterns\nOrderMessage.subscribe(to: [\n  /^api-.*/,     # All API services  \n  /^web-.*/,     # All web services\n  'gateway'      # Plus specific gateway\n])\n</code></pre>"},{"location":"core-concepts/message-filtering/#combined-filters-multi-criteria","title":"Combined Filters (Multi-Criteria)","text":"<p>Combine <code>from</code>, <code>to</code>, and <code>broadcast</code> filters:</p> <pre><code># Admin services to production environments only\nOrderMessage.subscribe(\n  from: /^admin-.*/, \n  to: /^prod-.*/\n)\n\n# Specific senders to multiple recipient types\nOrderMessage.subscribe(\n  from: ['payment-gateway', 'billing-service'],\n  to: [/^order-.*/, /^fulfillment-.*/]\n)\n\n# Complex routing scenarios\nOrderMessage.subscribe(\n  from: /^(admin|system)-.*/,\n  to: ['critical-service', /^prod-.*/]\n)\n</code></pre>"},{"location":"core-concepts/message-filtering/#use-cases-and-patterns","title":"Use Cases and Patterns","text":""},{"location":"core-concepts/message-filtering/#environment-based-routing","title":"Environment-Based Routing","text":"<p>Route messages based on deployment environments:</p> <pre><code># Development services\nclass DevOrderProcessor &lt; SmartMessage::Base\n  # Only receive messages to dev/staging environments\n  DevOrderProcessor.subscribe(to: /^(dev|staging)-.*/)\nend\n\n# Production services  \nclass ProdOrderProcessor &lt; SmartMessage::Base\n  # Only receive messages to production environments\n  ProdOrderProcessor.subscribe(to: /^prod-.*/)\nend\n\n# Cross-environment admin tools\nclass AdminDashboard &lt; SmartMessage::Base\n  # Receive admin messages from any environment\n  AdminDashboard.subscribe(from: /^admin-.*/)\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#service-pattern-routing","title":"Service Pattern Routing","text":"<p>Route based on service naming conventions:</p> <pre><code># Payment services ecosystem\nclass PaymentProcessor &lt; SmartMessage::Base\n  # Receive from all payment-related services\n  PaymentProcessor.subscribe(from: /^payment-.*/)\nend\n\n# API layer services\nclass ApiGateway &lt; SmartMessage::Base\n  # Receive from web frontends and mobile apps\n  ApiGateway.subscribe(from: /^(web|mobile|api)-.*/)\nend\n\n# Monitoring and alerting\nclass MonitoringService &lt; SmartMessage::Base\n  # Receive from all system monitoring components\n  MonitoringService.subscribe(from: /^(system|monitor|health)-.*/)\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#administrative-and-security-routing","title":"Administrative and Security Routing","text":"<p>Route administrative and security messages:</p> <pre><code># Security monitoring\nclass SecurityService &lt; SmartMessage::Base\n  # Admin + security services + any system monitoring\n  SecurityService.subscribe(from: ['admin', /^security-.*/, /^system-monitor.*/])\nend\n\n# Audit logging\nclass AuditService &lt; SmartMessage::Base\n  # Capture all admin actions across environments\n  AuditService.subscribe(from: /^admin-.*/)\nend\n\n# Operations dashboard\nclass OpsDashboard &lt; SmartMessage::Base\n  # Operational messages + broadcasts\n  OpsDashboard.subscribe(\n    broadcast: true,\n    from: /^(ops|admin|system)-.*/\n  )\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#gateway-and-transformation-patterns","title":"Gateway and Transformation Patterns","text":"<p>Filter for message transformation and routing:</p> <pre><code># Message format gateway\nclass FormatGateway &lt; SmartMessage::Base\n  # Receive legacy format messages for transformation\n  FormatGateway.subscribe(from: ['legacy-system', /^old-.*/, 'mainframe'])\n\n  def self.process(header, payload)\n    # Transform and republish\n    transformed = transform_legacy_format(payload)\n    ModernMessage.new(transformed).publish\n  end\nend\n\n# Environment promotion gateway\nclass PromotionGateway &lt; SmartMessage::Base\n  # Receive staging-approved messages for prod promotion\n  PromotionGateway.subscribe(\n    from: /^staging-.*/, \n    to: 'promotion-queue'\n  )\n\n  def self.process(header, payload)\n    # Republish to production\n    data = JSON.parse(payload)\n    republish_to_production(data)\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#filter-validation","title":"Filter Validation","text":"<p>SmartMessage validates filter parameters at subscription time to prevent runtime errors:</p>"},{"location":"core-concepts/message-filtering/#valid-filter-types","title":"Valid Filter Types","text":"<pre><code># String filters\nMyMessage.subscribe(from: 'service-name')\n\n# Regex filters  \nMyMessage.subscribe(from: /^service-.*/)\n\n# Array filters with strings and regexes\nMyMessage.subscribe(from: ['exact-service', /^pattern-.*/, 'another-service'])\n\n# Combined filters\nMyMessage.subscribe(from: /^admin-.*/, to: ['service-a', /^prod-.*/])\n</code></pre>"},{"location":"core-concepts/message-filtering/#invalid-filter-types","title":"Invalid Filter Types","text":"<p>These will raise <code>ArgumentError</code> at subscription time:</p> <pre><code># Invalid primitive types\nMyMessage.subscribe(from: 123)                    # Numbers not allowed\nMyMessage.subscribe(from: true)                   # Booleans not allowed  \nMyMessage.subscribe(from: {key: 'value'})         # Hashes not allowed\n\n# Invalid array elements\nMyMessage.subscribe(from: ['valid', 123])         # Mixed valid/invalid\nMyMessage.subscribe(from: [/valid/, Object.new])  # Mixed valid/invalid\n</code></pre>"},{"location":"core-concepts/message-filtering/#implementation-details","title":"Implementation Details","text":""},{"location":"core-concepts/message-filtering/#filter-processing","title":"Filter Processing","text":"<p>Internally, filters are processed by the dispatcher's <code>message_matches_filters?</code> method:</p> <ol> <li>Normalization: String and Regexp values are converted to arrays</li> <li>Validation: Array elements are validated to be String or Regexp only</li> <li>Matching: For each filter array, check if message value matches any element:</li> <li>String elements: exact equality (<code>filter == value</code>)</li> <li>Regexp elements: pattern matching (<code>filter.match?(value)</code>)</li> </ol>"},{"location":"core-concepts/message-filtering/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>String matching: Very fast hash-based equality</li> <li>Regex matching: Slightly slower but still performant for typical patterns</li> <li>Array processing: Linear scan through filter array (typically small)</li> <li>Filter caching: Normalized filters are cached in subscription objects</li> </ul>"},{"location":"core-concepts/message-filtering/#memory-usage","title":"Memory Usage","text":"<ul> <li>Filter arrays are stored per subscription</li> <li>Regex objects are shared (Ruby optimizes identical regex literals)</li> <li>No dynamic regex compilation during message processing</li> </ul>"},{"location":"core-concepts/message-filtering/#testing-filtered-subscriptions","title":"Testing Filtered Subscriptions","text":""},{"location":"core-concepts/message-filtering/#basic-filter-testing","title":"Basic Filter Testing","text":"<pre><code>class FilterTest &lt; Minitest::Test\n  def setup\n    @transport = SmartMessage::Transport.create(:memory, auto_process: true)\n    TestMessage.config do\n      transport @transport\n      serializer SmartMessage::Serializer::Json.new\n    end\n    TestMessage.unsubscribe!\n  end\n\n  def test_string_filter\n    TestMessage.subscribe(from: 'payment-service')\n\n    # Should match\n    message = TestMessage.new(data: 'test')\n    message.from('payment-service')\n    message.publish\n\n    # Should not match\n    message = TestMessage.new(data: 'test')  \n    message.from('user-service')\n    message.publish\n\n    # Verify only one message was processed\n    assert_equal 1, processed_message_count\n  end\n\n  def test_regex_filter\n    TestMessage.subscribe(from: /^payment-.*/)\n\n    # Should match\n    ['payment-gateway', 'payment-processor'].each do |sender|\n      message = TestMessage.new(data: 'test')\n      message.from(sender)\n      message.publish\n    end\n\n    # Should not match\n    message = TestMessage.new(data: 'test')\n    message.from('user-service')\n    message.publish\n\n    # Verify two messages were processed\n    assert_equal 2, processed_message_count\n  end\n\n  def test_combined_filter\n    TestMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)\n\n    # Should match\n    message = TestMessage.new(data: 'test')\n    message.from('admin-panel')\n    message.to('prod-api')\n    message.publish\n\n    # Should not match (wrong from)\n    message = TestMessage.new(data: 'test')\n    message.from('user-panel')\n    message.to('prod-api')\n    message.publish\n\n    # Should not match (wrong to)\n    message = TestMessage.new(data: 'test')\n    message.from('admin-panel')\n    message.to('dev-api')\n    message.publish\n\n    # Verify only one message was processed\n    assert_equal 1, processed_message_count\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#performance-testing","title":"Performance Testing","text":"<pre><code>def test_filter_performance\n  # Setup large number of subscriptions with different filters\n  1000.times do |i|\n    TestMessage.subscribe(\"TestMessage.handler_#{i}\", from: \"service-#{i}\")\n  end\n\n  start_time = Time.now\n\n  # Publish many messages\n  100.times do |i|\n    message = TestMessage.new(data: i)\n    message.from(\"service-#{i % 10}\")  # Will match some filters\n    message.publish\n  end\n\n  processing_time = Time.now - start_time\n\n  # Verify performance is acceptable\n  assert processing_time &lt; 1.0, \"Filter processing took too long: #{processing_time}s\"\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#migration-guide","title":"Migration Guide","text":""},{"location":"core-concepts/message-filtering/#upgrading-from-string-only-filters","title":"Upgrading from String-Only Filters","text":"<p>If you're upgrading from a version that only supported string filters:</p> <pre><code># Old (still works)\nMyMessage.subscribe(from: 'exact-service')\nMyMessage.subscribe(from: ['service-a', 'service-b'])\n\n# New capabilities\nMyMessage.subscribe(from: /^service-.*/)                    # Regex patterns\nMyMessage.subscribe(from: ['exact', /^pattern-.*/])         # Mixed arrays\nMyMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)      # Combined criteria\n</code></pre>"},{"location":"core-concepts/message-filtering/#error-handling-changes","title":"Error Handling Changes","text":"<p>Previous versions may have failed silently with invalid filters. The new implementation validates at subscription time:</p> <pre><code># This will now raise ArgumentError instead of failing silently\nbegin\n  MyMessage.subscribe(from: 123)  # Invalid type\nrescue ArgumentError =&gt; e\n  puts \"Filter validation failed: #{e.message}\"\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#next-steps","title":"Next Steps","text":"<ul> <li>Dispatcher Documentation - How filtering integrates with message routing</li> <li>Entity Addressing - Understanding <code>from</code>, <code>to</code>, and <code>reply_to</code> fields  </li> <li>Examples - Complete working examples with filtering</li> </ul>"},{"location":"core-concepts/message-processing/","title":"Message Processing in SmartMessage","text":""},{"location":"core-concepts/message-processing/#understanding-the-selfprocess-method","title":"Understanding the <code>self.process</code> Method","text":"<p>The <code>self.process</code> method in SmartMessage classes serves as the default message handler. It defines what should happen when a message of that type is received by a subscriber.</p>"},{"location":"core-concepts/message-processing/#purpose-of-selfprocess","title":"Purpose of <code>self.process</code>","text":"<p>The <code>self.process</code> method defines what happens when a message is received. It's the entry point for processing incoming messages of that type.</p>"},{"location":"core-concepts/message-processing/#how-it-works","title":"How it Works","text":""},{"location":"core-concepts/message-processing/#1-message-publishing-flow","title":"1. Message Publishing Flow","text":"<pre><code># Someone publishes a message\nSensorDataMessage.new(device_id: \"THERM-001\", value: 22.5).publish\n</code></pre>"},{"location":"core-concepts/message-processing/#2-subscription-routing","title":"2. Subscription &amp; Routing","text":"<pre><code># A class subscribes to receive messages\nSensorDataMessage.subscribe  # Uses default \"SensorDataMessage.process\"\n# OR with custom method\nSensorDataMessage.subscribe(\"MyService.custom_handler\")\n</code></pre>"},{"location":"core-concepts/message-processing/#3-message-processing","title":"3. Message Processing","text":"<p>When a message arrives, the dispatcher calls the registered handler method with: - <code>message_header</code> - metadata (timestamp, UUID, message class, etc.) - <code>message_payload</code> - the serialized message data (usually JSON)</p>"},{"location":"core-concepts/message-processing/#message-handler-options","title":"Message Handler Options","text":"<p>SmartMessage supports multiple ways to handle incoming messages:</p>"},{"location":"core-concepts/message-processing/#1-default-handler-pattern-using-selfprocess","title":"1. Default Handler Pattern (using <code>self.process</code>)","text":"<pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # This gets called when a SensorDataMessage is received\n    # decoded_message is already a message instance\n    puts \"Sensor reading: #{data['value']}\"\n  end\nend\n\nSensorDataMessage.subscribe  # Uses \"SensorDataMessage.process\"\n</code></pre>"},{"location":"core-concepts/message-processing/#2-custom-method-handler-pattern","title":"2. Custom Method Handler Pattern","text":"<pre><code>class ThermostatService\n  def self.handle_sensor_data(message_header, message_payload)\n    # Custom processing logic\n    # decoded_message is already a message instance\n    adjust_temperature(data)\n  end\nend\n\nSensorDataMessage.subscribe(\"ThermostatService.handle_sensor_data\")\n</code></pre>"},{"location":"core-concepts/message-processing/#3-block-handler-pattern-new","title":"3. Block Handler Pattern (NEW)","text":"<pre><code># Subscribe with a block - perfect for simple handlers\nSensorDataMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"Temperature: #{data['value']}\u00b0C from #{data['device_id']}\"\n\n  # You can access header information too\n  puts \"Received at: #{header.published_at}\"\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#4-proclambda-handler-pattern-new","title":"4. Proc/Lambda Handler Pattern (NEW)","text":"<pre><code># Create a reusable handler\ntemperature_handler = proc do |header, payload|\n  data = JSON.parse(payload)\n  if data['value'] &gt; 30\n    puts \"\u26a0\ufe0f High temperature alert: #{data['value']}\u00b0C\"\n  end\nend\n\n# Use the proc as a handler\nSensorDataMessage.subscribe(temperature_handler)\n\n# Or use a lambda\nalert_handler = lambda do |header, payload|\n  data = JSON.parse(payload)\n  AlertService.process_sensor_data(data)\nend\n\nSensorDataMessage.subscribe(alert_handler)\n</code></pre>"},{"location":"core-concepts/message-processing/#real-example-from-iot-code","title":"Real Example from IoT Code","text":"<p>Looking at the smart home IoT example:</p> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    sensor_# decoded_message is already a message instance\n    icon = case sensor_data['device_type']\n           when 'thermostat' then '\ud83c\udf21\ufe0f'\n           when 'security_camera' then '\ud83d\udcf9'\n           when 'door_lock' then '\ud83d\udeaa'\n           end\n\n    puts \"#{icon} Sensor data: #{sensor_data['device_id']} - #{sensor_data['value']}\"\n  end\nend\n</code></pre> <p>This <code>process</code> method gets called every time a <code>SensorDataMessage</code> is published and received by a subscriber.</p>"},{"location":"core-concepts/message-processing/#message-handler-parameters","title":"Message Handler Parameters","text":""},{"location":"core-concepts/message-processing/#message_header","title":"<code>message_header</code>","text":"<p>Contains metadata about the message: <pre><code>message_header.uuid           # Unique message ID\nmessage_header.message_class  # \"SensorDataMessage\"\nmessage_header.published_at   # Timestamp when published\nmessage_header.publisher_pid  # Process ID of publisher\n</code></pre></p>"},{"location":"core-concepts/message-processing/#message_payload","title":"<code>message_payload</code>","text":"<p>The serialized message content (typically JSON): <pre><code># Example payload\n{\n  \"device_id\": \"THERM-001\",\n  \"device_type\": \"thermostat\",\n  \"value\": 22.5,\n  \"unit\": \"celsius\",\n  \"timestamp\": \"2025-08-18T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"core-concepts/message-processing/#multiple-handlers-for-one-message-type","title":"Multiple Handlers for One Message Type","text":"<p>A single message type can have multiple subscribers with different handlers using any combination of the handler patterns:</p> <pre><code># Default handler for logging\nclass SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    puts \"\ud83d\udcca Sensor data logged: #{data['device_id']}\"\n  end\nend\n\n# Custom method handler for specific services\nclass ThermostatService\n  def self.handle_sensor_data(message_header, message_payload)\n    # decoded_message is already a message instance\n    return unless data['device_type'] == 'thermostat'\n    adjust_temperature(data['value'])\n  end\nend\n\n# Register all handlers - mix of different types\nSensorDataMessage.subscribe  # Uses default process method\n\nSensorDataMessage.subscribe(\"ThermostatService.handle_sensor_data\")  # Method handler\n\nSensorDataMessage.subscribe do |header, payload|  # Block handler\n  data = JSON.parse(payload)\n  if data['value'] &gt; 30\n    puts \"\ud83d\udea8 High temperature alert: #{data['value']}\u00b0C\"\n  end\nend\n\n# Proc handler for reusable logic\ndatabase_logger = proc do |header, payload|\n  data = JSON.parse(payload)\n  Database.insert(:sensor_readings, data)\nend\n\nSensorDataMessage.subscribe(database_logger)  # Proc handler\n</code></pre>"},{"location":"core-concepts/message-processing/#message-processing-lifecycle","title":"Message Processing Lifecycle","text":"<ol> <li>Message Published: <code>message.publish</code> is called</li> <li>Transport Delivery: Message is sent via configured transport (Redis, stdout, etc.)</li> <li>Dispatcher Routing: Dispatcher receives message and looks up subscribers</li> <li>Handler Execution: Each registered handler is called in its own thread</li> <li>Business Logic: Your <code>process</code> method executes the business logic</li> </ol>"},{"location":"core-concepts/message-processing/#threading-and-concurrency","title":"Threading and Concurrency","text":"<ul> <li>Each message handler runs in its own thread from the dispatcher's thread pool</li> <li>Multiple handlers for the same message run concurrently</li> <li>Handlers should be thread-safe if they access shared resources</li> </ul> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # This runs in its own thread\n    # Be careful with shared state\n    # decoded_message is already a message instance\n\n    # Thread-safe operations\n    update_local_cache(data)\n\n    # Avoid shared mutable state without synchronization\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#error-handling-in-handlers","title":"Error Handling in Handlers","text":"<p>Handlers should include proper error handling:</p> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    begin\n      # decoded_message is already a message instance\n\n      # Validate required fields\n      raise \"Missing device_id\" unless data['device_id']\n\n      # Process the message\n      process_sensor_reading(data)\n\n    rescue JSON::ParserError =&gt; e\n      logger.error \"Invalid JSON in sensor message: #{e.message}\"\n    rescue =&gt; e\n      logger.error \"Error processing sensor data: #{e.message}\"\n      # Consider dead letter queue or retry logic\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#choosing-the-right-handler-type","title":"Choosing the Right Handler Type","text":""},{"location":"core-concepts/message-processing/#when-to-use-each-handler-type","title":"When to Use Each Handler Type","text":"<p>Default <code>self.process</code> method: - Simple message types with basic processing - When you want a standard handler for the message class - Good for prototyping and simple applications</p> <p>Custom method handlers (<code>\"ClassName.method_name\"</code>): - Complex business logic that belongs in a service class - When you need testable, organized code - Handlers that need to be called from multiple places - Enterprise applications with well-defined service layers</p> <p>Block handlers (<code>subscribe do |header, payload|</code>): - Simple, one-off processing logic - Quick prototyping and experimentation - Inline filtering or formatting - When the logic is specific to the subscription point</p> <p>Proc/Lambda handlers: - Reusable handlers across multiple message types - Dynamic handler creation based on configuration - Functional programming patterns - When you need to pass handlers as parameters</p>"},{"location":"core-concepts/message-processing/#examples-of-each-use-case","title":"Examples of Each Use Case","text":"<pre><code># Default - simple logging\nclass UserEventMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    puts \"User event: #{JSON.parse(payload)['event_type']}\"\n  end\nend\n\n# Method handler - complex business logic\nclass EmailService\n  def self.send_welcome_email(header, payload)\n    user_data = JSON.parse(payload)\n    return unless user_data['event_type'] == 'user_registered'\n\n    EmailTemplate.render(:welcome, user_data)\n                 .deliver_to(user_data['email'])\n  end\nend\n\nUserEventMessage.subscribe(\"EmailService.send_welcome_email\")\n\n# Block handler - simple inline logic\nUserEventMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"\ud83c\udf89 Welcome #{data['username']}!\" if data['event_type'] == 'user_registered'\nend\n\n# Proc handler - reusable across message types\naudit_logger = proc do |header, payload|\n  AuditLog.create(\n    message_type: header.message_class,\n    timestamp: header.published_at,\n    data: payload\n  )\nend\n\nUserEventMessage.subscribe(audit_logger)\nOrderEventMessage.subscribe(audit_logger)  # Reuse the same proc\nPaymentEventMessage.subscribe(audit_logger)\n</code></pre>"},{"location":"core-concepts/message-processing/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/message-processing/#1-keep-handlers-fast","title":"1. Keep Handlers Fast","text":"<pre><code>def self.process(decoded_message)\n  # Quick validation\n  # decoded_message is already a message instance\n  return unless valid_message?(data)\n\n  # Delegate heavy work to background jobs\n  BackgroundJob.perform_async(data)\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#2-use-descriptive-handler-names","title":"2. Use Descriptive Handler Names","text":"<pre><code># Good method names\nSensorDataMessage.subscribe(\"ThermostatService.handle_temperature_reading\")\nSensorDataMessage.subscribe(\"AlertService.monitor_for_anomalies\")\n\n# Good block handlers with comments\nSensorDataMessage.subscribe do |header, payload|  # Temperature monitoring\n  data = JSON.parse(payload)\n  monitor_temperature_thresholds(data)\nend\n\n# Good proc handlers with descriptive variable names\ntemperature_validator = proc do |header, payload|\n  data = JSON.parse(payload)\n  validate_temperature_range(data)\nend\n\nSensorDataMessage.subscribe(temperature_validator)\n\n# Less clear\nSensorDataMessage.subscribe(\"Service1.method1\")\nSensorDataMessage.subscribe do |h, p|; process_stuff(p); end\n</code></pre>"},{"location":"core-concepts/message-processing/#3-filter-messages-early","title":"3. Filter Messages Early","text":"<pre><code>def self.handle_thermostat_data(message_header, message_payload)\n  # decoded_message is already a message instance\n\n  # Filter early to avoid unnecessary processing\n  return unless data['device_type'] == 'thermostat'\n  return unless data['device_id']&amp;.start_with?('THERM-')\n\n  # Process only relevant messages\n  adjust_temperature(data)\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#4-include-logging-and-monitoring","title":"4. Include Logging and Monitoring","text":"<pre><code>def self.process(decoded_message)\n  start_time = Time.now\n\n  begin\n    # decoded_message is already a message instance\n    logger.info \"Processing sensor data from #{data['device_id']}\"\n\n    # Business logic here\n    result = process_sensor_reading(data)\n\n    # Success metrics\n    duration = Time.now - start_time\n    metrics.histogram('message.processing.duration', duration)\n\n  rescue =&gt; e\n    logger.error \"Failed to process sensor data: #{e.message}\"\n    metrics.increment('message.processing.errors')\n    raise\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#summary","title":"Summary","text":"<p>SmartMessage provides flexible options for handling incoming messages, from simple default handlers to sophisticated proc-based solutions.</p>"},{"location":"core-concepts/message-processing/#handler-types-summary","title":"Handler Types Summary:","text":"<ol> <li>Default Handler (<code>self.process</code>): Built-in method for basic message processing</li> <li>Method Handler (<code>\"Class.method\"</code>): Organized, testable handlers in service classes  </li> <li>Block Handler (<code>subscribe do |h,p|</code>): Inline logic perfect for simple processing</li> <li>Proc Handler (<code>subscribe(proc {...})</code>): Reusable, composable handlers</li> </ol>"},{"location":"core-concepts/message-processing/#key-points","title":"Key Points:","text":"<ul> <li>Flexibility: Choose the right handler type for your use case</li> <li>Parameters: All handlers receive <code>(message_header, message_payload)</code></li> <li>Payload: Usually JSON that needs to be parsed back into Ruby objects  </li> <li>Multiple Handlers: One message type can have multiple subscribers with different handler types</li> <li>Threading: Each handler runs in its own thread via the dispatcher's thread pool</li> <li>Error Handling: Include proper error handling for production reliability</li> <li>Unsubscription: All handler types can be unsubscribed using their returned identifiers</li> </ul>"},{"location":"core-concepts/message-processing/#return-values","title":"Return Values:","text":"<p>The <code>subscribe</code> method always returns a string identifier that can be used for unsubscription:</p> <pre><code># All of these return identifiers for unsubscription\ndefault_id = MyMessage.subscribe\nmethod_id = MyMessage.subscribe(\"Service.handle\")\nblock_id = MyMessage.subscribe { |h,p| puts p }\nproc_id = MyMessage.subscribe(my_proc)\n\n# Unsubscribe any handler type\nMyMessage.unsubscribe(block_id)\nMyMessage.unsubscribe(proc_id)\n</code></pre> <p>This enhanced subscription system provides the foundation for building sophisticated, event-driven applications while maintaining simplicity for basic use cases.</p>"},{"location":"core-concepts/properties/","title":"SmartMessage Property System","text":"<p>The SmartMessage property system builds on Hashie::Dash to provide a robust, declarative way to define message attributes. This document covers all available property options and features.</p>"},{"location":"core-concepts/properties/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Basic Property Definition</li> <li>Schema Versioning</li> <li>Class-Level Description</li> <li>Property Options</li> <li>Accessing Property Information</li> <li>Hashie Extensions</li> <li>Examples</li> </ul>"},{"location":"core-concepts/properties/#basic-property-definition","title":"Basic Property Definition","text":"<p>Properties are defined using the <code>property</code> method in your message class:</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  property :field_name\nend\n</code></pre>"},{"location":"core-concepts/properties/#schema-versioning","title":"Schema Versioning","text":"<p>SmartMessage supports schema versioning to enable message evolution while maintaining compatibility:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  version 2  # Declare schema version\n\n  property :order_id, required: true\n  property :customer_email  # Added in version 2\nend\n</code></pre>"},{"location":"core-concepts/properties/#version-management","title":"Version Management","text":"<pre><code># Version 1 message\nclass V1OrderMessage &lt; SmartMessage::Base\n  version 1  # or omit for default version 1\n\n  property :order_id, required: true\n  property :amount, required: true\nend\n\n# Version 2 message with additional field\nclass V2OrderMessage &lt; SmartMessage::Base\n  version 2\n\n  property :order_id, required: true\n  property :amount, required: true\n  property :customer_email  # New in version 2\nend\n\n# Version 3 message with validation\nclass V3OrderMessage &lt; SmartMessage::Base\n  version 3\n\n  property :order_id, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(String) &amp;&amp; v.length &gt; 0 }\n\n  property :amount, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(Numeric) &amp;&amp; v &gt; 0 }\n\n  property :customer_email,\n    validate: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\nend\n</code></pre>"},{"location":"core-concepts/properties/#version-validation","title":"Version Validation","text":"<p>The framework automatically validates version compatibility:</p> <pre><code>message = V2OrderMessage.new(order_id: \"123\", amount: 99.99)\n# Header automatically gets version: 2\n\n# Version validation happens automatically\nmessage.validate!  # Validates message + header + version compatibility\n\n# Manual version validation\nmessage.validate_header_version!  # Checks header version matches class version\n\n# Check version information\nV2OrderMessage.version                    # =&gt; 2\nV2OrderMessage.expected_header_version    # =&gt; 2\nmessage._sm_header.version               # =&gt; 2\n</code></pre>"},{"location":"core-concepts/properties/#version-evolution-patterns","title":"Version Evolution Patterns","text":"<pre><code># Pattern 1: Additive changes (safe)\nclass UserMessageV1 &lt; SmartMessage::Base\n  version 1\n  property :user_id, required: true\n  property :name, required: true\nend\n\nclass UserMessageV2 &lt; SmartMessage::Base\n  version 2\n  property :user_id, required: true\n  property :name, required: true\n  property :email  # Optional addition - backward compatible\nend\n\n# Pattern 2: Field validation evolution\nclass ProductMessageV1 &lt; SmartMessage::Base\n  version 1\n  property :product_id, required: true\n  property :price, required: true\nend\n\nclass ProductMessageV2 &lt; SmartMessage::Base\n  version 2\n  property :product_id, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(String) &amp;&amp; v.match?(/\\APROD-\\d+\\z/) }\n\n  property :price, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(Numeric) &amp;&amp; v &gt; 0 }\nend\n</code></pre>"},{"location":"core-concepts/properties/#class-level-description","title":"Class-Level Description","text":"<p>In addition to property-level descriptions, you can add a description for the entire message class using the <code>description</code> DSL method:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Handles order processing and fulfillment workflow\"\n\n  property :order_id, description: \"Unique order identifier\"\n  property :amount, description: \"Total amount in cents\"\nend\n\n# Access the class description\nOrderMessage.description  # =&gt; \"Handles order processing and fulfillment workflow\"\n\n# Instance access to class description\norder = OrderMessage.new(order_id: \"123\", amount: 9999)\norder.description  # =&gt; \"Handles order processing and fulfillment workflow\"\n</code></pre>"},{"location":"core-concepts/properties/#setting-descriptions","title":"Setting Descriptions","text":"<p>Class descriptions can be set in multiple ways:</p> <pre><code># 1. During class definition\nclass PaymentMessage &lt; SmartMessage::Base\n  description \"Processes payment transactions\"\n  property :payment_id\nend\n\n# 2. After class definition\nclass RefundMessage &lt; SmartMessage::Base\n  property :refund_id\nend\nRefundMessage.description \"Handles payment refunds and reversals\"\n\n# 3. Within config block\nclass NotificationMessage &lt; SmartMessage::Base\n  config do\n    description \"Sends notifications to users\"\n    transport MyTransport.new\n    serializer MySerializer.new\n  end\nend\n</code></pre>"},{"location":"core-concepts/properties/#default-descriptions","title":"Default Descriptions","text":"<p>Classes without explicit descriptions automatically receive a default description:</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  property :data\nend\n\nMyMessage.description  # =&gt; \"MyMessage is a SmartMessage\"\n\n# This applies to all unnamed message classes\nclass SomeModule::ComplexMessage &lt; SmartMessage::Base\n  property :info\nend\n\nSomeModule::ComplexMessage.description  \n# =&gt; \"SomeModule::ComplexMessage is a SmartMessage\"\n</code></pre>"},{"location":"core-concepts/properties/#use-cases","title":"Use Cases","text":"<p>Class descriptions are useful for: - Documenting the overall purpose of a message class - Providing context for code generation tools - Integration with documentation systems - API documentation generation - Dynamic message introspection in gateway applications</p>"},{"location":"core-concepts/properties/#important-notes","title":"Important Notes","text":"<ul> <li>Class descriptions are not inherited by subclasses - each class maintains its own description</li> <li>Setting a description to <code>nil</code> will revert to the default description</li> <li>Descriptions are stored as strings and can include multiline content</li> <li>Both class and instance methods are available to access descriptions</li> </ul>"},{"location":"core-concepts/properties/#property-options","title":"Property Options","text":"<p>SmartMessage supports all Hashie::Dash property options plus additional features:</p>"},{"location":"core-concepts/properties/#1-default-values","title":"1. Default Values","text":"<p>Specify a default value for a property when not provided during initialization:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  # Static default\n  property :status, default: 'pending'\n\n  # Dynamic default using a Proc\n  property :created_at, default: -&gt; { Time.now }\n\n  # Default array\n  property :items, default: []\nend\n\norder = OrderMessage.new\norder.status     # =&gt; 'pending'\norder.created_at # =&gt; Current time\norder.items      # =&gt; []\n</code></pre>"},{"location":"core-concepts/properties/#2-required-properties","title":"2. Required Properties","text":"<p>Mark properties as required to ensure they're provided during initialization:</p> <pre><code>class PaymentMessage &lt; SmartMessage::Base\n  property :payment_id, required: true\n  property :amount, required: true\n  property :note  # Optional\nend\n\n# This raises ArgumentError: The property 'payment_id' is required\nPaymentMessage.new(amount: 100)\n\n# This works\nPaymentMessage.new(payment_id: 'PAY-123', amount: 100)\n</code></pre>"},{"location":"core-concepts/properties/#3-property-transformation","title":"3. Property Transformation","text":"<p>Transform property values when they're set:</p> <pre><code>class UserMessage &lt; SmartMessage::Base\n  property :email, transform_with: -&gt;(v) { v.to_s.downcase }\n  property :name, transform_with: -&gt;(v) { v.to_s.strip.capitalize }\n  property :tags, transform_with: -&gt;(v) { Array(v).map(&amp;:to_s) }\nend\n\nuser = UserMessage.new(\n  email: 'USER@EXAMPLE.COM',\n  name: '  john  ',\n  tags: 'admin'\n)\n\nuser.email # =&gt; 'user@example.com'\nuser.name  # =&gt; 'John'\nuser.tags  # =&gt; ['admin']\n</code></pre>"},{"location":"core-concepts/properties/#4-property-translation-from-hashieextensionsdashpropertytranslation","title":"4. Property Translation (from Hashie::Extensions::Dash::PropertyTranslation)","text":"<p>Map external field names to internal property names:</p> <pre><code>class ApiMessage &lt; SmartMessage::Base\n  property :user_id, from: :userId\n  property :order_date, from: 'orderDate'\n  property :total_amount, from: [:totalAmount, :total, :amount]\nend\n\n# All of these work\nmsg1 = ApiMessage.new(userId: 123)\nmsg2 = ApiMessage.new(user_id: 123)\nmsg3 = ApiMessage.new('orderDate' =&gt; '2024-01-01')\nmsg4 = ApiMessage.new(totalAmount: 100)  # or total: 100, or amount: 100\n\nmsg1.user_id # =&gt; 123\n</code></pre>"},{"location":"core-concepts/properties/#5-type-coercion-from-hashieextensionscoercion","title":"5. Type Coercion (from Hashie::Extensions::Coercion)","text":"<p>Automatically coerce property values to specific types:</p> <pre><code>class TypedMessage &lt; SmartMessage::Base\n  property :count\n  property :price\n  property :active\n  property :tags\n  property :metadata\n\n  coerce_key :count, Integer\n  coerce_key :price, Float\n  coerce_key :active, -&gt;(v) { v.to_s.downcase == 'true' }\n  coerce_key :tags, Array[String]\n  coerce_key :metadata, Hash\nend\n\nmsg = TypedMessage.new(\n  count: '42',\n  price: '19.99',\n  active: 'yes',\n  tags: 'important',\n  metadata: nil\n)\n\nmsg.count    # =&gt; 42 (Integer)\nmsg.price    # =&gt; 19.99 (Float)\nmsg.active   # =&gt; false (Boolean logic)\nmsg.tags     # =&gt; ['important'] (Array)\nmsg.metadata # =&gt; {} (Hash)\n</code></pre>"},{"location":"core-concepts/properties/#6-property-validation-smartmessage-enhancement","title":"6. Property Validation (SmartMessage Enhancement)","text":"<p>Add custom validation logic to ensure data integrity:</p> <pre><code>class ValidatedMessage &lt; SmartMessage::Base\n  # Lambda validation\n  property :age,\n           validate: -&gt;(v) { v.is_a?(Integer) &amp;&amp; v.between?(1, 120) },\n           validation_message: \"Age must be an integer between 1 and 120\"\n\n  # Regex validation for email\n  property :email,\n           validate: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i,\n           validation_message: \"Must be a valid email address\"\n\n  # Array inclusion validation\n  property :status,\n           validate: ['active', 'inactive', 'pending'],\n           validation_message: \"Status must be active, inactive, or pending\"\n\n  # Range validation\n  property :score,\n           validate: (0..100),\n           validation_message: \"Score must be between 0 and 100\"\n\n  # Class type validation\n  property :created_at,\n           validate: Time,\n           validation_message: \"Must be a Time object\"\n\n  # Symbol method validation\n  property :username,\n           validate: :valid_username?,\n           validation_message: \"Username contains invalid characters\"\n\n  private\n\n  def valid_username?(value)\n    value.to_s.match?(/\\A[a-zA-Z0-9_]+\\z/)\n  end\nend\n\n# Validation usage\nmessage = ValidatedMessage.new(age: 25, email: \"test@example.com\")\n\n# Validate entire message\nmessage.validate!           # Raises SmartMessage::Errors::ValidationError on failure\nmessage.valid?              # Returns true/false\n\n# Get validation errors\nerrors = message.validation_errors\nerrors.each do |error|\n  puts \"#{error[:property]}: #{error[:message]}\"\nend\n</code></pre>"},{"location":"core-concepts/properties/#7-property-descriptions-smartmessage-enhancement","title":"7. Property Descriptions (SmartMessage Enhancement)","text":"<p>Add human-readable descriptions to document your properties for dynamic LLM integration:</p> <pre><code>class DocumentedMessage &lt; SmartMessage::Base\n  property :transaction_id,\n           required: true,\n           description: \"Unique identifier for the transaction\"\n\n  property :amount,\n           transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n           description: \"Transaction amount in the smallest currency unit\"\n\n  property :currency,\n           default: 'USD',\n           description: \"ISO 4217 currency code\"\n\n  property :status,\n           default: 'pending',\n           description: \"Current transaction status: pending, completed, failed\"\n\n  property :metadata,\n           default: {},\n           description: \"Additional transaction metadata as key-value pairs\"\nend\n\n# Access descriptions programmatically\nDocumentedMessage.property_description(:amount)\n# =&gt; \"Transaction amount in the smallest currency unit\"\n\nDocumentedMessage.property_descriptions\n# =&gt; {\n#      transaction_id: \"Unique identifier for the transaction\",\n#      amount: \"Transaction amount in the smallest currency unit\",\n#      currency: \"ISO 4217 currency code\",\n#      status: \"Current transaction status: pending, completed, failed\",\n#      metadata: \"Additional transaction metadata as key-value pairs\"\n#    }\n\nDocumentedMessage.described_properties\n# =&gt; [:transaction_id, :amount, :currency, :status, :metadata]\n</code></pre>"},{"location":"core-concepts/properties/#accessing-property-information","title":"Accessing Property Information","text":"<p>SmartMessage provides several methods to introspect properties:</p> <pre><code>class IntrospectionExample &lt; SmartMessage::Base\n  property :id, required: true, description: \"Unique identifier\"\n  property :name, description: \"Display name\"\n  property :created_at, default: -&gt; { Time.now }\n  property :tags\nend\n\n# Instance methods\ninstance = IntrospectionExample.new(id: 1, name: \"Test\")\ninstance.fields  # =&gt; Set[:id, :name, :created_at, :tags]\ninstance.to_h    # =&gt; Hash of all properties and values\n\n# Class methods\nIntrospectionExample.fields              # =&gt; Set[:id, :name, :created_at, :tags]\nIntrospectionExample.property_descriptions  # =&gt; Hash of descriptions\nIntrospectionExample.described_properties   # =&gt; [:id, :name]\n</code></pre>"},{"location":"core-concepts/properties/#hashie-extensions","title":"Hashie Extensions","text":"<p>SmartMessage::Base automatically includes these Hashie extensions:</p>"},{"location":"core-concepts/properties/#1-deepmerge","title":"1. DeepMerge","text":"<p>Allows deep merging of nested hash properties:</p> <pre><code>msg = MyMessage.new(config: { a: 1, b: { c: 2 } })\nmsg.deep_merge(config: { b: { d: 3 } })\n# =&gt; config: { a: 1, b: { c: 2, d: 3 } }\n</code></pre>"},{"location":"core-concepts/properties/#2-ignoreundeclared","title":"2. IgnoreUndeclared","text":"<p>Silently ignores properties that haven't been declared:</p> <pre><code># Won't raise an error for unknown properties\nmsg = MyMessage.new(known: 'value', unknown: 'ignored')\n</code></pre>"},{"location":"core-concepts/properties/#3-indifferentaccess","title":"3. IndifferentAccess","text":"<p>Access properties with strings or symbols:</p> <pre><code>msg = MyMessage.new('name' =&gt; 'John')\nmsg[:name]    # =&gt; 'John'\nmsg['name']   # =&gt; 'John'\nmsg.name      # =&gt; 'John'\n</code></pre>"},{"location":"core-concepts/properties/#4-methodaccess","title":"4. MethodAccess","text":"<p>Access properties as methods:</p> <pre><code>msg = MyMessage.new(name: 'John')\nmsg.name         # =&gt; 'John'\nmsg.name = 'Jane'\nmsg.name         # =&gt; 'Jane'\n</code></pre>"},{"location":"core-concepts/properties/#5-mergeinitializer","title":"5. MergeInitializer","text":"<p>Allows initializing with merged hash values:</p> <pre><code>defaults = { status: 'active', retries: 3 }\nmsg = MyMessage.new(defaults.merge(status: 'pending'))\n# =&gt; status: 'pending', retries: 3\n</code></pre>"},{"location":"core-concepts/properties/#examples","title":"Examples","text":""},{"location":"core-concepts/properties/#complete-example-order-processing-message","title":"Complete Example: Order Processing Message","text":"<pre><code>class OrderProcessingMessage &lt; SmartMessage::Base\n  description \"Manages the complete order lifecycle from placement to delivery\"\n\n  # Required fields with descriptions\n  property :order_id,\n           required: true,\n           description: \"Unique order identifier from the ordering system\"\n\n  property :customer_id,\n           required: true,\n           description: \"Customer who placed the order\"\n\n  # Amount with transformation and description\n  property :total_amount,\n           transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n           description: \"Total order amount including tax and shipping\"\n\n  # Status with default and validation description\n  property :status,\n           default: 'pending',\n           description: \"Order status: pending, processing, shipped, delivered, cancelled\"\n\n  # Items with coercion\n  property :items,\n           default: [],\n           description: \"Array of order line items\"\n\n  # Timestamps with dynamic defaults\n  property :created_at,\n           default: -&gt; { Time.now },\n           description: \"When the order was created\"\n\n  property :updated_at,\n           default: -&gt; { Time.now },\n           description: \"Last modification timestamp\"\n\n  # Optional fields\n  property :notes,\n           description: \"Optional order notes or special instructions\"\n\n  property :shipping_address,\n           description: \"Shipping address as a nested hash\"\n\n  # Field translation for external APIs\n  property :external_ref,\n           from: [:externalReference, :ext_ref],\n           description: \"Reference ID from external system\"\nend\n\n# Usage\norder = OrderProcessingMessage.new(\n  order_id: 'ORD-2024-001',\n  customer_id: 'CUST-123',\n  total_amount: '149.99',\n  items: [\n    { sku: 'WIDGET-A', quantity: 2, price: 49.99 },\n    { sku: 'WIDGET-B', quantity: 1, price: 50.01 }\n  ],\n  shipping_address: {\n    street: '123 Main St',\n    city: 'Springfield',\n    state: 'IL',\n    zip: '62701'\n  },\n  externalReference: 'EXT-789'  # Note: uses translated field name\n)\n\n# Access properties\norder.order_id         # =&gt; 'ORD-2024-001'\norder.total_amount     # =&gt; BigDecimal('149.99')\norder.status           # =&gt; 'pending' (default)\norder.external_ref     # =&gt; 'EXT-789' (translated)\norder.created_at       # =&gt; Time object\n\n# Get class and property information\nOrderProcessingMessage.description\n# =&gt; \"Manages the complete order lifecycle from placement to delivery\"\n\nOrderProcessingMessage.property_description(:total_amount)\n# =&gt; \"Total order amount including tax and shipping\"\n\nOrderProcessingMessage.property_descriptions.keys\n# =&gt; [:order_id, :customer_id, :total_amount, :status, :items, ...]\n</code></pre>"},{"location":"core-concepts/properties/#example-api-integration-message","title":"Example: API Integration Message","text":"<pre><code>class ApiWebhookMessage &lt; SmartMessage::Base\n  # Handle different API naming conventions\n  property :event_type,\n           from: [:eventType, :event, :type],\n           required: true,\n           description: \"Type of webhook event\"\n\n  property :payload,\n           required: true,\n           description: \"Event payload data\"\n\n  property :timestamp,\n           from: [:timestamp, :created_at, :occurredAt],\n           transform_with: -&gt;(v) { Time.parse(v.to_s) },\n           description: \"When the event occurred\"\n\n  property :retry_count,\n           from: :retryCount,\n           default: 0,\n           transform_with: -&gt;(v) { v.to_i },\n           description: \"Number of delivery attempts\"\n\n  property :signature,\n           description: \"HMAC signature for webhook validation\"\nend\n\n# Can initialize with various field names\nwebhook1 = ApiWebhookMessage.new(\n  eventType: 'order.completed',\n  payload: { order_id: 123 },\n  occurredAt: '2024-01-01T10:00:00Z',\n  retryCount: '2'\n)\n\nwebhook2 = ApiWebhookMessage.new(\n  type: 'order.completed',        # Alternative field name\n  payload: { order_id: 123 },\n  timestamp: Time.now,             # Alternative field name\n  retry_count: 2                   # Internal field name\n)\n</code></pre>"},{"location":"core-concepts/properties/#best-practices","title":"Best Practices","text":"<ol> <li>Always add descriptions to document the purpose and format of each property</li> <li>Use required properties for fields that must be present for valid messages</li> <li>Provide sensible defaults for optional fields to reduce boilerplate</li> <li>Use transformations to ensure data consistency and type safety</li> <li>Leverage field translation when integrating with external APIs that use different naming conventions</li> <li>Document valid values in descriptions for enum-like fields (e.g., status fields)</li> <li>Use type coercion for fields that may come from untrusted sources (like HTTP parameters)</li> </ol>"},{"location":"core-concepts/properties/#property-option-compatibility","title":"Property Option Compatibility","text":"<p>Multiple options can be combined on a single property:</p> <pre><code>property :amount,\n         required: true,\n         from: [:amount, :total, :value],\n         transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n         description: \"Transaction amount in cents\"\n</code></pre> <p>The processing order is: 1. Field translation (from) 2. Default value (if not provided) 3. Required validation 4. Type coercion 5. Transformation 6. Value assignment</p>"},{"location":"core-concepts/properties/#limitations","title":"Limitations","text":"<ul> <li>Property names must be valid Ruby method names</li> <li>The <code>_sm_</code> prefix is reserved for internal SmartMessage properties</li> <li>Descriptions are metadata only and don't affect runtime behavior</li> <li>Some Hashie options may conflict if used incorrectly (e.g., required with default)</li> </ul>"},{"location":"development/ideas/","title":"Ideas to Think About","text":"<p>This document analyzes potential enhancements to SmartMessage based on a comparison between the current implementation and an idealized vision of intelligent messaging.</p>"},{"location":"development/ideas/#current-state-vs-vision","title":"Current State vs. Vision","text":"<p>A description was provided that envisioned SmartMessage as an advanced, intelligent messaging system. While the current implementation is solid and well-designed, there are significant opportunities for enhancement to move toward that vision.</p>"},{"location":"development/ideas/#what-currently-matches","title":"What Currently Matches:","text":"<p>\u2705 Message abstraction from transport mechanisms - The gem does abstract messages from their delivery systems</p> <p>\u2705 Pluggable architecture - Supports different transports and serializers</p> <p>\u2705 Multiple messaging patterns - Can handle 1-to-1, 1-to-many scenarios through subscription patterns</p> <p>\u2705 Error handling - Basic error isolation in the dispatcher</p>"},{"location":"development/ideas/#major-enhancement-opportunities","title":"Major Enhancement Opportunities:","text":"<p>The following features were described in the vision but are not currently implemented:</p>"},{"location":"development/ideas/#1-autonomous-self-publishing","title":"1. Autonomous Self-Publishing","text":"<p>Vision: Messages autonomously publish themselves based on predefined triggers Current: Messages require explicit <code>.publish</code> calls Potential Implementation: <pre><code>class SmartMessage::Base\n  # Add trigger-based publishing\n  def self.publish_on(event_type, condition = nil, &amp;block)\n    @auto_publish_triggers ||= []\n    @auto_publish_triggers &lt;&lt; {\n      event: event_type,\n      condition: condition || block,\n      target: self\n    }\n  end\n\n  # Monitor system events and auto-publish when triggered\n  def self.check_triggers(event_data)\n    @auto_publish_triggers&amp;.each do |trigger|\n      if trigger[:condition].call(event_data)\n        new(event_data).publish\n      end\n    end\n  end\nend\n\n# Usage example:\nclass OrderStatusUpdate &lt; SmartMessage::Base\n  property :order_id\n  property :status\n\n  # Automatically publish when order status changes\n  publish_on(:order_status_changed) do |event|\n    event[:status] == 'shipped'\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#2-dynamic-content-transformation","title":"2. Dynamic Content Transformation","text":"<p>Vision: On-the-fly format conversion for different subscribers Current: One serializer per message class Potential Implementation: <pre><code>class SmartMessage::Dispatcher\n  # Route with format transformation\n  def route_with_transformation(message_header, message_payload)\n    @subscribers[message_header.message_class].each do |processor|\n      # Get subscriber's preferred format\n      preferred_format = get_subscriber_format(processor)\n\n      # Transform if needed\n      if preferred_format != message_header.format\n        transformed_payload = transform_format(\n          message_payload,\n          from: message_header.format,\n          to: preferred_format\n        )\n        route_to_processor(processor, message_header, transformed_payload)\n      else\n        route_to_processor(processor, message_header, message_payload)\n      end\n    end\n  end\n\n  private\n\n  def transform_format(payload, from:, to:)\n    # Convert between formats (JSON -&gt; XML, XML -&gt; MessagePack, etc.)\n    case [from, to]\n    when ['json', 'xml']\n      json_to_xml(payload)\n    when ['xml', 'json']\n      xml_to_json(payload)\n    # Add more transformations as needed\n    end\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#3-contextual-awareness-and-routing-intelligence","title":"3. Contextual Awareness and Routing Intelligence","text":"<p>Vision: Intelligent routing based on context and subscriber relevance Current: Simple class-name-based dispatch Potential Implementation: <pre><code>class SmartMessage::IntelligentDispatcher &lt; SmartMessage::Dispatcher\n  def initialize\n    super\n    @subscriber_profiles = {}\n    @routing_intelligence = RoutingIntelligence.new\n  end\n\n  def subscribe_with_profile(message_class, processor, profile: {})\n    super(message_class, processor)\n    @subscriber_profiles[processor] = profile\n  end\n\n  def route(message_header, message_payload)\n    # Analyze message content\n    message_context = analyze_message_context(message_payload)\n\n    # Find relevant subscribers based on context\n    relevant_subscribers = find_relevant_subscribers(\n      message_header.message_class,\n      message_context\n    )\n\n    # Route only to relevant subscribers\n    relevant_subscribers.each do |processor|\n      route_to_processor(processor, message_header, message_payload)\n    end\n  end\n\n  private\n\n  def find_relevant_subscribers(message_class, context)\n    candidates = @subscribers[message_class] || []\n\n    candidates.select do |processor|\n      profile = @subscriber_profiles[processor]\n      @routing_intelligence.is_relevant?(context, profile)\n    end\n  end\nend\n\n# Usage:\ndispatcher.subscribe_with_profile(\n  \"OrderMessage\",\n  \"FulfillmentService.process\",\n  profile: {\n    interests: ['physical_goods'],\n    regions: ['US', 'CA'],\n    order_value_min: 100\n  }\n)\n</code></pre></p>"},{"location":"development/ideas/#4-feedback-mechanisms","title":"4. Feedback Mechanisms","text":"<p>Vision: Collect feedback from subscribers for continuous improvement Current: No feedback system Potential Implementation: <pre><code>class SmartMessage::Base\n  def self.process_with_feedback(message_header, message_payload)\n    start_time = Time.now\n\n    begin\n      result = process_without_feedback(message_header, message_payload)\n\n      # Collect success feedback\n      SmartMessage::FeedbackCollector.record_success(\n        processor: \"#{self}.process\",\n        message_class: message_header.message_class,\n        processing_time: Time.now - start_time,\n        result_quality: evaluate_result_quality(result)\n      )\n\n      result\n    rescue =&gt; e\n      # Collect failure feedback\n      SmartMessage::FeedbackCollector.record_failure(\n        processor: \"#{self}.process\",\n        message_class: message_header.message_class,\n        error: e,\n        processing_time: Time.now - start_time\n      )\n      raise\n    end\n  end\n\n  alias_method :process_without_feedback, :process\n  alias_method :process, :process_with_feedback\nend\n\nmodule SmartMessage::FeedbackCollector\n  def self.record_success(processor:, message_class:, processing_time:, result_quality:)\n    # Store feedback for analysis\n    feedback_store.record({\n      type: 'success',\n      processor: processor,\n      message_class: message_class,\n      processing_time: processing_time,\n      result_quality: result_quality,\n      timestamp: Time.now\n    })\n  end\n\n  def self.analyze_processor_performance(processor)\n    # Analyze collected feedback to provide insights\n    feedback_store.analyze(processor)\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#5-security-features","title":"5. Security Features","text":"<p>Vision: Built-in encryption and authentication Current: No security features Potential Implementation: <pre><code>class SmartMessage::SecureTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @encryption_key = options[:encryption_key]\n    @auth_provider = options[:auth_provider]\n  end\n\n  def publish(message_header, message_payload)\n    # Authenticate sender\n    unless @auth_provider.authenticate(message_header.publisher_pid)\n      raise SmartMessage::Errors::AuthenticationFailed\n    end\n\n    # Encrypt payload\n    encrypted_payload = encrypt_payload(message_payload)\n\n    # Add security metadata to header\n    secure_header = message_header.dup\n    secure_header.encrypted = true\n    secure_header.encryption_algorithm = 'AES-256-GCM'\n\n    super(secure_header, encrypted_payload)\n  end\n\n  protected\n\n  def receive(message_header, message_payload)\n    # Decrypt if needed\n    if message_header.encrypted\n      decrypted_payload = decrypt_payload(message_payload)\n      super(message_header, decrypted_payload)\n    else\n      super\n    end\n  end\n\n  private\n\n  def encrypt_payload(payload)\n    # Implement encryption logic\n  end\n\n  def decrypt_payload(encrypted_payload)\n    # Implement decryption logic\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"development/ideas/#phase-1-foundation-enhancements","title":"Phase 1: Foundation Enhancements","text":"<ol> <li>Enhanced Statistics System - More detailed metrics collection</li> <li>Message Tracing - Correlation IDs and message flow tracking</li> <li>Improved Error Handling - Retry mechanisms and dead letter queues</li> <li>Configuration Management - More sophisticated configuration options</li> </ol>"},{"location":"development/ideas/#phase-2-intelligence-features","title":"Phase 2: Intelligence Features","text":"<ol> <li>Content Analysis - Message content classification and tagging</li> <li>Routing Intelligence - Context-aware subscriber matching</li> <li>Performance Optimization - Adaptive processing based on load</li> <li>Feedback Collection - Basic subscriber feedback mechanisms</li> </ol>"},{"location":"development/ideas/#phase-3-advanced-features","title":"Phase 3: Advanced Features","text":"<ol> <li>Dynamic Transformation - Format conversion between subscribers</li> <li>Autonomous Publishing - Event-driven message creation</li> <li>Security Layer - Encryption and authentication</li> <li>Machine Learning Integration - Predictive routing and optimization</li> </ol>"},{"location":"development/ideas/#phase-4-enterprise-features","title":"Phase 4: Enterprise Features","text":"<ol> <li>Distributed Processing - Multi-node message handling</li> <li>Advanced Analytics - Message flow analysis and optimization</li> <li>Integration APIs - Easy integration with existing systems</li> <li>Management Console - Web-based monitoring and configuration</li> </ol>"},{"location":"development/ideas/#technical-considerations","title":"Technical Considerations","text":""},{"location":"development/ideas/#architecture-changes-needed","title":"Architecture Changes Needed","text":"<ol> <li>Plugin System Enhancement - More sophisticated plugin architecture</li> <li>Event System - System-wide event broadcasting for triggers</li> <li>Metadata Framework - Rich message and subscriber metadata</li> <li>Processing Pipeline - Configurable message processing stages</li> </ol>"},{"location":"development/ideas/#performance-implications","title":"Performance Implications","text":"<ol> <li>Intelligence Overhead - Balance between smart features and performance</li> <li>Memory Usage - Feedback collection and context storage</li> <li>Processing Complexity - Multiple transformation and routing steps</li> <li>Scalability - Ensure enhancements don't impact horizontal scaling</li> </ol>"},{"location":"development/ideas/#backward-compatibility","title":"Backward Compatibility","text":"<ol> <li>Gradual Migration - All enhancements should be optional</li> <li>API Stability - Maintain existing API while adding new features</li> <li>Configuration Migration - Smooth upgrade path for existing installations</li> <li>Testing Strategy - Comprehensive testing for both old and new features</li> </ol>"},{"location":"development/ideas/#current-strengths-to-preserve","title":"Current Strengths to Preserve","text":"<p>The existing SmartMessage implementation has several strengths that should be maintained:</p> <ol> <li>Simplicity - Easy to understand and use</li> <li>Solid Architecture - Well-designed plugin system and separation of concerns</li> <li>Thread Safety - Proper concurrent processing</li> <li>Flexibility - Support for custom transports and serializers</li> <li>Testing - Good test coverage and patterns</li> </ol>"},{"location":"development/ideas/#conclusion","title":"Conclusion","text":"<p>While the current SmartMessage implementation is solid and functional, there's significant potential to evolve it toward a more intelligent messaging system. The key is to implement these enhancements gradually while preserving the simplicity and reliability that make the current system valuable.</p> <p>The vision of autonomous, context-aware messaging is achievable, but it requires careful planning to ensure that added intelligence doesn't compromise the system's core strengths of simplicity and reliability.</p>"},{"location":"development/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and solve common issues when working with SmartMessage.</p>"},{"location":"development/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"development/troubleshooting/#1-messages-not-being-processed","title":"1. Messages Not Being Processed","text":"<p>Symptoms: - Messages are published but process methods are never called - No errors are thrown - Statistics show messages published but not routed</p> <p>Possible Causes &amp; Solutions:</p>"},{"location":"development/troubleshooting/#missing-subscription","title":"Missing Subscription","text":"<pre><code># Problem: Forgot to subscribe\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(header, payload)\n    puts \"Processing message\"\n  end\nend\n\nMyMessage.new(data: \"test\").publish  # Nothing happens\n\n# Solution: Add subscription\nMyMessage.subscribe\nMyMessage.new(data: \"test\").publish  # Now it works\n</code></pre>"},{"location":"development/troubleshooting/#transport-not-configured-for-loopback","title":"Transport Not Configured for Loopback","text":"<pre><code># Problem: Using STDOUT without loopback\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)  # No loopback\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# Solution: Enable loopback for local testing\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#auto-process-disabled","title":"Auto-process Disabled","text":"<pre><code># Problem: Memory transport with auto_process disabled\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: false)\n  end\nend\n\n# Messages are stored but not processed\ntransport = MyMessage.transport\nputs transport.message_count  # Shows stored messages\n\n# Solution: Enable auto_process or manually process\nMyMessage.config do\n  transport SmartMessage::Transport.create(:memory, auto_process: true)\nend\n\n# Or manually trigger processing\ntransport.process_all\n</code></pre>"},{"location":"development/troubleshooting/#2-serialization-errors","title":"2. Serialization Errors","text":"<p>Symptoms: - <code>SmartMessage::Errors::SerializerNotConfigured</code> exceptions - Encoding/decoding failures - Malformed message data</p> <p>Solutions:</p>"},{"location":"development/troubleshooting/#missing-serializer-configuration","title":"Missing Serializer Configuration","text":"<pre><code># Problem: No serializer configured\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    # Missing serializer!\n  end\nend\n\n# Throws: SmartMessage::Errors::SerializerNotConfigured\nMyMessage.new(data: \"test\").publish\n\n# Solution: Add serializer\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#json-encoding-issues","title":"JSON Encoding Issues","text":"<pre><code># Problem: Objects that can't be serialized to JSON\nclass ProblematicMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# This will fail\nmessage = ProblematicMessage.new(data: Object.new)\nmessage.publish  # JSON::GeneratorError\n\n# Solution: Ensure data is JSON-serializable\nmessage = ProblematicMessage.new(data: { key: \"value\" })\nmessage.publish  # Works fine\n\n# Or implement custom serialization\nclass SafeMessage &lt; SmartMessage::Base\n  property :data\n\n  def to_h\n    hash = super\n    hash[:data] = hash[:data].to_s if hash[:data]\n    hash\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#3-transport-configuration-issues","title":"3. Transport Configuration Issues","text":"<p>Symptoms: - <code>SmartMessage::Errors::TransportNotConfigured</code> exceptions - Connection failures - Messages not being sent</p> <p>Solutions:</p>"},{"location":"development/troubleshooting/#missing-transport-configuration","title":"Missing Transport Configuration","text":"<pre><code># Problem: No transport configured\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    serializer SmartMessage::Serializer::Json.new\n    # Missing transport!\n  end\nend\n\nMyMessage.new(data: \"test\").publish  # Throws TransportNotConfigured\n\n# Solution: Add transport\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#transport-connection-issues","title":"Transport Connection Issues","text":"<pre><code># For custom transports that might fail to connect\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport CustomTransport.new(host: \"unreachable-host\")\n  end\nend\n\n# Check transport status\ntransport = MyMessage.transport\nputs \"Connected: #{transport.connected?}\"\n\n# Solution: Verify connection settings\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport CustomTransport.new(\n      host: \"localhost\",\n      port: 5672,\n      retry_attempts: 3\n    )\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#4-thread-pool-issues","title":"4. Thread Pool Issues","text":"<p>Symptoms: - Messages processed very slowly - Application hangs on exit - High memory usage</p> <p>Debugging Thread Pool:</p> <pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# Check thread pool status\nstatus = dispatcher.status\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Scheduled tasks: #{status[:scheduled_task_count]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\nputs \"Pool size: #{status[:length]}\"\n\n# If queue is growing, messages are being created faster than processed\nif status[:queue_length] &gt; 100\n  puts \"\u26a0\ufe0f  Large queue detected - consider optimizing message processing\"\nend\n\n# If pool is not running\nunless status[:running]\n  puts \"\u274c Thread pool is not running - check for shutdown issues\"\nend\n</code></pre> <p>Solutions:</p>"},{"location":"development/troubleshooting/#slow-message-processing","title":"Slow Message Processing","text":"<pre><code># Problem: Slow process method blocking thread pool\nclass SlowMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    sleep(10)  # Very slow operation\n    # Processing logic\n  end\nend\n\n# Solution: Optimize or use background jobs\nclass OptimizedMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    # Quick validation\n    data = JSON.parse(payload)\n\n    # Delegate heavy work to background job\n    BackgroundJob.perform_async(data)\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#application-hanging-on-exit","title":"Application Hanging on Exit","text":"<pre><code># Problem: Threads not shutting down gracefully\n# The dispatcher handles this automatically, but if you create custom threads:\n\nclass CustomMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    # Problem: Creating non-daemon threads\n    Thread.new do\n      loop do\n        # Long-running work\n        sleep(1)\n      end\n    end\n  end\nend\n\n# Solution: Use daemon threads or proper cleanup\nclass BetterMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    thread = Thread.new do\n      loop do\n        break if Thread.current[:stop_requested]\n        # Work with interruption points\n        sleep(1)\n      end\n    end\n\n    # Register cleanup\n    at_exit do\n      thread[:stop_requested] = true\n      thread.join(5)  # Wait up to 5 seconds\n    end\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#5-memory-issues","title":"5. Memory Issues","text":"<p>Symptoms: - Increasing memory usage over time - Out of memory errors - Slow performance</p> <p>Debugging Memory Usage:</p> <pre><code># Check message storage in memory transport\ntransport = SmartMessage::Transport.create(:memory)\nputs \"Stored messages: #{transport.message_count}\"\nputs \"Max messages: #{transport.instance_variable_get(:@options)[:max_messages]}\"\n\n# Check statistics storage\nputs \"Statistics entries: #{SS.stat.keys.length}\"\n\n# Monitor object creation\nclass MemoryMonitorMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    puts \"Objects before: #{ObjectSpace.count_objects[:TOTAL]}\"\n\n    # Your processing logic\n    data = JSON.parse(payload)\n\n    puts \"Objects after: #{ObjectSpace.count_objects[:TOTAL]}\"\n  end\nend\n</code></pre> <p>Solutions:</p>"},{"location":"development/troubleshooting/#memory-transport-overflow","title":"Memory Transport Overflow","text":"<pre><code># Problem: Memory transport storing too many messages\ntransport = SmartMessage::Transport.create(:memory, max_messages: 10000)\n\n# Monitor and clean up\ndef cleanup_memory_transport(transport)\n  if transport.message_count &gt; 5000\n    puts \"Cleaning up old messages...\"\n    transport.clear_messages\n  end\nend\n\n# Or use smaller limits\ntransport = SmartMessage::Transport.create(:memory, max_messages: 100)\n</code></pre>"},{"location":"development/troubleshooting/#statistics-memory-growth","title":"Statistics Memory Growth","text":"<pre><code># Problem: Statistics growing without bounds\n# Check current statistics size\nputs \"Statistics size: #{SS.stat.size}\"\n\n# Solution: Periodic cleanup\ndef cleanup_statistics\n  # Keep only recent statistics\n  current_stats = SS.stat\n  important_stats = current_stats.select do |key, value|\n    # Keep publish counts and recent routing stats\n    key.include?('publish') || value &gt; 0\n  end\n\n  SS.reset\n  important_stats.each { |key, value| SS.add(*key.split('+'), how_many: value) }\nend\n\n# Run cleanup periodically\nThread.new do\n  loop do\n    sleep(3600)  # Every hour\n    cleanup_statistics\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#6-debugging-message-flow","title":"6. Debugging Message Flow","text":"<p>Enable Debug Logging:</p> <pre><code># Add debug output to your message classes\nclass DebugMessage &lt; SmartMessage::Base\n  property :data\n\n  def publish\n    puts \"\ud83d\ude80 Publishing #{self.class.name}: #{self.to_h}\"\n    super\n  end\n\n  def self.process(header, payload)\n    puts \"\ud83d\udce5 Processing #{header.message_class}: #{payload}\"\n\n    # Your processing logic\n    data = JSON.parse(payload)\n    message = new(data)\n\n    puts \"\u2705 Processed #{header.message_class}: #{message.data}\"\n  end\nend\n</code></pre> <p>Trace Message Path:</p> <pre><code># Add correlation IDs for tracing\nclass TrackedMessage &lt; SmartMessage::Base\n  property :data\n  property :correlation_id, default: -&gt; { SecureRandom.uuid }\n\n  def publish\n    puts \"[#{correlation_id}] Publishing message\"\n    super\n  end\n\n  def self.process(header, payload)\n    data = JSON.parse(payload)\n    message = new(data)\n\n    puts \"[#{message.correlation_id}] Processing message\"\n\n    # Your logic here\n\n    puts \"[#{message.correlation_id}] Processing complete\"\n  end\nend\n</code></pre> <p>Check Statistics:</p> <pre><code># Monitor message flow with statistics\ndef print_message_stats(message_class)\n  class_name = message_class.to_s\n  published = SS.get(class_name, 'publish')\n  routed = SS.get(class_name, \"#{class_name}.process\", 'routed')\n\n  puts \"#{class_name} Statistics:\"\n  puts \"  Published: #{published}\"\n  puts \"  Routed: #{routed}\"\n  puts \"  Success rate: #{routed.to_f / published * 100}%\" if published &gt; 0\nend\n\n# Usage\nprint_message_stats(MyMessage)\n</code></pre>"},{"location":"development/troubleshooting/#7-configuration-issues","title":"7. Configuration Issues","text":"<p>Debug Configuration:</p> <pre><code># Check current configuration\ndef debug_message_config(message_class)\n  puts \"#{message_class} Configuration:\"\n  puts \"  Transport: #{message_class.transport.class.name}\"\n  puts \"  Transport configured: #{message_class.transport_configured?}\"\n  puts \"  Serializer: #{message_class.serializer.class.name}\"\n  puts \"  Serializer configured: #{message_class.serializer_configured?}\"\n\n  # Check instance-level overrides\n  instance = message_class.new\n  puts \"  Instance transport: #{instance.transport.class.name}\"\n  puts \"  Instance serializer: #{instance.serializer.class.name}\"\nend\n\ndebug_message_config(MyMessage)\n</code></pre> <p>Reset Configuration:</p> <pre><code># If configuration gets corrupted, reset it\nclass MyMessage &lt; SmartMessage::Base\n  # Reset all configuration\n  reset_transport\n  reset_serializer\n  reset_logger\n\n  # Reconfigure\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#performance-troubleshooting","title":"Performance Troubleshooting","text":""},{"location":"development/troubleshooting/#slow-message-processing_1","title":"Slow Message Processing","text":"<pre><code># Benchmark message processing\nrequire 'benchmark'\n\ndef benchmark_message_processing(message_class, count = 100)\n  time = Benchmark.measure do\n    count.times do |i|\n      message_class.new(data: \"test #{i}\").publish\n    end\n\n    # Wait for processing to complete\n    sleep(1)\n  end\n\n  puts \"Processed #{count} messages in #{time.real.round(2)} seconds\"\n  puts \"Rate: #{(count / time.real).round(2)} messages/second\"\nend\n\nbenchmark_message_processing(MyMessage, 1000)\n</code></pre>"},{"location":"development/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<pre><code># Monitor memory during message processing\ndef monitor_memory_usage\n  require 'objspace'\n\n  initial_memory = ObjectSpace.count_objects[:TOTAL]\n\n  # Process some messages\n  100.times { |i| MyMessage.new(data: \"test #{i}\").publish }\n\n  # Force garbage collection\n  GC.start\n\n  final_memory = ObjectSpace.count_objects[:TOTAL]\n\n  puts \"Memory usage:\"\n  puts \"  Initial: #{initial_memory} objects\"\n  puts \"  Final: #{final_memory} objects\"\n  puts \"  Difference: #{final_memory - initial_memory} objects\"\nend\n\nmonitor_memory_usage\n</code></pre>"},{"location":"development/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"development/troubleshooting/#collect-debug-information","title":"Collect Debug Information","text":"<pre><code>def collect_debug_info\n  puts \"SmartMessage Debug Information\"\n  puts \"==============================\"\n  puts \"Version: #{SmartMessage::VERSION}\"\n  puts \"Ruby version: #{RUBY_VERSION}\"\n  puts \"Platform: #{RUBY_PLATFORM}\"\n  puts \"\"\n\n  # Available transports\n  puts \"Available transports: #{SmartMessage::Transport.available.join(', ')}\"\n  puts \"\"\n\n  # Current statistics\n  puts \"Current statistics:\"\n  SS.stat.each { |key, value| puts \"  #{key}: #{value}\" }\n  puts \"\"\n\n  # Thread pool status if dispatcher exists\n  begin\n    dispatcher = SmartMessage::Dispatcher.new\n    status = dispatcher.status\n    puts \"Dispatcher status:\"\n    status.each { |key, value| puts \"  #{key}: #{value}\" }\n  rescue =&gt; e\n    puts \"Dispatcher error: #{e.message}\"\n  end\nend\n\ncollect_debug_info\n</code></pre>"},{"location":"development/troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code># Enable debug output in test.log\nrequire 'debug_me'\ninclude DebugMe\n\n# This will log to test.log with detailed information\ndebug_me { \"Message published: #{message.to_h}\" }\n</code></pre> <p>If you're still experiencing issues after trying these troubleshooting steps, please open an issue on the GitHub repository with:</p> <ol> <li>Your debug information (use <code>collect_debug_info</code> above)</li> <li>A minimal code example that reproduces the issue</li> <li>The full error message and stack trace</li> <li>Your system environment details</li> </ol>"},{"location":"getting-started/examples/","title":"Examples &amp; Use Cases","text":"<p>This document provides practical examples of using SmartMessage in real-world scenarios.</p>"},{"location":"getting-started/examples/#basic-messaging-patterns","title":"Basic Messaging Patterns","text":""},{"location":"getting-started/examples/#simple-notification-system","title":"Simple Notification System","text":"<pre><code>require 'smart_message'\n\nclass NotificationMessage &lt; SmartMessage::Base\n  description \"Sends notifications to users via multiple channels\"\n\n  property :recipient\n  property :subject\n  property :body\n  property :priority, default: 'normal'\n  property :channel, default: 'email'\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n  end\n\n  def self.process(decoded_message)\n    notification = decoded_message\n\n    case notification.channel\n    when 'email'\n      send_email(notification)\n    when 'sms'\n      send_sms(notification)\n    when 'push'\n      send_push_notification(notification)\n    end\n  end\n\n  private\n\n  def self.send_email(notification)\n    puts \"\ud83d\udce7 Sending email to #{notification.recipient}\"\n    puts \"Subject: #{notification.subject}\"\n    puts \"Priority: #{notification.priority}\"\n  end\n\n  def self.send_sms(notification)\n    puts \"\ud83d\udcf1 Sending SMS to #{notification.recipient}\"\n    puts \"Message: #{notification.body}\"\n  end\n\n  def self.send_push_notification(notification)\n    puts \"\ud83d\udd14 Sending push notification to #{notification.recipient}\"\n    puts \"Title: #{notification.subject}\"\n  end\nend\n\n# Setup\nNotificationMessage.subscribe\n\n# Send notifications\nNotificationMessage.new(\n  recipient: \"user@example.com\",\n  subject: \"Welcome!\",\n  body: \"Thanks for signing up!\",\n  priority: \"high\"\n).publish\n\nNotificationMessage.new(\n  recipient: \"+1234567890\",\n  subject: \"Alert\",\n  body: \"Your order has shipped!\",\n  channel: \"sms\"\n).publish\n</code></pre>"},{"location":"getting-started/examples/#event-driven-architecture","title":"Event-Driven Architecture","text":"<pre><code># User registration event\nclass UserRegisteredEvent &lt; SmartMessage::Base\n  property :user_id\n  property :email\n  property :name\n  property :registration_source\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    event = decoded_message\n\n    # Fan out to multiple handlers\n    send_welcome_email(event)\n    create_user_profile(event)\n    track_analytics(event)\n    setup_default_preferences(event)\n  end\n\n  private\n\n  def self.send_welcome_email(event)\n    WelcomeEmailMessage.new(\n      user_id: event.user_id,\n      email: event.email,\n      name: event.name\n    ).publish\n  end\n\n  def self.create_user_profile(event)\n    CreateProfileMessage.new(\n      user_id: event.user_id,\n      source: event.registration_source\n    ).publish\n  end\n\n  def self.track_analytics(event)\n    AnalyticsMessage.new(\n      event_type: 'user_registration',\n      user_id: event.user_id,\n      properties: {\n        source: event.registration_source,\n        timestamp: event.timestamp\n      }\n    ).publish\n  end\n\n  def self.setup_default_preferences(event)\n    PreferencesMessage.new(\n      user_id: event.user_id,\n      preferences: default_preferences\n    ).publish\n  end\n\n  def self.default_preferences\n    {\n      email_notifications: true,\n      marketing_emails: false,\n      theme: 'light'\n    }\n  end\nend\n\n# Supporting message classes\nclass WelcomeEmailMessage &lt; SmartMessage::Base\n  property :user_id\n  property :email\n  property :name\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n\n    puts \"\ud83d\udce7 Sending welcome email to #{message.email} (#{message.name})\"\n    # Email sending logic here\n  end\nend\n\nclass AnalyticsMessage &lt; SmartMessage::Base\n  property :event_type\n  property :user_id\n  property :properties\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    event = decoded_message\n\n    puts \"\ud83d\udcca Tracking event: #{event.event_type} for user #{event.user_id}\"\n    # Analytics tracking logic here\n  end\nend\n\n# Setup and trigger\n[UserRegisteredEvent, WelcomeEmailMessage, AnalyticsMessage].each(&amp;:subscribe)\n\n# Simulate user registration\nUserRegisteredEvent.new(\n  user_id: 12345,\n  email: \"alice@example.com\",\n  name: \"Alice Johnson\",\n  registration_source: \"web_form\"\n).publish\n</code></pre>"},{"location":"getting-started/examples/#e-commerce-order-processing","title":"E-commerce Order Processing","text":"<pre><code># Order lifecycle management\nclass OrderCreatedMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :items\n  property :total_amount\n  property :shipping_address\n  property :created_at, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    order = decoded_message\n\n    # Validate order\n    if valid_order?(order)\n      # Reserve inventory\n      InventoryReservationMessage.new(\n        order_id: order.order_id,\n        items: order.items\n      ).publish\n\n      # Process payment\n      PaymentProcessingMessage.new(\n        order_id: order.order_id,\n        customer_id: order.customer_id,\n        amount: order.total_amount\n      ).publish\n    else\n      # Handle invalid order\n      OrderRejectedMessage.new(\n        order_id: order.order_id,\n        reason: \"Invalid order data\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.valid_order?(order)\n    order.items&amp;.any? &amp;&amp; order.total_amount&amp;.positive?\n  end\nend\n\nclass InventoryReservationMessage &lt; SmartMessage::Base\n  property :order_id\n  property :items\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    reservation = decoded_message\n\n    success = reserve_inventory(reservation.items)\n\n    if success\n      InventoryReservedMessage.new(\n        order_id: reservation.order_id\n      ).publish\n    else\n      InventoryFailedMessage.new(\n        order_id: reservation.order_id,\n        reason: \"Insufficient stock\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.reserve_inventory(items)\n    # Inventory reservation logic\n    puts \"\ud83c\udfea Reserving inventory for #{items.length} items\"\n    true  # Simulate success\n  end\nend\n\nclass PaymentProcessingMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    payment = decoded_message\n\n    success = process_payment(payment)\n\n    if success\n      PaymentSuccessMessage.new(\n        order_id: payment.order_id,\n        transaction_id: generate_transaction_id\n      ).publish\n    else\n      PaymentFailedMessage.new(\n        order_id: payment.order_id,\n        reason: \"Payment declined\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.process_payment(payment)\n    puts \"\ud83d\udcb3 Processing payment of $#{payment.amount} for order #{payment.order_id}\"\n    true  # Simulate success\n  end\n\n  def self.generate_transaction_id\n    \"txn_#{SecureRandom.hex(8)}\"\n  end\nend\n\n# Setup\n[\n  OrderCreatedMessage,\n  InventoryReservationMessage, \n  PaymentProcessingMessage\n].each(&amp;:subscribe)\n\n# Create an order\nOrderCreatedMessage.new(\n  order_id: \"ORD-001\",\n  customer_id: \"CUST-123\",\n  items: [\n    { sku: \"WIDGET-A\", quantity: 2, price: 19.99 },\n    { sku: \"GADGET-B\", quantity: 1, price: 49.99 }\n  ],\n  total_amount: 89.97,\n  shipping_address: {\n    street: \"123 Main St\",\n    city: \"Anytown\",\n    state: \"CA\",\n    zip: \"12345\"\n  }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#logging-and-monitoring","title":"Logging and Monitoring","text":"<pre><code># Centralized logging system\nclass LogMessage &lt; SmartMessage::Base\n  property :level\n  property :service\n  property :message\n  property :context\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n  property :correlation_id\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: \"application.log\")\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    log_entry = decoded_message\n\n    formatted_message = format_log_entry(log_entry)\n\n    case log_entry.level\n    when 'ERROR', 'FATAL'\n      send_alert(log_entry)\n    when 'WARN'\n      track_warning(log_entry)\n    end\n\n    puts formatted_message\n  end\n\n  private\n\n  def self.format_log_entry(log_entry)\n    \"[#{log_entry.timestamp}] #{log_entry.level} #{log_entry.service}: #{log_entry.message}\" +\n    (log_entry.correlation_id ? \" (#{log_entry.correlation_id})\" : \"\") +\n    (log_entry.context ? \" | #{log_entry.context.to_json}\" : \"\")\n  end\n\n  def self.send_alert(log_entry)\n    if log_entry.level == 'FATAL'\n      puts \"\ud83d\udea8 FATAL ERROR ALERT: #{log_entry.message}\"\n    else\n      puts \"\u26a0\ufe0f  ERROR ALERT: #{log_entry.message}\"\n    end\n  end\n\n  def self.track_warning(log_entry)\n    puts \"\ud83d\udcdd Warning tracked: #{log_entry.message}\"\n  end\nend\n\n# Application performance monitoring\nclass MetricMessage &lt; SmartMessage::Base\n  property :metric_name\n  property :value\n  property :unit\n  property :tags\n  property :timestamp, default: -&gt; { Time.now.to_f }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    metric = decoded_message\n\n    # Store metric (would typically go to monitoring system)\n    store_metric(metric)\n\n    # Check for alerts\n    check_thresholds(metric)\n  end\n\n  private\n\n  def self.store_metric(metric)\n    puts \"\ud83d\udcca Metric: #{metric.metric_name} = #{metric.value} #{metric.unit} #{metric.tags}\"\n  end\n\n  def self.check_thresholds(metric)\n    case metric.metric_name\n    when 'response_time'\n      if metric.value &gt; 1000  # More than 1 second\n        puts \"\u26a0\ufe0f  High response time alert: #{metric.value}ms\"\n      end\n    when 'error_rate'\n      if metric.value &gt; 0.05  # More than 5% error rate\n        puts \"\ud83d\udea8 High error rate alert: #{(metric.value * 100).round(2)}%\"\n      end\n    end\n  end\nend\n\n# Setup\nLogMessage.subscribe\nMetricMessage.subscribe\n\n# Log some events\nLogMessage.new(\n  level: \"INFO\",\n  service: \"user-service\",\n  message: \"User login successful\",\n  context: { user_id: 123, ip: \"192.168.1.1\" },\n  correlation_id: \"req-abc123\"\n).publish\n\nLogMessage.new(\n  level: \"ERROR\",\n  service: \"payment-service\",\n  message: \"Payment gateway timeout\",\n  context: { order_id: \"ORD-001\", gateway: \"stripe\" },\n  correlation_id: \"req-def456\"\n).publish\n\n# Send some metrics\nMetricMessage.new(\n  metric_name: \"response_time\",\n  value: 1250,\n  unit: \"ms\",\n  tags: { service: \"api\", endpoint: \"/users\" }\n).publish\n\nMetricMessage.new(\n  metric_name: \"error_rate\",\n  value: 0.08,\n  unit: \"percentage\",\n  tags: { service: \"payment-service\" }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#gateway-pattern","title":"Gateway Pattern","text":"<pre><code># Bridge between different message systems\nclass MessageGateway &lt; SmartMessage::Base\n  property :source_system\n  property :destination_system\n  property :message_type\n  property :payload\n\n  # Receive from one transport\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    gateway_message = decoded_message\n\n    # Transform and forward to destination system\n    case gateway_message.destination_system\n    when 'email_system'\n      forward_to_email_system(gateway_message)\n    when 'sms_system'\n      forward_to_sms_system(gateway_message)\n    when 'audit_system'\n      forward_to_audit_system(gateway_message)\n    end\n  end\n\n  private\n\n  def self.forward_to_email_system(gateway_message)\n    # Create a new message instance with different transport\n    email_message = EmailSystemMessage.new(\n      original_payload: gateway_message.payload,\n      source: gateway_message.source_system\n    )\n\n    # Override transport for this instance\n    email_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"email_system.log\")\n    end\n\n    email_message.publish\n  end\n\n  def self.forward_to_sms_system(gateway_message)\n    sms_message = SMSSystemMessage.new(\n      original_payload: gateway_message.payload,\n      source: gateway_message.source_system\n    )\n\n    sms_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"sms_system.log\")\n    end\n\n    sms_message.publish\n  end\n\n  def self.forward_to_audit_system(gateway_message)\n    audit_message = AuditSystemMessage.new(\n      event_type: gateway_message.message_type,\n      data: gateway_message.payload,\n      source_system: gateway_message.source_system,\n      processed_at: Time.now.iso8601\n    )\n\n    audit_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"audit_system.log\")\n    end\n\n    audit_message.publish\n  end\nend\n\n# Destination system message classes\nclass EmailSystemMessage &lt; SmartMessage::Base\n  property :original_payload\n  property :source\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udce7 Email system processed message from #{decoded_message.source}\"\n  end\nend\n\nclass SMSSystemMessage &lt; SmartMessage::Base\n  property :original_payload\n  property :source\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udcf1 SMS system processed message from #{decoded_message.source}\"\n  end\nend\n\nclass AuditSystemMessage &lt; SmartMessage::Base\n  property :event_type\n  property :data\n  property :source_system\n  property :processed_at\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udccb Audit system logged event from #{decoded_message.source_system}\"\n  end\nend\n\n# Setup\n[MessageGateway, EmailSystemMessage, SMSSystemMessage, AuditSystemMessage].each(&amp;:subscribe)\n\n# Route messages through gateway\nMessageGateway.new(\n  source_system: \"web_app\",\n  destination_system: \"email_system\",\n  message_type: \"notification\",\n  payload: { recipient: \"user@example.com\", subject: \"Hello!\" }\n).publish\n\nMessageGateway.new(\n  source_system: \"mobile_app\",\n  destination_system: \"audit_system\",\n  message_type: \"user_action\",\n  payload: { action: \"login\", user_id: 123 }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#error-handling-and-retry-patterns","title":"Error Handling and Retry Patterns","text":"<pre><code># Resilient message processing with retries\nclass ResilientMessage &lt; SmartMessage::Base\n  property :data\n  property :retry_count, default: 0\n  property :max_retries, default: 3\n  property :original_error\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n\n    begin\n      # Simulate potentially failing operation\n      if should_fail?(message)\n        raise StandardError, \"Simulated failure\"\n      end\n\n      puts \"\u2705 Successfully processed message: #{message.data}\"\n\n    rescue =&gt; e\n      handle_error(message, e)\n    end\n  end\n\n  private\n\n  def self.should_fail?(message)\n    # Simulate 30% failure rate\n    rand &lt; 0.3\n  end\n\n  def self.handle_error(message, error)\n    puts \"\u274c Error processing message: #{error.message}\"\n\n    if message.retry_count &lt; message.max_retries\n      # Retry with exponential backoff\n      delay = 2 ** message.retry_count\n      puts \"\ud83d\udd04 Retrying in #{delay} seconds (attempt #{message.retry_count + 1})\"\n\n      # In a real system, you'd use a delayed job or similar\n      Thread.new do\n        sleep(delay)\n\n        retry_message = new(\n          data: message.data,\n          retry_count: message.retry_count + 1,\n          max_retries: message.max_retries,\n          original_error: error.message\n        )\n\n        retry_message.publish\n      end\n    else\n      # Max retries exceeded, send to dead letter queue\n      DeadLetterMessage.new(\n        original_message: message.to_h,\n        final_error: error.message,\n        retry_attempts: message.retry_count,\n        failed_at: Time.now.iso8601\n      ).publish\n    end\n  end\nend\n\nclass DeadLetterMessage &lt; SmartMessage::Base\n  property :original_message\n  property :final_error\n  property :retry_attempts\n  property :failed_at\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: \"dead_letter_queue.log\")\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    dead_letter = decoded_message\n\n    puts \"\ud83d\udc80 Message sent to dead letter queue:\"\n    puts \"   Original: #{dead_letter.original_message}\"\n    puts \"   Error: #{dead_letter.final_error}\"\n    puts \"   Attempts: #{dead_letter.retry_attempts}\"\n    puts \"   Failed at: #{dead_letter.failed_at}\"\n\n    # Could trigger alerts, save to database, etc.\n  end\nend\n\n# Setup\nResilientMessage.subscribe\nDeadLetterMessage.subscribe\n\n# Send messages that might fail\n5.times do |i|\n  ResilientMessage.new(\n    data: \"Test message #{i + 1}\"\n  ).publish\n\n  sleep(0.1)  # Small delay between messages\nend\n</code></pre>"},{"location":"getting-started/examples/#testing-helpers","title":"Testing Helpers","text":"<pre><code># Test utilities for SmartMessage\nmodule SmartMessageTestHelpers\n  def self.with_test_transport\n    original_transports = {}\n\n    # Store original transports\n    SmartMessage::Base.descendants.each do |klass|\n      original_transports[klass] = klass.transport\n    end\n\n    # Set up test transport\n    test_transport = SmartMessage::Transport.create(:memory, auto_process: true)\n\n    SmartMessage::Base.descendants.each do |klass|\n      klass.config do\n        transport test_transport\n      end\n    end\n\n    yield test_transport\n\n  ensure\n    # Restore original transports\n    original_transports.each do |klass, transport|\n      klass.config do\n        transport transport\n      end\n    end\n  end\n\n  def self.clear_statistics\n    SS.reset\n  end\n\n  def self.wait_for_processing(timeout: 1.0)\n    start_time = Time.now\n\n    while Time.now - start_time &lt; timeout\n      # Check if any messages are still being processed\n      # This is a simplified check\n      sleep(0.01)\n    end\n  end\nend\n\n# Example test usage\ndef test_message_processing\n  SmartMessageTestHelpers.with_test_transport do |transport|\n    # Clear any existing messages\n    transport.clear_messages\n    SmartMessageTestHelpers.clear_statistics\n\n    # Set up subscriptions\n    TestMessage.subscribe\n\n    # Send test message\n    TestMessage.new(data: \"test\").publish\n\n    # Wait for processing\n    SmartMessageTestHelpers.wait_for_processing\n\n    # Check results\n    puts \"Messages in transport: #{transport.message_count}\"\n    puts \"Published count: #{SS.get('TestMessage', 'publish')}\"\n    puts \"Processed count: #{SS.get('TestMessage', 'TestMessage.process', 'routed')}\"\n  end\nend\n\nclass TestMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n    puts \"Processed test message: #{message.data}\"\n  end\nend\n\n# Run the test\ntest_message_processing\n</code></pre> <p>These examples demonstrate the flexibility and power of SmartMessage for building robust, scalable messaging systems. Each pattern can be adapted to your specific needs and combined with other patterns for more complex workflows.</p>"},{"location":"getting-started/examples/#executable-example-programs","title":"Executable Example Programs","text":"<p>The <code>examples/</code> directory contains complete, runnable programs that demonstrate various SmartMessage features:</p>"},{"location":"getting-started/examples/#memory-transport-examples","title":"Memory Transport Examples","text":"<ul> <li><code>memory/03_point_to_point_orders.rb</code> - Point-to-point order processing with payment integration</li> <li><code>memory/04_publish_subscribe_events.rb</code> - Event broadcasting to multiple services (email, SMS, audit)</li> <li><code>memory/05_many_to_many_chat.rb</code> - Interactive chat system with rooms, bots, and human agents</li> <li><code>memory/07_proc_handlers_demo.rb</code> - Flexible message handlers (blocks, procs, lambdas, methods)</li> <li><code>memory/08_custom_logger_demo.rb</code> - Advanced logging with SmartMessage::Logger::Default</li> <li><code>memory/09_error_handling_demo.rb</code> - Comprehensive validation, version mismatch, and error handling</li> <li><code>memory/10_entity_addressing_basic.rb</code> - Basic FROM/TO/REPLY_TO message addressing</li> <li><code>memory/11_entity_addressing_with_filtering.rb</code> - Advanced entity-aware message filtering</li> <li><code>memory/02_dead_letter_queue_demo.rb</code> - Complete Dead Letter Queue system demonstration</li> <li><code>memory/01_message_deduplication_demo.rb</code> - Message deduplication patterns</li> <li><code>memory/12_regex_filtering_microservices.rb</code> - Advanced regex filtering for microservices</li> <li><code>memory/13_header_block_configuration.rb</code> - Header and block configuration examples</li> <li><code>memory/14_global_configuration_demo.rb</code> - Global configuration management</li> <li><code>memory/15_logger_demo.rb</code> - Advanced logging demonstrations</li> </ul>"},{"location":"getting-started/examples/#redis-transport-examples","title":"Redis Transport Examples","text":"<ul> <li><code>redis/01_smart_home_iot_demo.rb</code> - Redis-based IoT sensor monitoring with real-time data flow</li> </ul>"},{"location":"getting-started/examples/#redis-enhanced-transport-examples","title":"Redis Enhanced Transport Examples","text":"<ul> <li><code>redis_enhanced/enhanced_01_basic_patterns.rb</code> - Basic enhanced transport patterns</li> <li><code>redis_enhanced/enhanced_02_fluent_api.rb</code> - Fluent API usage examples</li> <li><code>redis_enhanced/enhanced_03_dual_publishing.rb</code> - Dual publishing strategies</li> <li><code>redis_enhanced/enhanced_04_advanced_routing.rb</code> - Advanced message routing</li> </ul>"},{"location":"getting-started/examples/#redis-queue-transport-examples","title":"Redis Queue Transport Examples","text":"<ul> <li><code>redis_queue/01_basic_messaging.rb</code> - Basic queue messaging patterns</li> <li><code>redis_queue/02_pattern_routing.rb</code> - Pattern-based message routing</li> <li><code>redis_queue/03_fluent_api.rb</code> - Fluent API for queue operations</li> <li><code>redis_queue/04_load_balancing.rb</code> - Load balancing across workers</li> <li><code>redis_queue/05_microservices.rb</code> - Microservices communication</li> <li><code>redis_queue/06_emergency_alerts.rb</code> - Emergency alert system</li> <li><code>redis_queue/07_queue_management.rb</code> - Queue management utilities</li> <li><code>redis_queue/01_comprehensive_examples.rb</code> - Comprehensive feature demonstration</li> </ul>"},{"location":"getting-started/examples/#city-scenario-comprehensive-demo","title":"City Scenario (Comprehensive Demo)","text":"<ul> <li><code>city_scenario/</code> - Complete emergency services simulation with multiple services and AI integration</li> </ul>"},{"location":"getting-started/examples/#performance-testing","title":"Performance Testing","text":"<ul> <li><code>performance_metrics/</code> - Benchmarking tools and performance comparisons</li> </ul>"},{"location":"getting-started/examples/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to the SmartMessage directory\ncd smart_message\n\n# Run examples from their respective transport directories\nruby examples/memory/03_point_to_point_orders.rb\nruby examples/memory/02_dead_letter_queue_demo.rb\nruby examples/redis/01_smart_home_iot_demo.rb\nruby examples/redis_queue/01_basic_messaging.rb\n\n# For city scenario comprehensive demo\ncd examples/city_scenario &amp;&amp; ./start_demo.sh\n</code></pre> <p>Each example is self-contained and includes: - Clear educational comments - Multiple message classes - Complete setup and teardown - Real-world scenarios - Best practices demonstration</p>"},{"location":"getting-started/examples/#example-features-demonstrated","title":"Example Features Demonstrated","text":"Example Transport Features Use Case memory/03 Memory/STDOUT Point-to-point, validation Order processing memory/04 Memory/STDOUT Pub-sub, multiple handlers Event broadcasting memory/05 Memory Many-to-many, bots Chat systems redis/01 Redis IoT, real-time, addressing Smart home monitoring memory/07 Memory Proc handlers, flexibility Dynamic message handling memory/08 Memory/STDOUT Custom logging, lifecycle Production logging memory/09 Memory/STDOUT Error handling, validation Robust message systems memory/10-11 Memory/STDOUT Entity addressing, filtering Microservice communication memory/02 Memory DLQ, circuit breakers, replay Production reliability redis_queue/* Redis Queue Load balancing, persistence Production messaging city_scenario/* Redis AI integration, health monitoring Emergency services <p>These examples provide practical, working code that you can use as a starting point for your own SmartMessage implementations.</p>"},{"location":"getting-started/quick-start/","title":"Getting Started with SmartMessage","text":"<p>This guide will help you get up and running with SmartMessage quickly.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Add SmartMessage to your Gemfile:</p> <pre><code>gem 'smart_message'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre> <p>Or install directly:</p> <pre><code>gem install smart_message\n</code></pre>"},{"location":"getting-started/quick-start/#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.0.0</li> <li>No additional system dependencies for basic usage</li> </ul>"},{"location":"getting-started/quick-start/#transport-options","title":"Transport Options","text":"<p>SmartMessage supports multiple transport layers:</p>"},{"location":"getting-started/quick-start/#built-in-transports","title":"Built-in Transports","text":"<ul> <li>Memory Transport - Perfect for development and testing. No external dependencies required.</li> <li>STDOUT Transport - Great for debugging and logging. No external dependencies.</li> <li>Redis Transport - Production-ready transport for distributed systems. Requires Redis server.</li> </ul>"},{"location":"getting-started/quick-start/#redis-installation-optional","title":"Redis Installation (Optional)","text":"<p>The Redis transport is built-in but requires Redis server to be installed. However, you don't need Redis just to play around - the Memory transport works great for development and testing.</p> <p>If you want to use Redis transport:</p> <p>macOS: <pre><code>brew install redis\nbrew services start redis\n</code></pre></p> <p>Ubuntu/Debian: <pre><code>sudo apt-get update\nsudo apt-get install redis-server\n</code></pre></p> <p>Other Transports: Additional transport layers (RabbitMQ, Kafka, etc.) are available as separate plugin repositories. Check the Transports documentation for more information.</p>"},{"location":"getting-started/quick-start/#your-first-message","title":"Your First Message","text":"<p>Let's create a simple message class and see it in action:</p>"},{"location":"getting-started/quick-start/#1-define-a-message-class","title":"1. Define a Message Class","text":"<pre><code>require 'smart_message'\n\nclass WelcomeMessage &lt; SmartMessage::Base\n  # Add a description for the message class\n  description \"Welcomes new users after successful signup\"\n\n  # Configure entity addressing (Method 1: Direct methods)\n  from 'user-service'           # Required: identifies sender\n  to 'notification-service'     # Optional: specific recipient\n  reply_to 'user-service'       # Optional: where responses go\n\n  # Alternative Method 2: Using header block\n  # header do\n  #   from 'user-service'\n  #   to 'notification-service'\n  #   reply_to 'user-service'\n  # end\n\n  # Define message properties\n  property :user_name\n  property :email\n  property :signup_date\n\n  # Configure the transport (where messages go)\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n  end\n\n  # Define how to process received messages\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    welcome = decoded_message\n\n    # Process the welcome message\n    puts \"\ud83c\udf89 Welcome #{welcome.user_name}!\"\n    puts \"\ud83d\udce7 Email: #{welcome.email}\"\n    puts \"\ud83d\udcc5 Signed up: #{welcome.signup_date}\"\n  end\nend\n</code></pre>"},{"location":"getting-started/quick-start/#2-subscribe-to-messages","title":"2. Subscribe to Messages","text":"<p>Before publishing, set up a subscription to receive messages. SmartMessage provides several ways to handle incoming messages:</p> <pre><code># 1. Default handler (uses the self.process method defined above)\nWelcomeMessage.subscribe\n\n# 2. Block handler (inline processing logic)\nWelcomeMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"\ud83d\udc4b Quick welcome for #{data['user_name']}\"\nend\n\n# 3. Proc handler (reusable processing logic)\nwelcome_processor = proc do |header, payload|\n  data = JSON.parse(payload)\n  EmailService.send_welcome_email(data['email'], data['user_name'])\nend\nWelcomeMessage.subscribe(welcome_processor)\n\n# 4. Custom method handler\nWelcomeMessage.subscribe(\"UserService.handle_welcome\")\n</code></pre>"},{"location":"getting-started/quick-start/#3-create-and-publish-a-message","title":"3. Create and Publish a Message","text":"<pre><code># Create a new welcome message\nwelcome = WelcomeMessage.new(\n  user_name: \"Alice Johnson\",\n  email: \"alice@example.com\", \n  signup_date: Date.today.to_s\n)\n\n# Publish the message\nwelcome.publish\n</code></pre>"},{"location":"getting-started/quick-start/#4-see-it-in-action","title":"4. See It in Action","text":"<p>Run your script and you should see:</p> <pre><code>===================================================\n== SmartMessage Published via STDOUT Transport\n== Header: #&lt;SmartMessage::Header:0x... @uuid=\"...\", @message_class=\"WelcomeMessage\", ...&gt;\n== Payload: {\"user_name\":\"Alice Johnson\",\"email\":\"alice@example.com\",\"signup_date\":\"2025-08-17\"}\n===================================================\n\n\ud83c\udf89 Welcome Alice Johnson!\n\ud83d\udce7 Email: alice@example.com\n\ud83d\udcc5 Signed up: 2025-08-17\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Message Definition: We created a <code>WelcomeMessage</code> class with three properties</li> <li>Configuration: We configured it to use STDOUT transport with loopback enabled</li> <li>Subscription: We subscribed to process incoming messages of this type</li> <li>Publishing: We created an instance and published it</li> <li>Processing: Because loopback is enabled, the message was immediately routed back and processed</li> </ol>"},{"location":"getting-started/quick-start/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/quick-start/#properties","title":"Properties","text":"<p>Messages use Hashie::Dash properties for type-safe attributes:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Represents customer orders for processing and fulfillment\"\n\n  property :order_id, required: true\n  property :amount, transform_with: -&gt;(v) { BigDecimal(v.to_s) }\n  property :items, default: []\n  property :created_at, default: -&gt; { Time.now }\nend\n</code></pre>"},{"location":"getting-started/quick-start/#headers","title":"Headers","text":"<p>Every message automatically gets a header with metadata:</p> <pre><code>message = WelcomeMessage.new(user_name: \"Bob\")\nputs message._sm_header.uuid          # Unique identifier\nputs message._sm_header.message_class # \"WelcomeMessage\"\nputs message._sm_header.published_at  # Timestamp when published\nputs message._sm_header.publisher_pid # Process ID of publisher\nputs message._sm_header.from          # 'user-service'\nputs message._sm_header.to            # 'notification-service'\nputs message._sm_header.reply_to      # 'user-service'\n</code></pre>"},{"location":"getting-started/quick-start/#transports","title":"Transports","text":"<p>Transports handle where messages go. Built-in options include:</p> <pre><code># STDOUT - for development/debugging\ntransport SmartMessage::Transport.create(:stdout, loopback: true)\n\n# Memory - for testing\ntransport SmartMessage::Transport.create(:memory, auto_process: true)\n</code></pre>"},{"location":"getting-started/quick-start/#serializers","title":"Serializers","text":"<p>Transports handle their own serialization automatically: - MemoryTransport: No serialization (objects passed directly) - StdoutTransport: JSON serialization for readability - RedisTransport: MessagePack (with JSON fallback) for efficiency</p>"},{"location":"getting-started/quick-start/#message-handlers","title":"Message Handlers","text":"<p>SmartMessage supports four types of message handlers to give you flexibility in how you process messages:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Handles customer order processing and fulfillment\"\n\n  # Define your message properties\n  property :order_id\n  property :amount\n\n  # Default handler - processed when no custom handler specified\n  def self.process(header, payload)\n    puts \"Default processing for order\"\n  end\nend\n\n# 1. Default handler (uses self.process)\nOrderMessage.subscribe\n\n# 2. Block handler - great for simple, inline logic\nOrderMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"Block handler: Processing order #{data['order_id']}\"\nend\n\n# 3. Proc handler - reusable across message types\naudit_logger = proc do |header, payload|\n  puts \"Audit: #{header.message_class} at #{header.published_at}\"\nend\nOrderMessage.subscribe(audit_logger)\n\n# 4. Method handler - organized in service classes\nclass OrderService\n  def self.process_order(header, payload)\n    puts \"Service processing order\"\n  end\nend\nOrderMessage.subscribe(\"OrderService.process_order\")\n</code></pre> <p>When to use each type: - Default: Simple built-in processing for the message type - Block: Quick inline logic specific to one subscription - Proc: Reusable handlers that work across multiple message types - Method: Complex business logic organized in service classes</p>"},{"location":"getting-started/quick-start/#entity-addressing","title":"Entity Addressing","text":"<p>SmartMessage supports entity-to-entity addressing for sophisticated messaging patterns:</p> <pre><code># Point-to-point messaging\nclass PaymentMessage &lt; SmartMessage::Base\n  from 'payment-service'    # Required: sender identity\n  to 'bank-gateway'         # Optional: specific recipient\n  reply_to 'payment-service' # Optional: where responses go\n\n  property :amount, required: true\nend\n\n# Broadcast messaging (no 'to' field)\nclass AnnouncementMessage &lt; SmartMessage::Base\n  from 'admin-service'      # Required sender\n  # No 'to' = broadcast to all subscribers\n\n  property :message, required: true\nend\n\n# Instance-level addressing override\npayment = PaymentMessage.new(amount: 100.00)\npayment.to('backup-gateway')  # Override destination\npayment.publish\n</code></pre> <p>For more details, see Entity Addressing.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics working, explore:</p> <ul> <li>Architecture Overview - Understand how SmartMessage works</li> <li>Examples - See more practical use cases</li> <li>Transports - Learn about different transport options</li> </ul>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#simple-notification-system","title":"Simple Notification System","text":"<pre><code>class NotificationMessage &lt; SmartMessage::Base\n  description \"Sends notifications to users via email, SMS, or push\"\n\n  property :recipient\n  property :subject\n  property :body\n  property :priority, default: 'normal'\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    notification = decoded_message\n\n    # Send email, SMS, push notification, etc.\n    send_notification(notification)\n  end\n\n  private\n\n  def self.send_notification(notification)\n    puts \"Sending #{notification.priority} notification to #{notification.recipient}\"\n    puts \"Subject: #{notification.subject}\"\n  end\nend\n\n# Subscribe and send\nNotificationMessage.subscribe\n\nNotificationMessage.new(\n  recipient: \"user@example.com\",\n  subject: \"Welcome!\",\n  body: \"Thanks for signing up!\",\n  priority: \"high\"\n).publish\n</code></pre>"},{"location":"getting-started/quick-start/#event-logging","title":"Event Logging","text":"<pre><code>class EventMessage &lt; SmartMessage::Base\n  description \"Logs application events for monitoring and analytics\"\n\n  property :event_type\n  property :user_id\n  property :data\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: 'events.log')\n  end\nend\n\n# Log events\nEventMessage.new(\n  event_type: 'user_login',\n  user_id: 123,\n  data: { ip: '192.168.1.1', user_agent: 'Chrome' }\n).publish\n</code></pre>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Check the Troubleshooting Guide</li> <li>Look at more Examples</li> </ul>"},{"location":"reference/dead-letter-queue/","title":"Dead Letter Queue","text":"<p>SmartMessage includes a comprehensive file-based Dead Letter Queue (DLQ) system for capturing, storing, and replaying failed messages. The DLQ provides production-grade reliability with automatic integration into the circuit breaker system.</p>"},{"location":"reference/dead-letter-queue/#overview","title":"Overview","text":"<p>The Dead Letter Queue serves as a safety net for your messaging system:</p> <ul> <li>Automatic Capture: Failed messages are automatically stored when circuit breakers trip</li> <li>Manual Capture: Explicitly store messages that fail business logic validation</li> <li>Replay Capabilities: Retry failed messages individually, in batches, or all at once</li> <li>Transport Override: Replay messages through a different transport than originally configured</li> <li>Administrative Tools: Filter, analyze, and export messages for debugging</li> <li>Thread-Safe: All operations are protected with mutex for concurrent access</li> </ul>"},{"location":"reference/dead-letter-queue/#file-format","title":"File Format","text":"<p>The DLQ uses JSON Lines (.jsonl) format - one JSON object per line:</p> <pre><code>{\"timestamp\":\"2025-08-19T10:30:45Z\",\"header\":{...},\"payload\":\"...\",\"error\":\"Connection timeout\",\"retry_count\":0,\"transport\":\"Redis\",\"stack_trace\":\"...\"}\n{\"timestamp\":\"2025-08-19T10:31:12Z\",\"header\":{...},\"payload\":\"...\",\"error\":\"Circuit breaker open\",\"retry_count\":1,\"transport\":\"Redis\",\"stack_trace\":\"...\"}\n</code></pre> <p>Benefits of JSON Lines: - Append-only for efficient writes - Line-by-line processing for memory efficiency - Human-readable for debugging - Easy to process with standard Unix tools</p>"},{"location":"reference/dead-letter-queue/#configuration","title":"Configuration","text":""},{"location":"reference/dead-letter-queue/#global-default-configuration","title":"Global Default Configuration","text":"<p>Configure a default DLQ that all components will use:</p> <pre><code># Set default path for all DLQ operations\nSmartMessage::DeadLetterQueue.configure_default('/var/log/app/dlq.jsonl')\n\n# Access the default instance anywhere\ndlq = SmartMessage::DeadLetterQueue.default\n</code></pre>"},{"location":"reference/dead-letter-queue/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Use environment variables for different deployments:</p> <pre><code># In your application initialization\nSmartMessage::DeadLetterQueue.configure_default(\n  ENV.fetch('SMART_MESSAGE_DLQ_PATH', 'dead_letters.jsonl')\n)\n</code></pre>"},{"location":"reference/dead-letter-queue/#per-environment-configuration","title":"Per-Environment Configuration","text":"<p>Configure different paths for each environment:</p> <pre><code># config/initializers/smart_message.rb (Rails example)\ncase Rails.env\nwhen 'production'\n  SmartMessage::DeadLetterQueue.configure_default('/var/log/smart_message/production_dlq.jsonl')\nwhen 'staging'\n  SmartMessage::DeadLetterQueue.configure_default('/var/log/smart_message/staging_dlq.jsonl')\nelse\n  SmartMessage::DeadLetterQueue.configure_default('tmp/development_dlq.jsonl')\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#custom-instances","title":"Custom Instances","text":"<p>Create separate DLQ instances for different purposes:</p> <pre><code># Critical failures need special handling\ncritical_dlq = SmartMessage::DeadLetterQueue.new('/var/log/critical_failures.jsonl')\n\n# Separate DLQ for payment messages\npayment_dlq = SmartMessage::DeadLetterQueue.new('/var/log/payment_failures.jsonl')\n\n# Temporary DLQ for testing\ntest_dlq = SmartMessage::DeadLetterQueue.new('/tmp/test_failures.jsonl')\n</code></pre>"},{"location":"reference/dead-letter-queue/#core-operations","title":"Core Operations","text":""},{"location":"reference/dead-letter-queue/#fifo-queue-operations","title":"FIFO Queue Operations","text":"<p>The DLQ operates as a First-In-First-Out queue:</p> <pre><code>dlq = SmartMessage::DeadLetterQueue.default\n\n# Add a failed message (accepts decoded message instance)\nentry = dlq.enqueue(\n  decoded_message,     # SmartMessage::Base instance\n  error: \"Connection timeout\",\n  retry_count: 0,\n  transport: \"Redis\",\n  stack_trace: exception.backtrace.join(\"\\n\")\n)\n\n# Check queue size\nputs \"Messages in queue: #{dlq.size}\"\n\n# Peek at the oldest message without removing it\nnext_message = dlq.peek\nputs \"Next for replay: #{next_message[:header][:message_class]}\"\n\n# Remove and get the oldest message\nmessage = dlq.dequeue\nprocess_message(message) if message\n\n# Clear all messages\ndlq.clear\n</code></pre>"},{"location":"reference/dead-letter-queue/#message-structure","title":"Message Structure","text":"<p>Each DLQ entry contains:</p> <pre><code>{\n  timestamp: \"2025-08-19T10:30:45Z\",        # When the failure occurred\n  header: {                                 # Complete message header\n    uuid: \"abc-123\",\n    message_class: \"OrderMessage\",\n    published_at: \"2025-08-19T10:30:40Z\",\n    publisher_pid: 12345,\n    version: 1,\n    from: \"order-service\",\n    to: \"payment-service\",\n    reply_to: \"order-service\"\n  },\n  payload: '{\"order_id\":\"123\",\"amount\":99.99}',  # Original message payload\n  payload_format: \"json\",                   # Serialization format\n  error: \"Connection refused\",              # Error message\n  retry_count: 2,                           # Number of retry attempts\n  transport: \"Redis\",                       # Transport that failed\n  stack_trace: \"...\"                        # Full stack trace (optional)\n}\n</code></pre>"},{"location":"reference/dead-letter-queue/#replay-capabilities","title":"Replay Capabilities","text":""},{"location":"reference/dead-letter-queue/#individual-message-replay","title":"Individual Message Replay","text":"<p>Replay the oldest message:</p> <pre><code>result = dlq.replay_one\nif result[:success]\n  puts \"Message replayed successfully\"\nelse\n  puts \"Replay failed: #{result[:error]}\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#batch-replay","title":"Batch Replay","text":"<p>Replay multiple messages:</p> <pre><code># Replay next 10 messages\nresults = dlq.replay_batch(10)\nputs \"Successful: #{results[:success]}\"\nputs \"Failed: #{results[:failed]}\"\nresults[:errors].each do |error|\n  puts \"Error: #{error}\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#full-queue-replay","title":"Full Queue Replay","text":"<p>Replay all messages:</p> <pre><code>results = dlq.replay_all\nputs \"Replayed #{results[:success]} messages\"\nputs \"Failed to replay #{results[:failed]} messages\"\n</code></pre>"},{"location":"reference/dead-letter-queue/#transport-override","title":"Transport Override","text":"<p>Replay through a different transport:</p> <pre><code># Original message used Redis, replay through RabbitMQ\nrabbit_transport = SmartMessage::Transport.create(:rabbitmq)\n\n# Replay one with override\ndlq.replay_one(rabbit_transport)\n\n# Replay batch with override\ndlq.replay_batch(10, rabbit_transport)\n\n# Replay all with override\ndlq.replay_all(rabbit_transport)\n</code></pre>"},{"location":"reference/dead-letter-queue/#administrative-functions","title":"Administrative Functions","text":""},{"location":"reference/dead-letter-queue/#message-filtering","title":"Message Filtering","text":"<p>Filter messages for analysis:</p> <pre><code># Find all failed OrderMessage instances\norder_failures = dlq.filter_by_class('OrderMessage')\nputs \"Found #{order_failures.size} failed orders\"\n\n# Find all timeout errors\ntimeout_errors = dlq.filter_by_error_pattern(/timeout/i)\ntimeout_errors.each do |entry|\n  puts \"Timeout at #{entry[:timestamp]}: #{entry[:error]}\"\nend\n\n# Find connection errors\nconnection_errors = dlq.filter_by_error_pattern('Connection refused')\n</code></pre>"},{"location":"reference/dead-letter-queue/#statistics","title":"Statistics","text":"<p>Get queue statistics:</p> <pre><code>stats = dlq.statistics\nputs \"Total messages: #{stats[:total]}\"\n\n# Breakdown by message class\nstats[:by_class].each do |klass, count|\n  puts \"#{klass}: #{count} failures\"\nend\n\n# Breakdown by error type\nstats[:by_error].sort_by { |_, count| -count }.first(5).each do |error, count|\n  puts \"#{error}: #{count} occurrences\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#time-based-export","title":"Time-Based Export","text":"<p>Export messages within a time range:</p> <pre><code># Get failures from the last hour\none_hour_ago = Time.now - 3600\nrecent_failures = dlq.export_range(one_hour_ago, Time.now)\n\n# Get failures from yesterday\nyesterday_start = Time.now - 86400\nyesterday_end = Time.now - 1\nyesterday_failures = dlq.export_range(yesterday_start, yesterday_end)\n\n# Export for analysis\nFile.write('failures_export.json', recent_failures.to_json)\n</code></pre>"},{"location":"reference/dead-letter-queue/#message-inspection","title":"Message Inspection","text":"<p>Inspect messages without removing them:</p> <pre><code># Look at next 10 messages\nmessages = dlq.inspect_messages(limit: 10)\nmessages.each do |msg|\n  puts \"#{msg[:timestamp]} - #{msg[:header][:message_class]}: #{msg[:error]}\"\nend\n\n# Default limit is 10\ndlq.inspect_messages.each do |msg|\n  analyze_failure(msg)\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#integration-with-circuit-breakers","title":"Integration with Circuit Breakers","text":"<p>The DLQ is automatically integrated with SmartMessage's circuit breaker system:</p>"},{"location":"reference/dead-letter-queue/#automatic-capture","title":"Automatic Capture","text":"<p>When circuit breakers trip, messages are automatically sent to the DLQ:</p> <pre><code>class PaymentMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis)\n    # Circuit breaker configured automatically\n  end\nend\n\n# If Redis is down, circuit breaker trips and message goes to DLQ\nmessage = PaymentMessage.new(amount: 100.00)\nbegin\n  message.publish\nrescue =&gt; e\n  # Message is already in DLQ via circuit breaker\n  puts \"Message saved to DLQ\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#manual-circuit-breaker-integration","title":"Manual Circuit Breaker Integration","text":"<p>Configure custom circuit breakers with DLQ fallback:</p> <pre><code>class CriticalService\n  include BreakerMachines::DSL\n\n  circuit :external_api do\n    threshold failures: 3, within: 60.seconds\n    reset_after 30.seconds\n\n    # Use custom DLQ for critical failures\n    custom_dlq = SmartMessage::DeadLetterQueue.new('/var/log/critical.jsonl')\n    fallback SmartMessage::CircuitBreaker::Fallbacks.dead_letter_queue(custom_dlq)\n  end\n\n  def call_api(message)\n    circuit(:external_api).wrap do\n      # API call that might fail\n      external_api.send(message)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"reference/dead-letter-queue/#queue-size-monitoring","title":"Queue Size Monitoring","text":"<p>Monitor DLQ growth:</p> <pre><code># Simple monitoring script\nloop do\n  dlq = SmartMessage::DeadLetterQueue.default\n  size = dlq.size\n\n  if size &gt; 100\n    send_alert(\"DLQ size critical: #{size} messages\")\n  elsif size &gt; 50\n    send_warning(\"DLQ size warning: #{size} messages\")\n  end\n\n  sleep 60  # Check every minute\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#error-pattern-detection","title":"Error Pattern Detection","text":"<p>Detect systematic failures:</p> <pre><code>dlq = SmartMessage::DeadLetterQueue.default\nstats = dlq.statistics\n\n# Check for dominant error patterns\ntop_error = stats[:by_error].max_by { |_, count| count }\nif top_error &amp;&amp; top_error[1] &gt; 10\n  alert(\"Systematic failure detected: #{top_error[0]} (#{top_error[1]} occurrences)\")\nend\n\n# Check for specific service failures\nstats[:by_class].each do |klass, count|\n  if count &gt; 5\n    alert(\"Service degradation: #{klass} has #{count} failures\")\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#best-practices","title":"Best Practices","text":""},{"location":"reference/dead-letter-queue/#1-regular-monitoring","title":"1. Regular Monitoring","text":"<p>Set up monitoring for DLQ size and growth rate:</p> <pre><code># Prometheus metrics example\ndlq_size = Prometheus::Client::Gauge.new(:dlq_size, 'Dead letter queue size')\ndlq_size.set(SmartMessage::DeadLetterQueue.default.size)\n</code></pre>"},{"location":"reference/dead-letter-queue/#2-automated-replay","title":"2. Automated Replay","text":"<p>Schedule periodic replay attempts:</p> <pre><code># Sidekiq job example\nclass ReplayDLQJob\n  include Sidekiq::Worker\n\n  def perform\n    dlq = SmartMessage::DeadLetterQueue.default\n\n    # Only replay if queue is manageable\n    if dlq.size &lt; 100\n      results = dlq.replay_all\n      log_results(results)\n    else\n      # Replay in smaller batches\n      results = dlq.replay_batch(10)\n      log_results(results)\n    end\n  end\n\n  private\n\n  def log_results(results)\n    Rails.logger.info(\"DLQ Replay: #{results[:success]} success, #{results[:failed]} failed\")\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#3-archival-strategy","title":"3. Archival Strategy","text":"<p>Archive old messages:</p> <pre><code># Archive messages older than 7 days\ndef archive_old_messages\n  dlq = SmartMessage::DeadLetterQueue.default\n  archive_path = \"/var/archive/dlq_#{Date.today}.jsonl\"\n\n  seven_days_ago = Time.now - (7 * 86400)\n  old_messages = dlq.export_range(Time.at(0), seven_days_ago)\n\n  if old_messages.any?\n    File.write(archive_path, old_messages.map(&amp;:to_json).join(\"\\n\"))\n    # Remove archived messages from active DLQ\n    # (Note: This would require implementing a remove_range method)\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#4-error-classification","title":"4. Error Classification","text":"<p>Classify errors for better handling:</p> <pre><code>class DLQAnalyzer\n  TRANSIENT_ERRORS = [\n    /connection refused/i,\n    /timeout/i,\n    /temporarily unavailable/i\n  ]\n\n  PERMANENT_ERRORS = [\n    /invalid message format/i,\n    /unauthorized/i,\n    /not found/i\n  ]\n\n  def self.classify_errors(dlq)\n    transient = []\n    permanent = []\n\n    dlq.inspect_messages(limit: 100).each do |msg|\n      if TRANSIENT_ERRORS.any? { |pattern| msg[:error].match?(pattern) }\n        transient &lt;&lt; msg\n      elsif PERMANENT_ERRORS.any? { |pattern| msg[:error].match?(pattern) }\n        permanent &lt;&lt; msg\n      end\n    end\n\n    { transient: transient, permanent: permanent }\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/dead-letter-queue/#common-issues","title":"Common Issues","text":""},{"location":"reference/dead-letter-queue/#1-dlq-file-growing-too-large","title":"1. DLQ File Growing Too Large","text":"<pre><code># Rotate DLQ files\ndef rotate_dlq\n  dlq = SmartMessage::DeadLetterQueue.default\n  timestamp = Time.now.strftime('%Y%m%d_%H%M%S')\n\n  # Move current file\n  FileUtils.mv(dlq.file_path, \"#{dlq.file_path}.#{timestamp}\")\n\n  # DLQ will create new file automatically\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#2-replay-failures","title":"2. Replay Failures","text":"<pre><code># Debug replay failures\nresult = dlq.replay_one\nunless result[:success]\n  puts \"Replay failed: #{result[:error]}\"\n\n  # Check if message class still exists\n  message = dlq.peek\n  begin\n    message[:header][:message_class].constantize\n  rescue NameError =&gt; e\n    puts \"Message class no longer exists: #{e.message}\"\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#3-corrupted-dlq-file","title":"3. Corrupted DLQ File","text":"<pre><code># Recover from corrupted file\ndef recover_dlq(corrupted_path)\n  recovered = []\n\n  File.foreach(corrupted_path) do |line|\n    begin\n      entry = JSON.parse(line.strip, symbolize_names: true)\n      recovered &lt;&lt; entry\n    rescue JSON::ParserError\n      # Skip corrupted line\n      puts \"Skipping corrupted line: #{line[0..50]}...\"\n    end\n  end\n\n  # Write recovered entries to new file\n  new_dlq = SmartMessage::DeadLetterQueue.new(\"#{corrupted_path}.recovered\")\n  recovered.each do |entry|\n    new_dlq.enqueue(\n      SmartMessage::Header.new(entry[:header]),\n      entry[:payload],\n      error: entry[:error],\n      retry_count: entry[:retry_count]\n    )\n  end\n\n  puts \"Recovered #{recovered.size} messages\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/dead-letter-queue/#file-io-optimization","title":"File I/O Optimization","text":"<p>The DLQ uses several optimizations:</p> <ol> <li>Append-only writes: New messages are appended, not inserted</li> <li>Immediate sync: <code>file.fsync</code> ensures durability</li> <li>Mutex protection: Thread-safe but may create contention</li> <li>Line-based processing: Memory efficient for large files</li> </ol>"},{"location":"reference/dead-letter-queue/#scaling-strategies","title":"Scaling Strategies","text":"<p>For high-volume systems:</p> <pre><code># Use multiple DLQ instances by message type\nclass DLQRouter\n  def self.get_dlq_for(message_class)\n    case message_class\n    when /Payment/\n      @payment_dlq ||= SmartMessage::DeadLetterQueue.new('/var/log/payment_dlq.jsonl')\n    when /Order/\n      @order_dlq ||= SmartMessage::DeadLetterQueue.new('/var/log/order_dlq.jsonl')\n    else\n      SmartMessage::DeadLetterQueue.default\n    end\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#memory-usage","title":"Memory Usage","text":"<p>For large DLQ files:</p> <pre><code># Process in chunks to avoid memory issues\ndef process_large_dlq(dlq, chunk_size: 100)\n  processed = 0\n\n  while dlq.size &gt; 0 &amp;&amp; processed &lt; 1000\n    # Process only chunk_size at a time\n    chunk_size.times do\n      break if dlq.size == 0\n\n      message = dlq.dequeue\n      process_message(message)\n      processed += 1\n    end\n\n    # Let other operations run\n    sleep(0.1)\n  end\n\n  processed\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#security-considerations","title":"Security Considerations","text":""},{"location":"reference/dead-letter-queue/#file-permissions","title":"File Permissions","text":"<p>Ensure proper file permissions:</p> <pre><code># Set restrictive permissions on DLQ files\ndef secure_dlq_file(path)\n  File.chmod(0600, path) if File.exist?(path)  # Read/write for owner only\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#sensitive-data","title":"Sensitive Data","text":"<p>Be careful with sensitive data in DLQ:</p> <pre><code># Sanitize sensitive data before storing\ndef sanitize_for_dlq(payload)\n  data = JSON.parse(payload)\n  data['credit_card'] = 'REDACTED' if data['credit_card']\n  data['password'] = 'REDACTED' if data['password']\n  data.to_json\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#encryption","title":"Encryption","text":"<p>For sensitive environments:</p> <pre><code># Example: Encrypt DLQ entries\nrequire 'openssl'\n\nclass EncryptedDLQ &lt; SmartMessage::DeadLetterQueue\n  def enqueue(header, payload, **options)\n    encrypted_payload = encrypt(payload)\n    super(header, encrypted_payload, **options)\n  end\n\n  def dequeue\n    entry = super\n    return nil unless entry\n\n    entry[:payload] = decrypt(entry[:payload])\n    entry\n  end\n\n  private\n\n  def encrypt(data)\n    # Implement encryption\n  end\n\n  def decrypt(data)\n    # Implement decryption\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#summary","title":"Summary","text":"<p>The SmartMessage Dead Letter Queue provides:</p> <ul> <li>Reliability: Automatic capture of failed messages</li> <li>Flexibility: Multiple configuration options</li> <li>Recoverability: Comprehensive replay capabilities</li> <li>Observability: Statistics and filtering for analysis</li> <li>Integration: Seamless circuit breaker integration</li> <li>Production-Ready: Thread-safe, performant, and scalable</li> </ul> <p>The DLQ ensures that no message is lost, even during system failures, and provides the tools needed to analyze, replay, and manage failed messages effectively.</p>"},{"location":"reference/logging/","title":"Logging in SmartMessage","text":"<p>SmartMessage provides comprehensive logging capabilities with support for multiple output formats, colorization, structured logging, and file rolling. Built on the Lumberjack logging framework, it offers production-ready features with flexible configuration options.</p>"},{"location":"reference/logging/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Configuration Options</li> <li>Output Formats</li> <li>Colorized Console Output</li> <li>File Rolling</li> <li>Structured Logging</li> <li>Application Integration</li> <li>SmartMessage Integration</li> <li>Examples</li> <li>Best Practices</li> </ul>"},{"location":"reference/logging/#quick-start","title":"Quick Start","text":"<p>Configure SmartMessage logging through the global configuration block:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT              # Output destination\n  config.log_level = :info           # Log level\n  config.log_format = :text          # Format\n  config.log_colorize = true         # Enable colors\nend\n\n# Access the logger in your application\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"Application started\", component: \"main\")\n</code></pre>"},{"location":"reference/logging/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/logging/#global-configuration","title":"Global Configuration","text":"<p>All logging configuration is done through the <code>SmartMessage.configure</code> block:</p> <pre><code>SmartMessage.configure do |config|\n  # Required: Output destination\n  config.logger = STDOUT                    # or file path, STDERR\n\n  # Optional: Logging behavior\n  config.log_level = :info                 # :debug, :info, :warn, :error, :fatal\n  config.log_format = :text                # :text, :json\n  config.log_colorize = true               # Enable colorized console output\n  config.log_include_source = false        # Include file/line information\n  config.log_structured_data = false       # Enable structured metadata\n\n  # Optional: File rolling options\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 10 * 1024 * 1024,       # 10 MB\n    keep_files: 5,                          # Keep 5 old files\n    roll_by_date: false,                    # Alternative: date-based rolling\n    date_pattern: '%Y-%m-%d'                # Daily pattern\n  }\nend\n</code></pre>"},{"location":"reference/logging/#configuration-details","title":"Configuration Details","text":"Option Type Default Description <code>logger</code> String/IO Required Output destination (file path, STDOUT, STDERR) <code>log_level</code> Symbol <code>:info</code> Log level (<code>:debug</code>, <code>:info</code>, <code>:warn</code>, <code>:error</code>, <code>:fatal</code>) <code>log_format</code> Symbol <code>:text</code> Output format (<code>:text</code>, <code>:json</code>) <code>log_colorize</code> Boolean <code>false</code> Enable colorized console output <code>log_include_source</code> Boolean <code>false</code> Include source file and line information <code>log_structured_data</code> Boolean <code>false</code> Enable structured data logging <code>log_options</code> Hash <code>{}</code> Additional Lumberjack options"},{"location":"reference/logging/#output-formats","title":"Output Formats","text":""},{"location":"reference/logging/#text-format-default","title":"Text Format (Default)","text":"<p>Human-readable text output with optional colorization:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_format = :text\n  config.log_colorize = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"User login successful\", user_id: 12345)\n# Output: 2025-01-15 10:30:45 [INFO] User login successful user_id=12345\n</code></pre>"},{"location":"reference/logging/#json-format","title":"JSON Format","text":"<p>Machine-readable structured JSON output:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_format = :json\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"User action\", user_id: 12345, action: \"login\")\n# Output: {\"timestamp\":\"2025-01-15T10:30:45.123Z\",\"level\":\"INFO\",\"message\":\"User action\",\"user_id\":12345,\"action\":\"login\",\"source\":\"app.rb:42:in `authenticate`\"}\n</code></pre>"},{"location":"reference/logging/#colorized-console-output","title":"Colorized Console Output","text":"<p>SmartMessage provides colorized console output for improved readability during development:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_format = :text\n  config.log_colorize = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.debug(\"Debug message\")    # Green background, black text, bold\nlogger.info(\"Info message\")      # Bright white text\nlogger.warn(\"Warning message\")   # Yellow background, white bold text\nlogger.error(\"Error message\")    # Light red background, white bold text\nlogger.fatal(\"Fatal message\")    # Light red background, yellow bold text\n</code></pre>"},{"location":"reference/logging/#color-scheme","title":"Color Scheme","text":"Level Foreground Background Style DEBUG Black Green Bold INFO Bright White None None WARN White Yellow Bold ERROR White Light Red Bold FATAL Yellow Light Red Bold <p>Note: Colorization is automatically disabled for file output to keep log files clean.</p>"},{"location":"reference/logging/#file-rolling","title":"File Rolling","text":"<p>SmartMessage supports both size-based and date-based log file rolling:</p>"},{"location":"reference/logging/#size-based-rolling","title":"Size-Based Rolling","text":"<pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 10 * 1024 * 1024,  # 10 MB\n    keep_files: 5                      # Keep 5 old files\n  }\nend\n</code></pre> <p>Files are named: <code>application.log</code>, <code>application.log.1</code>, <code>application.log.2</code>, etc.</p>"},{"location":"reference/logging/#date-based-rolling","title":"Date-Based Rolling","text":"<pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_options = {\n    roll_by_date: true,\n    date_pattern: '%Y-%m-%d'  # Daily rolling\n  }\nend\n</code></pre> <p>Files are named: <code>application.log.2025-01-15</code>, <code>application.log.2025-01-14</code>, etc.</p>"},{"location":"reference/logging/#rolling-options","title":"Rolling Options","text":"Option Type Description <code>roll_by_size</code> Boolean Enable size-based rolling <code>max_file_size</code> Integer Maximum file size in bytes <code>keep_files</code> Integer Number of old files to keep <code>roll_by_date</code> Boolean Enable date-based rolling <code>date_pattern</code> String Date format pattern"},{"location":"reference/logging/#structured-logging","title":"Structured Logging","text":"<p>Enable structured data logging to include metadata with your log entries:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_format = :json\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n\nlogger = SmartMessage.configuration.default_logger\n\n# Log with structured data\nlogger.info(\"User registration\", \n            user_id: \"user123\",\n            email: \"user@example.com\",\n            registration_source: \"web\",\n            timestamp: Time.now.iso8601)\n\n# Log with block for conditional data\nlogger.warn(\"Database slow query\") do\n  {\n    query: \"SELECT * FROM users WHERE status = ?\",\n    duration_ms: 1500,\n    table: \"users\",\n    slow_query: true\n  }\nend\n</code></pre>"},{"location":"reference/logging/#application-integration","title":"Application Integration","text":""},{"location":"reference/logging/#accessing-the-logger","title":"Accessing the Logger","text":"<p>The configured logger is available globally:</p> <pre><code># Get the globally configured logger\nlogger = SmartMessage.configuration.default_logger\n\n# Use in your application\nlogger.info(\"Application starting\", version: \"1.0.0\")\nlogger.warn(\"Configuration missing\", config_key: \"database_url\")\nlogger.error(\"Service unavailable\", service: \"payment_gateway\")\n</code></pre>"},{"location":"reference/logging/#class-level-integration","title":"Class-Level Integration","text":"<pre><code>class OrderService\n  def initialize\n    @logger = SmartMessage.configuration.default_logger\n  end\n\n  def process_order(order)\n    @logger.info(\"Processing order\", \n                 order_id: order.id,\n                 customer_id: order.customer_id,\n                 amount: order.amount)\n\n    begin\n      # Process order logic\n      result = perform_processing(order)\n\n      @logger.info(\"Order completed\", \n                   order_id: order.id,\n                   status: \"success\",\n                   processing_time_ms: result[:duration])\n\n    rescue StandardError =&gt; e\n      @logger.error(\"Order processing failed\",\n                    order_id: order.id,\n                    error: e.message,\n                    error_class: e.class.name)\n      raise\n    end\n  end\nend\n</code></pre>"},{"location":"reference/logging/#smartmessage-integration","title":"SmartMessage Integration","text":"<p>SmartMessage classes automatically use the configured logger:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_id, required: true\n  property :amount, required: true\n\n  config do\n    transport SmartMessage::Transport::StdoutTransport.new\n    serializer SmartMessage::Serializer::Json.new\n    from 'order-service'\n  end\n\n  def process\n    # Logger is automatically available\n    logger.info(\"Processing order message\",\n                message_id: _sm_header.uuid,\n                order_id: order_id,\n                customer_id: customer_id,\n                amount: amount)\n\n    # Log the complete message structure\n    logger.debug(\"Message details\",\n                 header: _sm_header.to_h,\n                 payload: _sm_payload,\n                 full_message: to_h)\n\n    # Process the order\n    case amount\n    when 0..100\n      logger.info(\"Small order processed\", order_id: order_id)\n    when 101..1000\n      logger.warn(\"Medium order requires review\", order_id: order_id)\n    else\n      logger.error(\"Large order requires manual approval\", \n                   order_id: order_id, \n                   amount: amount)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/logging/#examples","title":"Examples","text":""},{"location":"reference/logging/#development-configuration","title":"Development Configuration","text":"<p>Perfect for local development with colorized console output:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_level = :debug\n  config.log_format = :text\n  config.log_colorize = true\n  config.log_include_source = true\nend\n</code></pre>"},{"location":"reference/logging/#production-configuration","title":"Production Configuration","text":"<p>Production setup with JSON logging and file rolling:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"/var/log/app/smartmessage.log\"\n  config.log_level = :info\n  config.log_format = :json\n  config.log_colorize = false\n  config.log_structured_data = true\n  config.log_include_source = false\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 50 * 1024 * 1024,  # 50 MB\n    keep_files: 10\n  }\nend\n</code></pre>"},{"location":"reference/logging/#dockercontainer-configuration","title":"Docker/Container Configuration","text":"<p>Container-friendly setup with structured STDOUT logging:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_level = ENV['LOG_LEVEL']&amp;.downcase&amp;.to_sym || :info\n  config.log_format = :json\n  config.log_colorize = false\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n</code></pre>"},{"location":"reference/logging/#testing-configuration","title":"Testing Configuration","text":"<p>Minimal logging for test environments:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDERR\n  config.log_level = :error\n  config.log_format = :text\n  config.log_colorize = false\nend\n</code></pre>"},{"location":"reference/logging/#multiple-logger-configurations","title":"Multiple Logger Configurations","text":"<p>You can create multiple logger instances for different purposes:</p> <pre><code># Configure global logger\nSmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_level = :info\n  config.log_format = :json\nend\n\n# Create additional loggers for specific needs\nconsole_logger = SmartMessage::Logger::Lumberjack.new(\n  log_file: STDERR,\n  level: :warn,\n  format: :text,\n  colorize: true\n)\n\ndebug_logger = SmartMessage::Logger::Lumberjack.new(\n  log_file: \"log/debug.log\",\n  level: :debug,\n  format: :text,\n  include_source: true\n)\n\n# Use in application\nconsole_logger.warn(\"Service degraded\")\ndebug_logger.debug(\"Detailed debugging info\", state: app_state)\n</code></pre>"},{"location":"reference/logging/#best-practices","title":"Best Practices","text":""},{"location":"reference/logging/#1-environment-based-configuration","title":"1. Environment-Based Configuration","text":"<p>Configure logging based on your environment:</p> <pre><code>case ENV['RAILS_ENV'] || ENV['ENVIRONMENT']\nwhen 'production'\n  SmartMessage.configure do |config|\n    config.logger = \"/var/log/app/smartmessage.log\"\n    config.log_level = :info\n    config.log_format = :json\n    config.log_structured_data = true\n    config.log_options = { roll_by_size: true, max_file_size: 50.megabytes, keep_files: 10 }\n  end\nwhen 'development'\n  SmartMessage.configure do |config|\n    config.logger = STDOUT\n    config.log_level = :debug\n    config.log_format = :text\n    config.log_colorize = true\n    config.log_include_source = true\n  end\nwhen 'test'\n  SmartMessage.configure do |config|\n    config.logger = STDERR\n    config.log_level = :error\n    config.log_format = :text\n  end\nend\n</code></pre>"},{"location":"reference/logging/#2-structured-data","title":"2. Structured Data","text":"<p>Use structured data for better log analysis:</p> <pre><code># Good: Structured data\nlogger.info(\"User action\", \n            user_id: user.id, \n            action: \"login\", \n            ip_address: request.ip,\n            user_agent: request.user_agent)\n\n# Avoid: String interpolation\nlogger.info(\"User #{user.id} logged in from #{request.ip}\")\n</code></pre>"},{"location":"reference/logging/#3-appropriate-log-levels","title":"3. Appropriate Log Levels","text":"<p>Use log levels appropriately:</p> <ul> <li>DEBUG: Detailed information for diagnosing problems</li> <li>INFO: General information about program execution</li> <li>WARN: Something unexpected happened, but the application is still working</li> <li>ERROR: A serious problem occurred, but the application can continue</li> <li>FATAL: A very serious error occurred, application may not be able to continue</li> </ul>"},{"location":"reference/logging/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Use appropriate log levels in production (avoid DEBUG)</li> <li>Consider async logging for high-volume applications</li> <li>Use structured data instead of string concatenation</li> <li>Be mindful of log volume and storage costs</li> </ul>"},{"location":"reference/logging/#5-security","title":"5. Security","text":"<ul> <li>Never log sensitive data (passwords, tokens, credit card numbers)</li> <li>Sanitize user input before logging</li> <li>Use structured data to avoid log injection attacks</li> </ul> <pre><code># Good: Structured data prevents injection\nlogger.info(\"User input received\", user_input: params[:query])\n\n# Avoid: Direct string interpolation\nlogger.info(\"User searched for: #{params[:query]}\")\n</code></pre>"},{"location":"reference/logging/#6-testing","title":"6. Testing","text":"<p>Test your logging configuration:</p> <pre><code># Test that logs are being generated\nrequire 'stringio'\n\nlog_output = StringIO.new\nSmartMessage.configure do |config|\n  config.logger = log_output\n  config.log_level = :debug\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"Test message\")\n\nassert_includes log_output.string, \"Test message\"\n</code></pre> <p>For more information, see the comprehensive logging examples at <code>examples/memory/15_logger_demo.rb</code> and <code>examples/memory/08_custom_logger_demo.rb</code>.</p>"},{"location":"reference/message-deduplication/","title":"Message Deduplication","text":"<p>SmartMessage provides a comprehensive message deduplication system using Deduplication Queues (DDQ) to prevent duplicate processing of messages with the same UUID. The system is designed with handler-scoped isolation, ensuring that different message handlers maintain independent deduplication state.</p>"},{"location":"reference/message-deduplication/#overview","title":"Overview","text":"<p>Message deduplication in SmartMessage works by:</p> <ol> <li>Handler-Scoped Tracking: Each message handler (subscription) gets its own DDQ instance</li> <li>UUID-Based Detection: Message UUIDs are tracked in circular buffers for O(1) lookup performance</li> <li>Configurable Storage: Support for both memory-based and Redis-based storage backends</li> <li>Automatic Integration: Seamlessly integrates with the existing dispatcher and subscription system</li> </ol>"},{"location":"reference/message-deduplication/#architecture","title":"Architecture","text":""},{"location":"reference/message-deduplication/#handler-only-scoping","title":"Handler-Only Scoping","text":"<p>The key innovation in SmartMessage's deduplication system is handler-only scoping. DDQ keys are automatically derived from the combination of message class and handler method:</p> <pre><code>DDQ Key Format: \"MessageClass:HandlerMethod\"\n</code></pre> <p>Examples: - <code>\"OrderMessage:PaymentService.process\"</code> - <code>\"OrderMessage:FulfillmentService.handle\"</code> - <code>\"InvoiceMessage:PaymentService.process\"</code></p> <p>This design provides: - Natural Isolation: Each handler has its own deduplication context - Cross-Process Support: Same handler across different processes gets isolated DDQs - No Parameter Pollution: No need for explicit subscriber identification in the API</p>"},{"location":"reference/message-deduplication/#ddq-data-structure","title":"DDQ Data Structure","text":"<p>Each DDQ uses a hybrid data structure for optimal performance:</p> <pre><code># Hybrid Array + Set Design\n@circular_array = Array.new(size)  # Maintains insertion order for eviction\n@lookup_set = Set.new              # Provides O(1) UUID lookup\n@index = 0                         # Current insertion position\n</code></pre> <p>Benefits: - O(1) Lookup: Set provides constant-time duplicate detection - O(1) Insertion: Array provides constant-time insertion and eviction - Memory Bounded: Circular buffer automatically evicts oldest entries - Thread Safe: Mutex protection for concurrent access</p>"},{"location":"reference/message-deduplication/#configuration","title":"Configuration","text":""},{"location":"reference/message-deduplication/#basic-setup","title":"Basic Setup","text":"<p>Enable deduplication for a message class:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  version 1\n  property :order_id, required: true\n  property :amount, required: true\n\n  # Configure deduplication\n  ddq_size 100              # Track last 100 UUIDs (default: 100)\n  ddq_storage :memory       # Storage backend (default: :memory)\n  enable_deduplication!     # Enable DDQ for this message class\n\n  def self.process(message)\n    puts \"Processing order: #{message.order_id}\"\n  end\nend\n</code></pre>"},{"location":"reference/message-deduplication/#storage-backends","title":"Storage Backends","text":""},{"location":"reference/message-deduplication/#memory-storage","title":"Memory Storage","text":"<p>Best for single-process applications:</p> <pre><code>class LocalMessage &lt; SmartMessage::Base\n  ddq_size 50\n  ddq_storage :memory\n  enable_deduplication!\nend\n</code></pre> <p>Memory Usage (approximate): - 10 UUIDs: ~480 bytes - 100 UUIDs: ~4.8 KB - 1000 UUIDs: ~48 KB</p>"},{"location":"reference/message-deduplication/#redis-storage","title":"Redis Storage","text":"<p>Best for distributed/multi-process applications:</p> <pre><code>class DistributedMessage &lt; SmartMessage::Base\n  ddq_size 1000\n  ddq_storage :redis, \n    redis_url: 'redis://localhost:6379',\n    redis_db: 1,\n    key_prefix: 'ddq'\n  enable_deduplication!\nend\n</code></pre> <p>Redis DDQ features: - Distributed State: Shared across multiple processes - Persistence: Survives process restarts - TTL Support: Automatic expiration of old entries - Atomic Operations: Transaction safety for concurrent access</p>"},{"location":"reference/message-deduplication/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>ddq_size</code> Integer 100 Maximum UUIDs to track in circular buffer <code>ddq_storage</code> Symbol <code>:memory</code> Storage backend (<code>:memory</code> or <code>:redis</code>) <code>redis_url</code> String <code>'redis://localhost:6379'</code> Redis connection URL <code>redis_db</code> Integer 0 Redis database number <code>key_prefix</code> String <code>'ddq'</code> Prefix for Redis keys <code>ttl</code> Integer 3600 TTL for Redis entries (seconds)"},{"location":"reference/message-deduplication/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/message-deduplication/#multiple-handlers-per-message-class","title":"Multiple Handlers per Message Class","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  ddq_size 200\n  ddq_storage :memory\n  enable_deduplication!\nend\n\n# Each gets separate DDQ tracking\nOrderMessage.subscribe('PaymentService.process')      # DDQ: \"OrderMessage:PaymentService.process\"\nOrderMessage.subscribe('FulfillmentService.handle')   # DDQ: \"OrderMessage:FulfillmentService.handle\"\nOrderMessage.subscribe('AuditService.log_order')      # DDQ: \"OrderMessage:AuditService.log_order\"\n\n# Same UUID can be processed by each handler independently\norder = OrderMessage.new(order_id: \"12345\", amount: 99.99)\norder.publish  # All three handlers will process this message\n</code></pre>"},{"location":"reference/message-deduplication/#cross-message-class-handlers","title":"Cross-Message-Class Handlers","text":"<pre><code>class PaymentService\n  def self.process(message)\n    puts \"PaymentService processing: #{message.class.name}\"\n  end\nend\n\n# Same handler, different message classes = separate DDQs\nOrderMessage.subscribe('PaymentService.process')     # DDQ: \"OrderMessage:PaymentService.process\"\nInvoiceMessage.subscribe('PaymentService.process')   # DDQ: \"InvoiceMessage:PaymentService.process\"\nRefundMessage.subscribe('PaymentService.process')    # DDQ: \"RefundMessage:PaymentService.process\"\n</code></pre>"},{"location":"reference/message-deduplication/#distributed-processing","title":"Distributed Processing","text":"<pre><code># Process A (payment-service-1)\nclass OrderMessage &lt; SmartMessage::Base\n  ddq_storage :redis, redis_url: 'redis://shared-redis:6379'\n  enable_deduplication!\nend\n\nOrderMessage.subscribe('PaymentService.process')\n\n# Process B (payment-service-2)  \n# Same configuration, same handler = shared DDQ in Redis\nOrderMessage.subscribe('PaymentService.process')\n\n# Only one process will handle each unique UUID\n</code></pre>"},{"location":"reference/message-deduplication/#api-reference","title":"API Reference","text":""},{"location":"reference/message-deduplication/#class-methods","title":"Class Methods","text":""},{"location":"reference/message-deduplication/#ddq_sizesize","title":"<code>ddq_size(size)</code>","text":"<p>Configure the maximum number of UUIDs to track: <pre><code>OrderMessage.ddq_size(500)  # Track last 500 UUIDs\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_storagestorage-options","title":"<code>ddq_storage(storage, **options)</code>","text":"<p>Configure the storage backend: <pre><code>OrderMessage.ddq_storage(:memory)\nOrderMessage.ddq_storage(:redis, redis_url: 'redis://localhost:6379', redis_db: 2)\n</code></pre></p>"},{"location":"reference/message-deduplication/#enable_deduplication","title":"<code>enable_deduplication!</code>","text":"<p>Enable deduplication for the message class: <pre><code>OrderMessage.enable_deduplication!\n</code></pre></p>"},{"location":"reference/message-deduplication/#disable_deduplication","title":"<code>disable_deduplication!</code>","text":"<p>Disable deduplication for the message class: <pre><code>OrderMessage.disable_deduplication!\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_enabled","title":"<code>ddq_enabled?</code>","text":"<p>Check if deduplication is enabled: <pre><code>puts OrderMessage.ddq_enabled?  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_config","title":"<code>ddq_config</code>","text":"<p>Get current DDQ configuration: <pre><code>config = OrderMessage.ddq_config\n# =&gt; {enabled: true, size: 100, storage: :memory, options: {}}\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_stats","title":"<code>ddq_stats</code>","text":"<p>Get DDQ statistics for all handlers: <pre><code>stats = OrderMessage.ddq_stats\n# =&gt; {enabled: true, current_count: 45, utilization: 45.0, ...}\n</code></pre></p>"},{"location":"reference/message-deduplication/#clear_ddq","title":"<code>clear_ddq!</code>","text":"<p>Clear all DDQ instances for the message class: <pre><code>OrderMessage.clear_ddq!\n</code></pre></p>"},{"location":"reference/message-deduplication/#duplicate_uuiduuid","title":"<code>duplicate_uuid?(uuid)</code>","text":"<p>Check if a UUID is tracked as duplicate: <pre><code>is_dup = OrderMessage.duplicate_uuid?(\"some-uuid-123\")  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#instance-methods","title":"Instance Methods","text":""},{"location":"reference/message-deduplication/#duplicate","title":"<code>duplicate?</code>","text":"<p>Check if this message instance is a duplicate: <pre><code>message = OrderMessage.new(order_id: \"123\", amount: 99.99)\nputs message.duplicate?  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#mark_as_processed","title":"<code>mark_as_processed!</code>","text":"<p>Manually mark this message as processed: <pre><code>message.mark_as_processed!  # Adds UUID to DDQ\n</code></pre></p>"},{"location":"reference/message-deduplication/#integration-with-dispatcher","title":"Integration with Dispatcher","text":"<p>The deduplication system integrates seamlessly with SmartMessage's dispatcher:</p>"},{"location":"reference/message-deduplication/#message-flow-with-ddq","title":"Message Flow with DDQ","text":"<ol> <li>Message Receipt: Dispatcher receives decoded message</li> <li>Handler Iteration: For each subscribed handler:</li> <li>DDQ Check: Check handler's DDQ for message UUID</li> <li>Skip Duplicates: If UUID found, log and skip to next handler</li> <li>Process New: If UUID not found, route to handler</li> <li>Mark Processed: After successful processing, add UUID to handler's DDQ</li> </ol>"},{"location":"reference/message-deduplication/#logging","title":"Logging","text":"<p>The dispatcher provides detailed logging for deduplication events:</p> <pre><code>[INFO] [SmartMessage::Dispatcher] Skipping duplicate for PaymentService.process: uuid-123\n[DEBUG] [SmartMessage::Dispatcher] Marked UUID as processed for FulfillmentService.handle: uuid-456\n</code></pre>"},{"location":"reference/message-deduplication/#statistics-integration","title":"Statistics Integration","text":"<p>DDQ statistics are integrated with SmartMessage's built-in statistics system:</p> <pre><code># Access via dispatcher\ndispatcher = SmartMessage::Dispatcher.new\nddq_stats = dispatcher.ddq_stats\n\n# Example output:\n# {\n#   \"OrderMessage:PaymentService.process\" =&gt; {\n#     size: 100, current_count: 23, utilization: 23.0, \n#     storage_type: :memory, implementation: \"SmartMessage::DDQ::Memory\"\n#   },\n#   \"OrderMessage:FulfillmentService.handle\" =&gt; { ... }\n# }\n</code></pre>"},{"location":"reference/message-deduplication/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"reference/message-deduplication/#memory-ddq-performance","title":"Memory DDQ Performance","text":"<ul> <li>Lookup Time: O(1) - Set provides constant-time contains check</li> <li>Insertion Time: O(1) - Array provides constant-time insertion</li> <li>Memory Usage: ~48 bytes per UUID (including Set and Array overhead)</li> <li>Thread Safety: Mutex-protected for concurrent access</li> </ul>"},{"location":"reference/message-deduplication/#redis-ddq-performance","title":"Redis DDQ Performance","text":"<ul> <li>Lookup Time: O(1) - Redis SET provides constant-time membership test</li> <li>Insertion Time: O(1) - Redis LPUSH + LTRIM for circular behavior</li> <li>Network Overhead: 1-2 Redis commands per duplicate check</li> <li>Persistence: Automatic persistence and cross-process sharing</li> </ul>"},{"location":"reference/message-deduplication/#benchmarks","title":"Benchmarks","text":"<p>Memory DDQ (1000 entries): - Memory Usage: ~57 KB - Lookup Performance: 0.001ms average - Insertion Performance: 0.002ms average</p> <p>Redis DDQ (1000 entries): - Memory Usage: Stored in Redis - Lookup Performance: 0.5-2ms average (network dependent) - Insertion Performance: 1-3ms average (network dependent)</p>"},{"location":"reference/message-deduplication/#best-practices","title":"Best Practices","text":""},{"location":"reference/message-deduplication/#1-choose-appropriate-ddq-size","title":"1. Choose Appropriate DDQ Size","text":"<p>Size DDQ based on your message volume and acceptable duplicate window:</p> <pre><code># High-volume service: larger DDQ\nclass HighVolumeMessage &lt; SmartMessage::Base\n  ddq_size 10000  # Track last 10k messages\n  ddq_storage :redis\n  enable_deduplication!\nend\n\n# Low-volume service: smaller DDQ\nclass LowVolumeMessage &lt; SmartMessage::Base\n  ddq_size 50     # Track last 50 messages  \n  ddq_storage :memory\n  enable_deduplication!\nend\n</code></pre>"},{"location":"reference/message-deduplication/#2-use-redis-for-distributed-systems","title":"2. Use Redis for Distributed Systems","text":"<p>For multi-process deployments, always use Redis storage:</p> <pre><code>class DistributedMessage &lt; SmartMessage::Base\n  ddq_storage :redis, \n    redis_url: ENV.fetch('REDIS_URL', 'redis://localhost:6379'),\n    redis_db: ENV.fetch('DDQ_REDIS_DB', 1).to_i\n  enable_deduplication!\nend\n</code></pre>"},{"location":"reference/message-deduplication/#3-monitor-ddq-statistics","title":"3. Monitor DDQ Statistics","text":"<p>Regularly monitor DDQ utilization:</p> <pre><code># In monitoring/health check code\nstats = OrderMessage.ddq_stats\nif stats[:utilization] &gt; 90\n  logger.warn \"DDQ utilization high: #{stats[:utilization]}%\"\nend\n</code></pre>"},{"location":"reference/message-deduplication/#4-handle-ddq-errors-gracefully","title":"4. Handle DDQ Errors Gracefully","text":"<p>The system is designed to fail-open (process messages when DDQ fails):</p> <pre><code># DDQ failures are logged but don't prevent message processing\n# Monitor logs for DDQ-related errors:\n# [ERROR] [SmartMessage::DDQ] Failed to check duplicate: Redis connection error\n</code></pre>"},{"location":"reference/message-deduplication/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/message-deduplication/#common-issues","title":"Common Issues","text":""},{"location":"reference/message-deduplication/#1-messages-not-being-deduplicated","title":"1. Messages Not Being Deduplicated","text":"<p>Symptoms: Same UUID processed multiple times by same handler Causes: - Deduplication not enabled: <code>enable_deduplication!</code> missing - Different handlers: Each handler has separate DDQ - DDQ size too small: Old UUIDs evicted too quickly</p> <p>Solutions: <pre><code># Verify deduplication is enabled\nputs OrderMessage.ddq_enabled?  # Should be true\n\n# Check DDQ configuration\nputs OrderMessage.ddq_config\n\n# Increase DDQ size if needed\nOrderMessage.ddq_size(1000)\n</code></pre></p>"},{"location":"reference/message-deduplication/#2-redis-connection-errors","title":"2. Redis Connection Errors","text":"<p>Symptoms: DDQ errors in logs, messages still processing Causes: Redis connectivity issues</p> <p>Solutions: <pre><code># Verify Redis connection\nredis_config = OrderMessage.ddq_config[:options]\nputs \"Redis URL: #{redis_config[:redis_url]}\"\n\n# Test Redis connectivity\nrequire 'redis'\nredis = Redis.new(url: redis_config[:redis_url])\nputs redis.ping  # Should return \"PONG\"\n</code></pre></p>"},{"location":"reference/message-deduplication/#3-high-memory-usage","title":"3. High Memory Usage","text":"<p>Symptoms: Increasing memory usage in memory DDQ Causes: DDQ size too large for available memory</p> <p>Solutions: <pre><code># Check memory usage\nstats = OrderMessage.ddq_stats\nputs \"Memory usage: #{stats[:current_count] * 48} bytes\"\n\n# Reduce DDQ size\nOrderMessage.ddq_size(100)  # Smaller size\n\n# Or switch to Redis\nOrderMessage.ddq_storage(:redis)\n</code></pre></p>"},{"location":"reference/message-deduplication/#debugging-ddq-issues","title":"Debugging DDQ Issues","text":"<pre><code># Enable debug logging\nSmartMessage.configure do |config|\n  config.log_level = :debug\nend\n\n# Check specific UUID\nuuid = \"test-uuid-123\" \nputs \"Is duplicate: #{OrderMessage.duplicate_uuid?(uuid)}\"\n\n# Clear DDQ for testing\nOrderMessage.clear_ddq!\n\n# Monitor DDQ stats\nstats = OrderMessage.ddq_stats\nputs \"Current count: #{stats[:current_count]}\"\nputs \"Utilization: #{stats[:utilization]}%\"\n</code></pre>"},{"location":"reference/message-deduplication/#migration-guide","title":"Migration Guide","text":""},{"location":"reference/message-deduplication/#from-class-level-to-handler-level-ddq","title":"From Class-Level to Handler-Level DDQ","text":"<p>If upgrading from a previous version with class-level deduplication:</p> <p>Before (hypothetical): <pre><code># All handlers shared one DDQ per message class\nOrderMessage.subscribe('PaymentService.process')\nOrderMessage.subscribe('FulfillmentService.handle')\n# Both shared the same DDQ\n</code></pre></p> <p>After (current): <pre><code># Each handler gets its own DDQ automatically\nOrderMessage.subscribe('PaymentService.process')     # DDQ: \"OrderMessage:PaymentService.process\"\nOrderMessage.subscribe('FulfillmentService.handle')  # DDQ: \"OrderMessage:FulfillmentService.handle\"\n# Separate DDQs with isolated tracking\n</code></pre></p> <p>Benefits of Migration: - Better Isolation: Handler failures don't affect other handlers' deduplication - Flexible Filtering: Different handlers can have different subscription filters - Cross-Process Safety: Handlers with same name across processes get separate DDQs</p> <p>The migration is automatic - no code changes required. The new system provides better isolation and reliability.</p>"},{"location":"reference/proc-handlers/","title":"SmartMessage Proc and Block Handlers - Implementation Summary","text":""},{"location":"reference/proc-handlers/#overview","title":"Overview","text":"<p>This document summarizes the enhanced subscription functionality added to SmartMessage, which extends the framework to support multiple message handler patterns including blocks, procs, and lambdas alongside the existing default and method handlers.</p>"},{"location":"reference/proc-handlers/#new-features-added","title":"New Features Added","text":""},{"location":"reference/proc-handlers/#1-enhanced-subscribe-method","title":"1. Enhanced <code>subscribe</code> Method","text":"<p>The <code>subscribe</code> method in <code>SmartMessage::Base</code> now supports multiple parameter types:</p> <pre><code># Original functionality (still works)\nMyMessage.subscribe                           # Default: \"MyMessage.process\"\nMyMessage.subscribe(\"Service.handle_message\") # Method handler\n\n# NEW functionality\nMyMessage.subscribe do |header, payload|     # Block handler\n  # Inline processing logic\nend\n\nMyMessage.subscribe(proc { |h,p| ... })      # Proc handler\nMyMessage.subscribe(lambda { |h,p| ... })    # Lambda handler\n</code></pre>"},{"location":"reference/proc-handlers/#2-proc-registry-system","title":"2. Proc Registry System","text":"<ul> <li>Storage: <code>@@proc_handlers</code> class variable stores all proc-based handlers</li> <li>Unique IDs: Each proc handler gets a unique identifier like <code>\"MessageClass.proc_abc123\"</code></li> <li>Cleanup: Automatic cleanup when unsubscribing proc handlers</li> <li>Registry Management: Helper methods for registration, lookup, and cleanup</li> </ul>"},{"location":"reference/proc-handlers/#3-enhanced-dispatcher-routing","title":"3. Enhanced Dispatcher Routing","text":"<p>The dispatcher (<code>lib/smart_message/dispatcher.rb</code>) now handles multiple handler types:</p> <pre><code>def route(message_header, message_payload)\n  @subscribers[message_klass].each do |message_processor|\n    @router_pool.post do\n      if proc_handler?(message_processor)\n        # Route to proc handler\n        SmartMessage::Base.call_proc_handler(message_processor, message_header, message_payload)\n      else\n        # Route to method handler (original logic)\n        target_klass.constantize.method(class_method).call(message_header, message_payload)\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"reference/proc-handlers/#implementation-details","title":"Implementation Details","text":""},{"location":"reference/proc-handlers/#core-files-modified","title":"Core Files Modified","text":"<ol> <li><code>lib/smart_message/base.rb</code>:</li> <li>Enhanced <code>subscribe</code> method with block and proc support</li> <li>Added proc registry management (<code>@@proc_handlers</code>)</li> <li>Added helper methods: <code>register_proc_handler</code>, <code>call_proc_handler</code>, <code>unregister_proc_handler</code>, <code>proc_handler?</code></li> <li> <p>Updated <code>unsubscribe</code> method to clean up proc handlers</p> </li> <li> <p><code>lib/smart_message/dispatcher.rb</code>:</p> </li> <li>Updated <code>route</code> method to handle both method and proc handlers</li> <li>Added <code>proc_handler?</code> check for routing decisions</li> <li>Maintained thread safety and error handling</li> </ol>"},{"location":"reference/proc-handlers/#handler-type-identification","title":"Handler Type Identification","text":"<ul> <li>Method handlers: String format <code>\"ClassName.method_name\"</code></li> <li>Proc handlers: String format <code>\"ClassName.proc_[hex_id]\"</code> stored in <code>@@proc_handlers</code> registry</li> <li>Default handlers: String format <code>\"ClassName.process\"</code></li> </ul>"},{"location":"reference/proc-handlers/#return-values","title":"Return Values","text":"<p>All subscription methods return identifiers for unsubscription:</p> <pre><code>default_id = MyMessage.subscribe                    # \"MyMessage.process\"\nmethod_id = MyMessage.subscribe(\"Service.handle\")   # \"Service.handle\"\nblock_id = MyMessage.subscribe { |h,p| }            # \"MyMessage.proc_abc123\"\nproc_id = MyMessage.subscribe(my_proc)              # \"MyMessage.proc_def456\"\n\n# All can be unsubscribed using the returned ID\nMyMessage.unsubscribe(block_id)\n</code></pre>"},{"location":"reference/proc-handlers/#testing-coverage","title":"Testing Coverage","text":""},{"location":"reference/proc-handlers/#unit-tests-testproc_handler_testrb","title":"Unit Tests (<code>test/proc_handler_test.rb</code>)","text":"<ul> <li>Default handler compatibility</li> <li>Block handler functionality</li> <li>Proc parameter handler functionality</li> <li>Lambda handler functionality</li> <li>Multiple handlers for same message type</li> <li>Mixed handler types (method + proc)</li> <li>Handler unsubscription and cleanup</li> <li>Error handling in proc handlers</li> <li>Complex logic processing</li> <li>Return value handling</li> </ul>"},{"location":"reference/proc-handlers/#integration-tests-testproc_handler_integration_testrb","title":"Integration Tests (<code>test/proc_handler_integration_test.rb</code>)","text":"<ul> <li>End-to-end testing with real transports (Memory, Stdout)</li> <li>Multiple proc handlers with concurrent execution</li> <li>Error handling and graceful degradation</li> <li>Handler lifecycle management</li> <li>Mixed handler type integration</li> <li>Lambda vs proc behavior</li> <li>Concurrent execution verification</li> </ul>"},{"location":"reference/proc-handlers/#test-results","title":"Test Results","text":"<ul> <li>55 total tests (10 new proc handler tests + existing tests)</li> <li>276 assertions</li> <li>All tests passing</li> <li>Full backward compatibility maintained</li> </ul>"},{"location":"reference/proc-handlers/#documentation-updates","title":"Documentation Updates","text":""},{"location":"reference/proc-handlers/#1-main-readmemd","title":"1. Main README.md","text":"<ul> <li>Updated Quick Start section with new subscription examples</li> <li>Enhanced Features section</li> <li>Updated Message Lifecycle section</li> </ul>"},{"location":"reference/proc-handlers/#2-getting-started-guide-docsgetting-startedmd","title":"2. Getting Started Guide (<code>docs/getting-started.md</code>)","text":"<ul> <li>Added comprehensive handler types section</li> <li>Updated subscription examples</li> <li>Added guidance on when to use each handler type</li> </ul>"},{"location":"reference/proc-handlers/#3-architecture-documentation-docsarchitecturemd","title":"3. Architecture Documentation (<code>docs/architecture.md</code>)","text":"<ul> <li>Updated system architecture diagram</li> <li>Enhanced message processing section</li> <li>Added handler routing process details</li> </ul>"},{"location":"reference/proc-handlers/#4-dispatcher-documentation-docsdispatchermd","title":"4. Dispatcher Documentation (<code>docs/dispatcher.md</code>)","text":"<ul> <li>Updated subscription management section</li> <li>Enhanced message routing process</li> <li>Added handler type processing details</li> </ul>"},{"location":"reference/proc-handlers/#5-examples-documentation-examplesreadmemd","title":"5. Examples Documentation (<code>examples/README.md</code>)","text":"<ul> <li>Added new proc handler example description</li> <li>Updated examples overview</li> <li>Added handler pattern demonstrations</li> </ul>"},{"location":"reference/proc-handlers/#6-new-comprehensive-guide-docsmessage_processingmd","title":"6. New Comprehensive Guide (<code>docs/message_processing.md</code>)","text":"<ul> <li>Complete guide to all handler types</li> <li>Best practices and use cases</li> <li>Performance considerations</li> <li>Error handling patterns</li> </ul>"},{"location":"reference/proc-handlers/#examples","title":"Examples","text":""},{"location":"reference/proc-handlers/#1-new-working-example-examplesmemory07_proc_handlers_demorb","title":"1. New Working Example (<code>examples/memory/07_proc_handlers_demo.rb</code>)","text":"<p>Complete demonstration of all handler types: - Default handler (self.process) - Block handlers (inline logic) - Proc handlers (reusable logic) - Lambda handlers (functional style) - Method handlers (service classes) - Handler management and unsubscription</p>"},{"location":"reference/proc-handlers/#2-enhanced-iot-example-examplesredis01_smart_home_iot_demorb","title":"2. Enhanced IoT Example (<code>examples/redis/01_smart_home_iot_demo.rb</code>)","text":"<p>Production-ready Redis transport example showing real-world usage patterns.</p>"},{"location":"reference/proc-handlers/#benefits-delivered","title":"Benefits Delivered","text":""},{"location":"reference/proc-handlers/#1-flexibility","title":"1. Flexibility","text":"<ul> <li>Choose the right handler pattern for each use case</li> <li>Mix multiple handler types for the same message</li> <li>Easy migration path from simple to complex handlers</li> </ul>"},{"location":"reference/proc-handlers/#2-developer-experience","title":"2. Developer Experience","text":"<ul> <li>Intuitive block syntax for simple cases</li> <li>Reusable proc handlers for cross-cutting concerns</li> <li>Organized method handlers for complex business logic</li> <li>Clear return values for handler management</li> </ul>"},{"location":"reference/proc-handlers/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient proc registry with minimal overhead</li> <li>Thread-safe concurrent processing</li> <li>No impact on existing method handler performance</li> </ul>"},{"location":"reference/proc-handlers/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Clean separation between handler types</li> <li>Proper cleanup and memory management</li> <li>Comprehensive error handling</li> <li>Full backward compatibility</li> </ul>"},{"location":"reference/proc-handlers/#production-considerations","title":"Production Considerations","text":""},{"location":"reference/proc-handlers/#1-handler-selection-guidelines","title":"1. Handler Selection Guidelines","text":"<ul> <li>Default handlers: Simple built-in processing</li> <li>Block handlers: Quick inline logic, prototyping</li> <li>Proc handlers: Reusable cross-message functionality (auditing, logging)</li> <li>Method handlers: Complex business logic, organized service classes</li> </ul>"},{"location":"reference/proc-handlers/#2-memory-management","title":"2. Memory Management","text":"<ul> <li>Proc handlers are stored in class variables and persist until explicitly unsubscribed</li> <li>Use returned handler IDs for proper cleanup</li> <li>Consider memory usage with many long-lived proc handlers</li> </ul>"},{"location":"reference/proc-handlers/#3-performance_1","title":"3. Performance","text":"<ul> <li>Proc handlers have minimal overhead vs method handlers</li> <li>All handlers execute in parallel threads</li> <li>No impact on existing code performance</li> </ul>"},{"location":"reference/proc-handlers/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Proc handler errors are isolated and don't crash the dispatcher</li> <li>Same error handling patterns as method handlers</li> <li>Debug output available for troubleshooting</li> </ul>"},{"location":"reference/proc-handlers/#migration-path","title":"Migration Path","text":""},{"location":"reference/proc-handlers/#for-existing-code","title":"For Existing Code","text":"<ul> <li>No changes required - all existing code continues to work</li> <li>Gradual adoption - can introduce proc handlers incrementally</li> <li>Mixed usage - can use multiple handler types simultaneously</li> </ul>"},{"location":"reference/proc-handlers/#for-new-development","title":"For New Development","text":"<ul> <li>Start with defaults for simple cases</li> <li>Use blocks for quick inline processing</li> <li>Use procs for reusable functionality</li> <li>Use methods for complex business logic</li> </ul>"},{"location":"reference/proc-handlers/#future-enhancements","title":"Future Enhancements","text":"<p>Potential areas for future development:</p> <ul> <li>Handler priority/ordering</li> <li>Conditional handler execution</li> <li>Handler metrics and monitoring</li> <li>Dynamic handler registration/deregistration</li> <li>Handler middleware/interceptors</li> </ul>"},{"location":"reference/proc-handlers/#conclusion","title":"Conclusion","text":"<p>The enhanced subscription functionality provides SmartMessage users with powerful, flexible options for message processing while maintaining the simplicity and elegance of the original design. The implementation is production-ready, thoroughly tested, and fully documented.</p> <p>This enhancement positions SmartMessage as a more versatile and developer-friendly messaging framework suitable for both simple prototypes and complex enterprise applications.</p>"},{"location":"reference/serializers/","title":"Transport-Based Serialization","text":"<p>In SmartMessage's architecture, serialization is handled at the transport level rather than being configured for individual messages. Each transport manages its own optimal serialization format, eliminating the need for separate serializer configuration.</p>"},{"location":"reference/serializers/#overview","title":"Overview","text":"<p>Transport-based serialization provides: - Automatic Format Selection: Each transport chooses its optimal serialization format - Simplified Configuration: No need to configure serializers separately - Format Optimization: Transports can choose the best format for their medium - Consistent Behavior: All messages using a transport share the same serialization format</p>"},{"location":"reference/serializers/#transport-serialization-formats","title":"Transport Serialization Formats","text":""},{"location":"reference/serializers/#memory-transport","title":"Memory Transport","text":"<ul> <li>Format: No serialization (objects passed directly)</li> <li>Use case: Testing and development where no network transmission occurs</li> <li>Performance: Fastest possible (no encoding/decoding overhead)</li> </ul> <pre><code># Memory transport - no serialization needed\ntransport = SmartMessage::Transport::MemoryTransport.new\n</code></pre>"},{"location":"reference/serializers/#stdout-transport","title":"STDOUT Transport","text":"<ul> <li>Format: JSON (human-readable)</li> <li>Use case: Debugging, development logging, message inspection</li> <li>Features: Pretty-printed output for easy reading</li> </ul> <pre><code># STDOUT transport - uses JSON for readability\ntransport = SmartMessage::Transport::StdoutTransport.new(\n  format: :pretty  # or :json for compact format\n)\n</code></pre>"},{"location":"reference/serializers/#redis-transport","title":"Redis Transport","text":"<ul> <li>Format: MessagePack (primary), JSON (fallback)</li> <li>Use case: Production messaging where efficiency matters</li> <li>Benefits: Compact binary format reduces network overhead</li> </ul> <pre><code># Redis transport - automatically uses MessagePack if available\ntransport = SmartMessage::Transport::RedisTransport.new(\n  url: 'redis://localhost:6379'\n)\n</code></pre>"},{"location":"reference/serializers/#how-it-works","title":"How It Works","text":""},{"location":"reference/serializers/#transport-serialization-process","title":"Transport Serialization Process","text":"<ol> <li> <p>Message Publishing:     <pre><code>message = OrderMessage.new(order_id: \"123\", amount: 99.99)\nmessage.publish  # Transport handles serialization automatically\n</code></pre></p> </li> <li> <p>Automatic Encoding: Transport calls its serializer internally    <pre><code># Inside transport.publish(message):\nserialized = transport.serializer.encode(message.to_hash)\n</code></pre></p> </li> <li> <p>Message Receiving: Transport deserializes automatically    <pre><code># Inside transport.receive(serialized_data):\ndata = transport.serializer.decode(serialized_data)\nmessage = MessageClass.new(data)\n</code></pre></p> </li> </ol>"},{"location":"reference/serializers/#message-structure","title":"Message Structure","text":"<p>All messages are serialized as flat hashes with the <code>_sm_header</code> property containing routing metadata:</p> <pre><code>{\n  _sm_header: {\n    uuid: \"...\",\n    message_class: \"OrderMessage\", \n    published_at: \"2025-01-09T...\",\n    from: \"order-service\",\n    to: \"fulfillment-service\",\n    serializer: \"SmartMessage::Serializer::Json\"\n  },\n  order_id: \"123\",\n  amount: 99.99,\n  items: [\"Widget A\", \"Widget B\"]\n}\n</code></pre>"},{"location":"reference/serializers/#custom-transport-serializers","title":"Custom Transport Serializers","text":"<p>You can specify a custom serializer when creating a transport:</p> <pre><code># Custom serializer for a transport\nclass MyCustomSerializer\n  def encode(data_hash)\n    # Your encoding logic here\n    # Must return a string\n  end\n\n  def decode(serialized_string)\n    # Your decoding logic here\n    # Must return a hash\n  end\nend\n\n# Use custom serializer with transport\ntransport = SmartMessage::Transport::RedisTransport.new(\n  serializer: MyCustomSerializer.new,\n  url: 'redis://localhost:6379'\n)\n</code></pre>"},{"location":"reference/serializers/#built-in-serializer-classes","title":"Built-in Serializer Classes","text":"<p>SmartMessage includes these serializer implementations that transports use internally:</p>"},{"location":"reference/serializers/#json-serializer","title":"JSON Serializer","text":"<p><pre><code>SmartMessage::Serializer::Json.new\n</code></pre> - Human-readable format - Wide compatibility - Used by STDOUT transport and as fallback</p>"},{"location":"reference/serializers/#messagepack-serializer","title":"MessagePack Serializer","text":"<p><pre><code>SmartMessage::Serializer::MessagePack.new\n</code></pre> - Binary format for efficiency - Smaller payload size - Used by Redis transport when available</p>"},{"location":"reference/serializers/#migration-from-message-level-serializers","title":"Migration from Message-Level Serializers","text":"<p>If you were previously configuring serializers at the message level, here's how to migrate:</p>"},{"location":"reference/serializers/#before-message-level-configuration","title":"Before (Message-Level Configuration)","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport::RedisTransport.new\n    serializer SmartMessage::Serializer::Json.new  # \u274c No longer needed\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#after-transport-level-serialization","title":"After (Transport-Level Serialization)","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  config do\n    # Transport automatically handles serialization\n    transport SmartMessage::Transport::RedisTransport.new\n  end\nend\n\n# Or specify custom serializer for transport\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport::RedisTransport.new(\n      serializer: MyCustomSerializer.new\n    )\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#serialization-best-practices","title":"Serialization Best Practices","text":""},{"location":"reference/serializers/#1-let-transports-choose","title":"1. Let Transports Choose","text":"<p>Let each transport use its optimal format: - Memory: No serialization - STDOUT: JSON for readability - Redis: MessagePack for efficiency</p>"},{"location":"reference/serializers/#2-custom-serializers","title":"2. Custom Serializers","text":"<p>Only use custom serializers when you have specific requirements: - Special data formats (XML, Protocol Buffers) - Encryption/compression needs - Legacy system compatibility</p>"},{"location":"reference/serializers/#3-testing","title":"3. Testing","text":"<p>Test with actual transports to ensure serialization works correctly:</p> <pre><code>RSpec.describe OrderMessage do\n  it \"serializes correctly with Redis transport\" do\n    transport = SmartMessage::Transport::RedisTransport.new\n    message = OrderMessage.new(order_id: \"123\", amount: 99.99)\n\n    # Test roundtrip serialization\n    serialized = transport.encode_message(message)\n    deserialized = transport.decode_message(serialized)\n\n    expect(deserialized[:order_id]).to eq(\"123\")\n    expect(deserialized[:amount]).to eq(99.99)\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#4-error-handling","title":"4. Error Handling","text":"<p>Transports handle serialization errors internally, but you can still catch them:</p> <pre><code>begin\n  message.publish\nrescue SmartMessage::Errors::SerializationError =&gt; e\n  logger.error \"Failed to serialize message: #{e.message}\"\nend\n</code></pre>"},{"location":"reference/serializers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/serializers/#format-efficiency","title":"Format Efficiency","text":"<ul> <li>MessagePack: 20-30% more compact than JSON</li> <li>JSON: Human-readable but larger payload</li> <li>Memory: No serialization overhead</li> </ul>"},{"location":"reference/serializers/#network-optimization","title":"Network Optimization","text":"<ul> <li>Redis transport automatically uses MessagePack when available</li> <li>Falls back to JSON if MessagePack gem is not installed</li> <li>STDOUT uses JSON for debugging clarity</li> </ul>"},{"location":"reference/serializers/#monitoring","title":"Monitoring","text":"<p>Each transport logs its serializer choice: <pre><code>[SmartMessage::Transport::RedisTransport] Using serializer: SmartMessage::Serializer::MessagePack\n</code></pre></p>"},{"location":"reference/serializers/#next-steps","title":"Next Steps","text":"<ul> <li>Transports - Available transport implementations</li> <li>Configuration - Setting up transports</li> <li>Examples - Real-world usage patterns</li> </ul>"},{"location":"reference/transports/","title":"Transport Layer","text":"<p>The transport layer is responsible for moving messages between systems. SmartMessage provides a pluggable transport architecture that supports various backend systems.</p>"},{"location":"reference/transports/#overview","title":"Overview","text":"<p>Transports handle: - Publishing: Sending messages to a destination (single or multiple transports) - Subscribing: Registering interest in message types - Routing: Directing incoming messages to the dispatcher - Connection Management: Handling connections to external systems</p>"},{"location":"reference/transports/#multi-transport-publishing","title":"Multi-Transport Publishing","text":"<p>SmartMessage supports publishing to multiple transports simultaneously for redundancy, integration, and migration scenarios. Configure an array of transports to send messages to multiple destinations with a single <code>publish()</code> call.</p> <pre><code>class CriticalMessage &lt; SmartMessage::Base\n  transport [\n    SmartMessage::Transport.create(:redis_queue, url: 'redis://primary:6379'),\n    SmartMessage::Transport.create(:redis, url: 'redis://backup:6379'),\n    SmartMessage::Transport::StdoutTransport.new(format: :json)\n  ]\nend\n\nmessage = CriticalMessage.new(data: \"important\")\nmessage.publish  # \u2705 Publishes to all three transports\n</code></pre> <p>\ud83d\udcda See Multi-Transport Documentation for comprehensive examples and best practices.</p>"},{"location":"reference/transports/#built-in-transports","title":"Built-in Transports","text":""},{"location":"reference/transports/#stdout-transport","title":"STDOUT Transport","text":"<p>Publish-only transport perfect for debugging, logging, and integration with external systems.</p> <p>Features: - Publish-only: No message processing or loopback capability - Outputs messages to console or file in pretty-print or JSON formats - Subscription attempts are ignored with warning logs - Perfect for piping to external tools and log aggregators - No external dependencies</p> <p>Usage:</p> <pre><code># Basic STDOUT output (publish-only)\ntransport = SmartMessage::Transport::StdoutTransport.new\n\n# Pretty-printed format for human reading (default)\ntransport = SmartMessage::Transport::StdoutTransport.new(format: :pretty)\n\n# JSON format for machine processing\ntransport = SmartMessage::Transport::StdoutTransport.new(format: :json)\n\n# Output to file instead of console\ntransport = SmartMessage::Transport::StdoutTransport.new(output: \"messages.log\")\n\n# Configure in message class\nclass LogMessage &lt; SmartMessage::Base\n  property :level\n  property :message\n\n  config do\n    transport SmartMessage::Transport::StdoutTransport.new(\n      format: :json,\n      output: \"app.log\"\n    )\n  end\nend\n</code></pre> <p>Options: - <code>format</code> (Symbol): Output format - <code>:pretty</code> for debugging, <code>:json</code> for integration (default: <code>:pretty</code>) - <code>output</code> (String|IO): Output destination - filename string or IO object (default: <code>$stdout</code>)</p> <p>Important: For local message processing during development, use MemoryTransport instead.</p> <p>Example Output: <pre><code>===================================================\n== SmartMessage Published via STDOUT Transport\n== Header: #&lt;SmartMessage::Header:0x... @uuid=\"abc-123\", @message_class=\"MyMessage\", ...&gt;\n== Payload: {\"user_id\":123,\"action\":\"login\",\"timestamp\":\"2025-08-17T10:30:00Z\"}\n===================================================\n</code></pre></p>"},{"location":"reference/transports/#memory-transport","title":"Memory Transport","text":"<p>Ideal for testing and in-memory message queuing.</p> <p>Features: - Stores messages in memory - Thread-safe operations - Optional auto-processing - Message inspection capabilities - Memory overflow protection</p> <p>Usage:</p> <pre><code># Auto-process messages as they're published\ntransport = SmartMessage::Transport.create(:memory, auto_process: true)\n\n# Store messages without processing (manual control)\ntransport = SmartMessage::Transport.create(:memory, auto_process: false)\n\n# Configure maximum message storage\ntransport = SmartMessage::Transport.create(:memory, \n  auto_process: false,\n  max_messages: 500\n)\n\n# Use in message class\nclass TestMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\nend\n</code></pre> <p>Options: - <code>auto_process</code> (Boolean): Automatically route messages to dispatcher (default: true) - <code>max_messages</code> (Integer): Maximum messages to store in memory (default: 1000)</p> <p>Message Management:</p> <pre><code>transport = SmartMessage::Transport.create(:memory)\n\n# Check stored messages\nputs transport.message_count\nputs transport.all_messages\n\n# Process all pending messages manually\ntransport.process_all\n\n# Clear all stored messages\ntransport.clear_messages\n\n# Access individual messages\nmessages = transport.all_messages\nmessages.each do |msg|\n  puts \"Published at: #{msg[:published_at]}\"\n  puts \"Header: #{msg[:header]}\"\n  puts \"Payload: #{msg[:payload]}\"\nend\n</code></pre>"},{"location":"reference/transports/#redis-transport","title":"Redis Transport","text":"<p>Production-ready Redis pub/sub transport for distributed messaging.</p> <p>Features: - Redis pub/sub messaging - Automatic channel management using message class names - Thread-safe subscriber management - Connection resilience with automatic reconnection - Configurable connection parameters - Background message subscription threads</p> <p>\ud83d\udca1 Redis Transport: SmartMessage provides a Redis-based transport for production messaging using pub/sub channels. See the Redis Transport documentation for detailed usage guidance.</p> <p>Usage:</p> <pre><code># Basic Redis configuration\ntransport = SmartMessage::Transport.create(:redis, \n  url: 'redis://localhost:6379',\n  db: 0\n)\n\n# Production configuration with custom options\ntransport = SmartMessage::Transport.create(:redis,\n  url: 'redis://prod-redis:6379',\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n\n# Configure in message class\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:redis, \n      url: 'redis://localhost:6379',\n      db: 1\n    )\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    order = decoded_message\n    puts \"Processing order #{order.order_id} for $#{order.amount}\"\n    # Your business logic here\n  end\nend\n\n# Subscribe to messages (creates Redis subscription to \"OrderMessage\" channel)\nOrderMessage.subscribe\n\n# Publish messages (publishes to \"OrderMessage\" Redis channel)\norder = OrderMessage.new(\n  order_id: \"ORD-123\",\n  customer_id: \"CUST-456\", \n  amount: 99.99\n)\norder.publish\n</code></pre> <p>Options: - <code>url</code> (String): Redis connection URL (default: 'redis://localhost:6379') - <code>db</code> (Integer): Redis database number (default: 0) - <code>auto_subscribe</code> (Boolean): Automatically start subscriber thread (default: true) - <code>reconnect_attempts</code> (Integer): Number of reconnection attempts (default: 5) - <code>reconnect_delay</code> (Integer): Delay between reconnection attempts in seconds (default: 1) - <code>debug</code> (Boolean): Enable debug output (default: false)</p> <p>Channel Naming:</p> <p>The Redis transport uses the message class name as the Redis channel name. This provides automatic routing:</p> <pre><code>class UserMessage &lt; SmartMessage::Base\n  # Messages published to/from Redis channel \"UserMessage\"\nend\n\nclass AdminMessage &lt; SmartMessage::Base  \n  # Messages published to/from Redis channel \"AdminMessage\"\nend\n\nclass OrderProcessing::PaymentMessage &lt; SmartMessage::Base\n  # Messages published to/from Redis channel \"OrderProcessing::PaymentMessage\"\nend\n</code></pre> <p>Connection Management:</p> <pre><code>transport = SmartMessage::Transport.create(:redis, url: 'redis://localhost:6379')\n\n# Check connection status\nputs transport.connected?  # =&gt; true/false\n\n# Manual connection management\ntransport.connect\ntransport.disconnect\n\n# The transport automatically reconnects on connection failures\n</code></pre> <p>Multi-Message Type Support:</p> <pre><code># Different message types can share the same Redis transport\nredis_transport = SmartMessage::Transport.create(:redis, \n  url: 'redis://localhost:6379',\n  auto_subscribe: true\n)\n\n# Configure multiple message classes to use the same transport\n[OrderMessage, PaymentMessage, ShippingMessage].each do |msg_class|\n  msg_class.config do\n    transport redis_transport\n  end\n\n  # Subscribe to each message type (creates separate Redis subscriptions)\n  msg_class.subscribe\nend\n\n# Publishing to any message type routes to its specific Redis channel\nOrderMessage.new(order_id: \"123\").publish      # -&gt; \"OrderMessage\" channel\nPaymentMessage.new(amount: 50.0).publish       # -&gt; \"PaymentMessage\" channel\nShippingMessage.new(tracking: \"ABC\").publish   # -&gt; \"ShippingMessage\" channel\n</code></pre> <p>Error Handling and Resilience:</p> <p>The Redis transport includes built-in error handling:</p> <pre><code># Automatic reconnection on connection failures\ntransport = SmartMessage::Transport.create(:redis,\n  url: 'redis://localhost:6379',\n  reconnect_attempts: 5,    # Try 5 times to reconnect\n  reconnect_delay: 2        # Wait 2 seconds between attempts\n)\n\n# Connection failures during publishing will trigger automatic retry\n# If all reconnection attempts fail, the original error is raised\n</code></pre> <p>Production Deployment:</p> <pre><code># Production Redis configuration\nclass ProductionMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: ENV['REDIS_URL'] || 'redis://localhost:6379',\n      db: ENV['REDIS_DB']&amp;.to_i || 0,\n      auto_subscribe: true,\n      reconnect_attempts: 10,\n      reconnect_delay: 5\n    )\n    logger Logger.new(STDOUT)\n  end\nend\n</code></pre> <p>Testing with Redis:</p> <pre><code># Test configuration (using separate Redis database)\nclass TestMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: 'redis://localhost:6379',\n      db: 15,  # Use separate database for tests\n      auto_subscribe: true\n    )\n  end\nend\n\n# In your test setup\ndef setup\n  # Clear test database\n  Redis.new(url: 'redis://localhost:6379', db: 15).flushdb\nend\n</code></pre>"},{"location":"reference/transports/#transport-interface","title":"Transport Interface","text":"<p>All transports must implement the <code>SmartMessage::Transport::Base</code> interface:</p>"},{"location":"reference/transports/#required-methods","title":"Required Methods","text":"<pre><code>class CustomTransport &lt; SmartMessage::Transport::Base\n  # Publish a message\n  def publish(message_header, message_payload)\n    # Send the message via your transport mechanism\n  end\n\n  # Optional: Override default options\n  def default_options\n    {\n      connection_timeout: 30,\n      retry_attempts: 3\n    }\n  end\n\n  # Optional: Custom configuration setup\n  def configure\n    @connection = establish_connection(@options)\n  end\n\n  # Optional: Connection status checking\n  def connected?\n    @connection&amp;.connected?\n  end\n\n  # Optional: Cleanup resources\n  def disconnect\n    @connection&amp;.close\n  end\nend\n</code></pre>"},{"location":"reference/transports/#inherited-methods","title":"Inherited Methods","text":"<p>Transports automatically inherit these methods from <code>SmartMessage::Transport::Base</code>:</p> <pre><code># Subscription management (uses dispatcher)\ntransport.subscribe(message_class, process_method)\ntransport.unsubscribe(message_class, process_method) \ntransport.unsubscribe!(message_class)\ntransport.subscribers\n\n# Connection management\ntransport.connect\ntransport.disconnect\ntransport.connected?\n\n# Message receiving (call this from your transport)\ntransport.receive(message_header, message_payload)  # protected method\n</code></pre>"},{"location":"reference/transports/#transport-registration","title":"Transport Registration","text":"<p>Register custom transports for easy creation:</p> <pre><code># Register custom transport classes\nSmartMessage::Transport.register(:kafka, KafkaTransport)\nSmartMessage::Transport.register(:webhook, WebhookTransport)\n\n# List all registered transports (includes built-ins)\nputs SmartMessage::Transport.available\n# =&gt; [:stdout, :memory, :redis, :kafka, :webhook]\n\n# Create instances of built-in transports\nredis_transport = SmartMessage::Transport.create(:redis, \n  url: \"redis://localhost:6379\"\n)\n\nmemory_transport = SmartMessage::Transport.create(:memory,\n  auto_process: true\n)\n\n# Create instances of custom transports\nkafka_transport = SmartMessage::Transport.create(:kafka,\n  servers: [\"localhost:9092\"]\n)\n</code></pre>"},{"location":"reference/transports/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"reference/transports/#class-level-configuration","title":"Class-Level Configuration","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  # All instances use this transport by default\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\nend\n</code></pre>"},{"location":"reference/transports/#instance-level-override","title":"Instance-Level Override","text":"<pre><code># Override transport for specific instances\norder = OrderMessage.new(order_id: \"123\", amount: 99.99)\n\norder.config do\n  # This instance will use STDOUT instead of memory (publish-only)\n  transport SmartMessage::Transport::StdoutTransport.new(format: :json)\nend\n\norder.publish  # Uses STDOUT transport (publish-only)\n</code></pre>"},{"location":"reference/transports/#runtime-transport-switching","title":"Runtime Transport Switching","text":"<pre><code>class NotificationMessage &lt; SmartMessage::Base\n  property :recipient\n  property :message\n\n  def self.send_via_email\n    config do\n      transport EmailTransport.new\n    end\n  end\n\n  def self.send_via_sms  \n    config do\n      transport SMSTransport.new\n    end\n  end\nend\n\n# Switch transport at runtime\nNotificationMessage.send_via_email\nnotification = NotificationMessage.new(\n  recipient: \"user@example.com\",\n  message: \"Hello!\"\n)\nnotification.publish  # Sent via email\n</code></pre>"},{"location":"reference/transports/#transport-options","title":"Transport Options","text":""},{"location":"reference/transports/#common-options-pattern","title":"Common Options Pattern","text":"<p>Most transports support these common option patterns:</p> <pre><code>transport = SmartMessage::Transport.create(:custom,\n  # Connection options\n  host: \"localhost\",\n  port: 5672,\n  username: \"guest\",\n  password: \"guest\",\n\n  # Retry options\n  retry_attempts: 3,\n  retry_delay: 1.0,\n\n  # Timeout options\n  connection_timeout: 30,\n  read_timeout: 10,\n\n  # Behavior options\n  auto_reconnect: true,\n  persistent: true\n)\n</code></pre>"},{"location":"reference/transports/#transport-specific-options","title":"Transport-Specific Options","text":"<p>Each transport may have specific options:</p> <pre><code># STDOUT specific (publish-only)\nSmartMessage::Transport::StdoutTransport.new(\n  format: :json,\n  output: \"/var/log/messages.log\"\n)\n\n# Memory specific  \nSmartMessage::Transport.create(:memory,\n  auto_process: false,\n  max_messages: 1000\n)\n\n# Redis specific\nSmartMessage::Transport.create(:redis,\n  url: \"redis://localhost:6379\",\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n</code></pre>"},{"location":"reference/transports/#error-handling","title":"Error Handling","text":""},{"location":"reference/transports/#transport-errors","title":"Transport Errors","text":"<p>Transports should handle their own connection and transmission errors:</p> <pre><code>class RobustTransport &lt; SmartMessage::Transport::Base\n  def publish(message_header, message_payload)\n    retry_count = 0\n    begin\n      send_message(message_header, message_payload)\n    rescue ConnectionError =&gt; e\n      retry_count += 1\n      if retry_count &lt;= @options[:retry_attempts]\n        sleep(@options[:retry_delay])\n        retry\n      else\n        # Log error and potentially fallback\n        handle_publish_error(e, message_header, message_payload)\n      end\n    end\n  end\n\n  private\n\n  def handle_publish_error(error, header, payload)\n    # Log the error\n    puts \"Failed to publish message: #{error.message}\"\n\n    # Optional: Store for later retry\n    store_failed_message(header, payload)\n\n    # Optional: Use fallback transport\n    fallback_transport&amp;.publish(header, payload)\n  end\nend\n</code></pre>"},{"location":"reference/transports/#connection-monitoring","title":"Connection Monitoring","text":"<pre><code>class MonitoredTransport &lt; SmartMessage::Transport::Base\n  def connected?\n    @connection&amp;.ping rescue false\n  end\n\n  def publish(message_header, message_payload)\n    unless connected?\n      connect\n    end\n\n    super\n  end\n\n  def connect\n    @connection = establish_connection(@options)\n    puts \"Connected to #{@options[:host]}:#{@options[:port]}\"\n  rescue =&gt; e\n    puts \"Failed to connect: #{e.message}\"\n    raise\n  end\nend\n</code></pre>"},{"location":"reference/transports/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/transports/#message-batching","title":"Message Batching","text":"<p>For high-throughput scenarios, consider batching:</p> <pre><code>class BatchingTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @batch = []\n    @batch_mutex = Mutex.new\n    setup_batch_timer\n  end\n\n  def publish(message_header, message_payload)\n    @batch_mutex.synchronize do\n      @batch &lt;&lt; [message_header, message_payload]\n\n      if @batch.size &gt;= @options[:batch_size]\n        flush_batch\n      end\n    end\n  end\n\n  private\n\n  def flush_batch\n    return if @batch.empty?\n\n    batch_to_send = @batch.dup\n    @batch.clear\n\n    send_batch(batch_to_send)\n  end\nend\n</code></pre>"},{"location":"reference/transports/#connection-pooling","title":"Connection Pooling","text":"<p>For database or network transports:</p> <pre><code>class PooledTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @connection_pool = ConnectionPool.new(\n      size: @options[:pool_size] || 5,\n      timeout: @options[:pool_timeout] || 5\n    ) { create_connection }\n  end\n\n  def publish(message_header, message_payload)\n    @connection_pool.with do |connection|\n      connection.send(message_header, message_payload)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/transports/#testing-transports","title":"Testing Transports","text":""},{"location":"reference/transports/#mock-transport-for-testing","title":"Mock Transport for Testing","text":"<pre><code>class MockTransport &lt; SmartMessage::Transport::Base\n  attr_reader :published_messages\n\n  def initialize(options = {})\n    super\n    @published_messages = []\n  end\n\n  def publish(message_header, message_payload)\n    @published_messages &lt;&lt; {\n      header: message_header,\n      payload: message_payload,\n      published_at: Time.now\n    }\n\n    # Optionally trigger processing\n    receive(message_header, message_payload) if @options[:auto_process]\n  end\n\n  def clear\n    @published_messages.clear\n  end\nend\n\n# Use in tests\nRSpec.describe \"Message Publishing\" do\n  let(:transport) { MockTransport.new(auto_process: true) }\n\n  before do\n    MyMessage.config do\n      transport transport\n    end\n  end\n\n  it \"publishes messages\" do\n    MyMessage.new(data: \"test\").publish\n\n    expect(transport.published_messages).to have(1).message\n    expect(transport.published_messages.first[:payload]).to include(\"test\")\n  end\nend\n</code></pre>"},{"location":"reference/transports/#next-steps","title":"Next Steps","text":"<ul> <li>Redis Transport Comparison - Detailed comparison of Redis, Enhanced, and Queue transports</li> <li>Serializers - Understanding message serialization</li> <li>Dispatcher - Message routing and processing  </li> <li>Examples - Real-world transport usage patterns</li> </ul>"},{"location":"transports/memory-transport/","title":"Memory Transport","text":"<p>The Memory Transport is an in-memory transport implementation designed for testing, development, and rapid prototyping. It stores messages in memory and provides synchronous processing capabilities.</p>"},{"location":"transports/memory-transport/#overview","title":"Overview","text":"<p>The Memory Transport is perfect for: - Unit testing - No external dependencies required - Local development - Fast, lightweight message processing - Rapid prototyping - Quick setup without infrastructure - Debug and inspection - Full visibility into message flow</p>"},{"location":"transports/memory-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83e\udde0 In-Memory Storage - Messages stored in process memory</li> <li>\u26a1 Synchronous Processing - Immediate message processing</li> <li>\ud83d\udd0d Message Inspection - View and count stored messages</li> <li>\ud83d\udd04 Auto-Processing - Optional automatic message processing</li> <li>\ud83d\udee1\ufe0f Memory Protection - Configurable message limits to prevent overflow</li> <li>\ud83e\uddf5 Thread-Safe - Mutex-protected operations</li> </ul>"},{"location":"transports/memory-transport/#configuration","title":"Configuration","text":""},{"location":"transports/memory-transport/#basic-setup","title":"Basic Setup","text":"<pre><code># Minimal configuration\ntransport = SmartMessage::Transport::MemoryTransport.new\n\n# With options\ntransport = SmartMessage::Transport::MemoryTransport.new(\n  auto_process: true,     # Process messages immediately (default: true)\n  max_messages: 1000      # Maximum messages to store (default: 1000)\n)\n</code></pre>"},{"location":"transports/memory-transport/#using-with-smartmessage","title":"Using with SmartMessage","text":"<pre><code># Configure as default transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new\nend\n\n# Use in message class\nclass TestMessage &lt; SmartMessage::Base\n  property :content, required: true\n\n  transport :memory\n\n  def process\n    puts \"Processing: #{content}\"\n  end\nend\n</code></pre>"},{"location":"transports/memory-transport/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>auto_process</code> Boolean <code>true</code> Automatically process messages when published <code>max_messages</code> Integer <code>1000</code> Maximum messages to store (prevents memory overflow)"},{"location":"transports/memory-transport/#usage-examples","title":"Usage Examples","text":""},{"location":"transports/memory-transport/#basic-message-processing","title":"Basic Message Processing","text":"<pre><code># Create transport\ntransport = SmartMessage::Transport::MemoryTransport.new\n\n# Define message\nclass AlertMessage &lt; SmartMessage::Base\n  property :message, required: true\n  property :severity, default: 'info'\n\n  transport transport\n\n  def process\n    puts \"[#{severity.upcase}] #{message}\"\n  end\nend\n\n# Publish message\nAlertMessage.new(\n  message: \"System startup complete\",\n  severity: \"info\"\n).publish\n\n# Output: [INFO] System startup complete\n</code></pre>"},{"location":"transports/memory-transport/#manual-processing-control","title":"Manual Processing Control","text":"<pre><code># Disable auto-processing for batch operations\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\nclass DataMessage &lt; SmartMessage::Base\n  property :data\n  transport transport\n\n  def process\n    puts \"Processing: #{data}\"\n  end\nend\n\n# Publish multiple messages\nDataMessage.new(data: \"batch 1\").publish\nDataMessage.new(data: \"batch 2\").publish\nDataMessage.new(data: \"batch 3\").publish\n\nputs \"Messages stored: #{transport.message_count}\"\n# Output: Messages stored: 3\n\n# Process all at once\ntransport.process_all\n# Output: \n# Processing: batch 1\n# Processing: batch 2\n# Processing: batch 3\n</code></pre>"},{"location":"transports/memory-transport/#message-inspection","title":"Message Inspection","text":"<pre><code>transport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :amount, required: true\n  transport transport\nend\n\n# Publish test messages\nOrderMessage.new(order_id: \"ORD-001\", amount: 99.99).publish\nOrderMessage.new(order_id: \"ORD-002\", amount: 149.50).publish\n\n# Inspect stored messages\nputs \"Total messages: #{transport.message_count}\"\ntransport.all_messages.each_with_index do |msg, index|\n  puts \"Message #{index + 1}: #{msg[:message_class]} at #{msg[:published_at]}\"\nend\n\n# Clear messages when done\ntransport.clear_messages\nputs \"Messages after clear: #{transport.message_count}\"\n</code></pre>"},{"location":"transports/memory-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/memory-transport/#instance-methods","title":"Instance Methods","text":""},{"location":"transports/memory-transport/#message_count","title":"<code>#message_count</code>","text":"<p>Returns the number of messages currently stored.</p> <pre><code>count = transport.message_count\nputs \"Stored messages: #{count}\"\n</code></pre>"},{"location":"transports/memory-transport/#all_messages","title":"<code>#all_messages</code>","text":"<p>Returns a copy of all stored messages with metadata.</p> <pre><code>messages = transport.all_messages\nmessages.each do |msg|\n  puts \"Class: #{msg[:message_class]}\"\n  puts \"Time: #{msg[:published_at]}\"\n  puts \"Data: #{msg[:serialized_message]}\"\nend\n</code></pre>"},{"location":"transports/memory-transport/#clear_messages","title":"<code>#clear_messages</code>","text":"<p>Removes all stored messages from memory.</p> <pre><code>transport.clear_messages\n</code></pre>"},{"location":"transports/memory-transport/#process_all","title":"<code>#process_all</code>","text":"<p>Manually processes all stored messages (useful when <code>auto_process: false</code>).</p> <pre><code># Publish messages without auto-processing\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n# ... publish messages ...\n\n# Process them all at once\ntransport.process_all\n</code></pre>"},{"location":"transports/memory-transport/#connected","title":"<code>#connected?</code>","text":"<p>Always returns <code>true</code> since memory transport is always available.</p> <pre><code>puts transport.connected?  # =&gt; true\n</code></pre>"},{"location":"transports/memory-transport/#use-cases","title":"Use Cases","text":""},{"location":"transports/memory-transport/#unit-testing","title":"Unit Testing","text":"<pre><code>RSpec.describe \"Message Processing\" do\n  let(:transport) { SmartMessage::Transport::MemoryTransport.new }\n\n  before do\n    MyMessage.transport = transport\n    transport.clear_messages\n  end\n\n  it \"processes messages correctly\" do\n    MyMessage.new(data: \"test\").publish\n    expect(transport.message_count).to eq(1)\n  end\n\n  it \"respects message limits\" do\n    transport = SmartMessage::Transport::MemoryTransport.new(max_messages: 2)\n\n    3.times { |i| MyMessage.new(data: i).publish }\n    expect(transport.message_count).to eq(2)  # Oldest message dropped\n  end\nend\n</code></pre>"},{"location":"transports/memory-transport/#development-environment","title":"Development Environment","text":"<pre><code># config/environments/development.rb\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new(\n    auto_process: true,\n    max_messages: 500\n  )\n  config.logger.level = Logger::DEBUG  # See all message activity\nend\n</code></pre>"},{"location":"transports/memory-transport/#batch-processing","title":"Batch Processing","text":"<pre><code># Collect messages for batch processing\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\n# Publish work items\nwork_items.each do |item|\n  WorkMessage.new(item: item).publish\nend\n\n# Process batch when ready\nputs \"Processing #{transport.message_count} work items...\"\nstart_time = Time.now\ntransport.process_all\nputs \"Completed in #{Time.now - start_time} seconds\"\n</code></pre>"},{"location":"transports/memory-transport/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Latency: ~0.01ms (memory access)</li> <li>Throughput: 100K+ messages/second</li> <li>Memory Usage: ~1KB per stored message</li> <li>Concurrency: Thread-safe with mutex protection</li> <li>Persistence: None (messages lost when process ends)</li> </ul>"},{"location":"transports/memory-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/memory-transport/#testing","title":"Testing","text":"<ul> <li>Use <code>clear_messages</code> in test setup/teardown</li> <li>Set reasonable <code>max_messages</code> limits for long-running tests</li> <li>Disable <code>auto_process</code> for message inspection tests</li> </ul>"},{"location":"transports/memory-transport/#development","title":"Development","text":"<ul> <li>Enable debug logging to see message flow</li> <li>Use message inspection methods for debugging</li> <li>Consider memory limits in long-running development processes</li> </ul>"},{"location":"transports/memory-transport/#production","title":"Production","text":"<p>\u26a0\ufe0f Not recommended for production use - Messages are lost when process restarts - No persistence or durability guarantees - Limited by process memory</p>"},{"location":"transports/memory-transport/#thread-safety","title":"Thread Safety","text":"<p>The Memory Transport is fully thread-safe: - All operations use mutex synchronization - Messages can be published from multiple threads - Inspection methods return safe copies</p> <pre><code># Thread-safe concurrent publishing\nthreads = []\n10.times do |i|\n  threads &lt;&lt; Thread.new do\n    100.times { |j| TestMessage.new(data: \"#{i}-#{j}\").publish }\n  end\nend\nthreads.each(&amp;:join)\n\nputs \"Total messages: #{transport.message_count}\"  # Always accurate\n</code></pre>"},{"location":"transports/memory-transport/#migration-from-memory-transport","title":"Migration from Memory Transport","text":"<p>When moving from Memory Transport to production transports:</p> <pre><code># Development (Memory Transport)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new\nend\n\n# Production (Redis Transport)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: ENV['REDIS_URL']\n  )\nend\n</code></pre> <p>Messages and processing logic remain identical - only the transport configuration changes.</p>"},{"location":"transports/memory-transport/#examples","title":"Examples","text":"<p>The <code>examples/memory/</code> directory contains comprehensive, runnable examples demonstrating Memory Transport capabilities:</p>"},{"location":"transports/memory-transport/#core-messaging-examples","title":"Core Messaging Examples","text":"<ul> <li>03_point_to_point_orders.rb - Point-to-point order processing with payment integration</li> <li>04_publish_subscribe_events.rb - Event broadcasting to multiple services (email, SMS, audit)</li> <li>05_many_to_many_chat.rb - Interactive chat system with rooms, bots, and human agents</li> </ul>"},{"location":"transports/memory-transport/#advanced-features","title":"Advanced Features","text":"<ul> <li>01_message_deduplication_demo.rb - Message deduplication patterns and strategies</li> <li>02_dead_letter_queue_demo.rb - Complete Dead Letter Queue system with circuit breakers</li> <li>07_proc_handlers_demo.rb - Flexible message handlers (blocks, procs, lambdas, methods)</li> </ul>"},{"location":"transports/memory-transport/#configuration-monitoring","title":"Configuration &amp; Monitoring","text":"<ul> <li>08_custom_logger_demo.rb - Advanced logging with SmartMessage::Logger::Default</li> <li>09_error_handling_demo.rb - Comprehensive validation, version mismatch, and error handling</li> <li>13_header_block_configuration.rb - Header and block configuration examples</li> <li>14_global_configuration_demo.rb - Global configuration management</li> <li>15_logger_demo.rb - Advanced logging demonstrations</li> </ul>"},{"location":"transports/memory-transport/#entity-addressing-filtering","title":"Entity Addressing &amp; Filtering","text":"<ul> <li>10_entity_addressing_basic.rb - Basic FROM/TO/REPLY_TO message addressing</li> <li>11_entity_addressing_with_filtering.rb - Advanced entity-aware message filtering</li> <li>12_regex_filtering_microservices.rb - Advanced regex filtering for microservices</li> </ul>"},{"location":"transports/memory-transport/#visual-demonstrations","title":"Visual Demonstrations","text":"<ul> <li>06_stdout_publish_only.rb - STDOUT transport publish-only demonstration with logging and metrics examples</li> <li>16_pretty_print_demo.rb - Message inspection and pretty-printing capabilities</li> </ul>"},{"location":"transports/memory-transport/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to the SmartMessage directory\ncd smart_message\n\n# Run any Memory Transport example\nruby examples/memory/03_point_to_point_orders.rb\nruby examples/memory/05_many_to_many_chat.rb\nruby examples/memory/02_dead_letter_queue_demo.rb\n\n# Or explore the entire directory\nls examples/memory/\n</code></pre> <p>Each example is self-contained and demonstrates specific Memory Transport features with clear educational comments and real-world scenarios.</p>"},{"location":"transports/memory-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Transport Overview - All available transports</li> <li>Redis Transport - Production-ready Redis transport</li> <li>Testing Guide - Testing strategies with SmartMessage</li> </ul>"},{"location":"transports/multi-transport/","title":"Multi-Transport Publishing","text":"<p>Send messages to multiple transports simultaneously for redundancy, integration, and migration scenarios.</p> <p>SmartMessage supports configuring messages with multiple transports, enabling sophisticated messaging patterns where a single <code>publish()</code> operation can deliver messages across different transport systems simultaneously.</p>"},{"location":"transports/multi-transport/#overview","title":"Overview","text":"<p>Multi-transport publishing allows you to:</p> <ul> <li>Redundancy: Send critical messages to primary and backup systems</li> <li>Integration: Simultaneously deliver to production queues and logging/monitoring systems</li> <li>Migration: Gradually transition between transport systems without downtime</li> <li>Fan-out: Broadcast messages to multiple processing pipelines</li> <li>Resilience: Ensure message delivery succeeds as long as ANY transport is available</li> </ul>"},{"location":"transports/multi-transport/#basic-configuration","title":"Basic Configuration","text":"<p>Configure multiple transports by passing an array to the <code>transport</code> method:</p> <pre><code>class OrderProcessingMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_id, required: true\n  property :amount, required: true\n\n  # Configure multiple transports\n  transport [\n    SmartMessage::Transport.create(:redis_queue, url: 'redis://primary:6379'),\n    SmartMessage::Transport.create(:redis, url: 'redis://backup:6379'),\n    SmartMessage::Transport::StdoutTransport.new(format: :json)\n  ]\nend\n\n# Publishing sends to ALL configured transports\nmessage = OrderProcessingMessage.new(\n  order_id: \"ORD-12345\", \n  customer_id: \"CUST-789\", \n  amount: 149.99\n)\n\nmessage.publish  # \u2705 Publishes to Redis Queue, Redis Pub/Sub, and STDOUT\n</code></pre>"},{"location":"transports/multi-transport/#transport-introspection","title":"Transport Introspection","text":"<p>SmartMessage provides utility methods to inspect and manage transport configurations:</p> <pre><code># Check transport configuration\nputs message.multiple_transports?  # =&gt; true\nputs message.single_transport?     # =&gt; false\nputs message.transports.length     # =&gt; 3\n\n# Access individual transports\nmessage.transports.each_with_index do |transport, index|\n  puts \"Transport #{index}: #{transport.class.name}\"\nend\n\n# Get primary transport (first in array) for backward compatibility\nprimary = message.transport  # Returns first transport\n</code></pre>"},{"location":"transports/multi-transport/#instance-level-overrides","title":"Instance-Level Overrides","text":"<p>You can override class-level multi-transport configuration at the instance level:</p> <pre><code>class MonitoringMessage &lt; SmartMessage::Base\n  property :metric, required: true\n\n  # Class-level: send to monitoring and backup\n  transport [\n    SmartMessage::Transport.create(:redis, url: 'redis://monitoring:6379'),\n    SmartMessage::Transport.create(:redis, url: 'redis://backup:6379')\n  ]\nend\n\n# Instance-level override for testing\ntest_message = MonitoringMessage.new(metric: \"cpu_usage: 85%\")\ntest_message.transport(SmartMessage::Transport::StdoutTransport.new)\n\nputs test_message.single_transport?  # =&gt; true (overridden)\ntest_message.publish  # Only goes to STDOUT\n</code></pre>"},{"location":"transports/multi-transport/#error-handling-and-resilience","title":"Error Handling and Resilience","text":"<p>Multi-transport publishing is designed to be resilient:</p>"},{"location":"transports/multi-transport/#partial-failures","title":"Partial Failures","text":"<p>When some transports succeed and others fail, publishing continues:</p> <pre><code>class CriticalAlert &lt; SmartMessage::Base\n  property :alert_text, required: true\n\n  transport [\n    ReliableTransport.new,      # \u2705 Succeeds\n    FailingTransport.new,       # \u274c Fails\n    BackupTransport.new         # \u2705 Succeeds  \n  ]\nend\n\nalert = CriticalAlert.new(alert_text: \"Database connection lost\")\nalert.publish  # \u2705 Succeeds! 2 out of 3 transports work\n\n# Logs will show:\n# [INFO] Published: CriticalAlert via ReliableTransport, BackupTransport  \n# [WARN] Failed transports for CriticalAlert: FailingTransport\n</code></pre>"},{"location":"transports/multi-transport/#complete-failures","title":"Complete Failures","text":"<p>Only when ALL transports fail does publishing raise an error:</p> <pre><code>class AllFailingMessage &lt; SmartMessage::Base\n  property :data\n\n  transport [\n    FailingTransport.new,       # \u274c Fails\n    AnotherFailingTransport.new # \u274c Fails\n  ]\nend\n\nmessage = AllFailingMessage.new(data: \"test\")\n\nbegin\n  message.publish\nrescue SmartMessage::Errors::PublishError =&gt; e\n  puts e.message  # \"All transports failed: FailingTransport: connection error; AnotherFailingTransport: timeout\"\nend\n</code></pre>"},{"location":"transports/multi-transport/#error-logging","title":"Error Logging","text":"<p>Multi-transport publishing provides comprehensive error logging:</p> <pre><code># Example log output during partial failure:\n[DEBUG] About to call transport.publish on RedisTransport\n[DEBUG] transport.publish completed on RedisTransport\n[ERROR] Transport FailingTransport failed: StandardError - Connection timeout\n[DEBUG] About to call transport.publish on StdoutTransport  \n[DEBUG] transport.publish completed on StdoutTransport\n[INFO]  Published: MyMessage via RedisTransport, StdoutTransport\n[WARN]  Failed transports for MyMessage: FailingTransport\n</code></pre>"},{"location":"transports/multi-transport/#common-use-cases","title":"Common Use Cases","text":""},{"location":"transports/multi-transport/#1-high-availability-critical-messages","title":"1. High-Availability Critical Messages","text":"<p>Ensure critical business messages reach their destination even if primary systems fail:</p> <pre><code>class PaymentProcessedMessage &lt; SmartMessage::Base\n  property :payment_id, required: true\n  property :amount, required: true\n  property :status, required: true\n\n  # Primary processing + backup + audit trail\n  transport [\n    SmartMessage::Transport.create(:redis_queue, \n      url: 'redis://primary-cluster:6379',\n      queue_prefix: 'payments'\n    ),\n    SmartMessage::Transport.create(:redis,\n      url: 'redis://backup-cluster:6380'  \n    ),\n    SmartMessage::Transport::StdoutTransport.new(\n      output: '/var/log/payments.log',\n      format: :json\n    )\n  ]\nend\n</code></pre>"},{"location":"transports/multi-transport/#2-development-and-production-dual-publishing","title":"2. Development and Production Dual Publishing","text":"<p>Send messages to both production and development environments during migration:</p> <pre><code>class UserRegistrationMessage &lt; SmartMessage::Base  \n  property :user_id, required: true\n  property :email, required: true\n\n  # Dual publishing during migration\n  transport [\n    SmartMessage::Transport.create(:redis, \n      url: ENV['PRODUCTION_REDIS_URL']\n    ),\n    SmartMessage::Transport.create(:redis_queue,\n      url: ENV['NEW_SYSTEM_REDIS_URL'],\n      queue_prefix: 'migration'\n    )\n  ]\nend\n</code></pre>"},{"location":"transports/multi-transport/#3-monitoring-and-alerting-integration","title":"3. Monitoring and Alerting Integration","text":"<p>Combine business processing with operational monitoring:</p> <pre><code>class OrderFailureMessage &lt; SmartMessage::Base\n  property :order_id, required: true  \n  property :error_message, required: true\n  property :customer_impact, required: true\n\n  transport [\n    # Business processing\n    SmartMessage::Transport.create(:redis_queue,\n      url: 'redis://orders:6379'\n    ),\n\n    # Operations monitoring  \n    SmartMessage::Transport.create(:webhook,\n      url: 'https://monitoring.company.com/alerts'\n    ),\n\n    # Development debugging\n    SmartMessage::Transport::StdoutTransport.new(format: :pretty)\n  ]\nend\n</code></pre>"},{"location":"transports/multi-transport/#4-ab-testing-and-feature-rollouts","title":"4. A/B Testing and Feature Rollouts","text":"<p>Send messages to old and new systems during feature rollouts:</p> <pre><code>class AnalyticsEventMessage &lt; SmartMessage::Base\n  property :event_type, required: true\n  property :user_id, required: true\n  property :metadata, default: {}\n\n  transport [\n    # Existing analytics pipeline (stable)\n    SmartMessage::Transport.create(:redis, \n      url: 'redis://analytics-v1:6379'\n    ),\n\n    # New analytics pipeline (testing)  \n    SmartMessage::Transport.create(:redis_queue,\n      url: 'redis://analytics-v2:6379',\n      queue_prefix: 'beta'\n    )\n  ]\nend\n</code></pre>"},{"location":"transports/multi-transport/#performance-considerations","title":"Performance Considerations","text":""},{"location":"transports/multi-transport/#sequential-processing","title":"Sequential Processing","text":"<p>Transports are processed sequentially in the order configured:</p> <pre><code># Order matters for performance\ntransport [\n  FastMemoryTransport.new,      # Processed first (fast)\n  SlowNetworkTransport.new,     # Processed second (slow) \n  AnotherFastTransport.new      # Processed third (waits for slow)\n]\n</code></pre> <p>Recommendation: Place fastest/most critical transports first.</p>"},{"location":"transports/multi-transport/#transport-independence","title":"Transport Independence","text":"<p>Each transport failure is isolated and doesn't affect others:</p> <pre><code>transport [\n  ReliableTransport.new,        # Always succeeds\n  UnreliableTransport.new,      # May fail, doesn't affect others\n  BackupTransport.new           # Provides redundancy\n]\n</code></pre>"},{"location":"transports/multi-transport/#memory-usage","title":"Memory Usage","text":"<p>Each transport instance maintains its own connection and state:</p> <pre><code># Each transport creates its own connection pool\ntransport [\n  SmartMessage::Transport.create(:redis, url: 'redis://server1:6379'),  \n  SmartMessage::Transport.create(:redis, url: 'redis://server2:6379'),\n  SmartMessage::Transport.create(:redis, url: 'redis://server3:6379')   \n]\n# Total: 3 Redis connection pools\n</code></pre>"},{"location":"transports/multi-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/multi-transport/#1-limit-transport-count","title":"1. Limit Transport Count","text":"<p>Don't configure excessive transports as this impacts performance:</p> <pre><code># \u2705 Good: 2-4 transports for specific purposes\ntransport [\n  PrimaryTransport.new,\n  BackupTransport.new, \n  MonitoringTransport.new\n]\n\n# \u274c Avoid: Too many transports\ntransport [\n  Transport1.new, Transport2.new, Transport3.new,\n  Transport4.new, Transport5.new, Transport6.new  # Overkill\n]\n</code></pre>"},{"location":"transports/multi-transport/#2-group-by-purpose","title":"2. Group by Purpose","text":"<p>Organize transports by their intended purpose:</p> <pre><code>class BusinessMessage &lt; SmartMessage::Base\n  transport [\n    # Core business processing\n    SmartMessage::Transport.create(:redis_queue, url: primary_redis_url),\n\n    # Operational monitoring  \n    SmartMessage::Transport::StdoutTransport.new(\n      output: '/var/log/business-events.log'\n    ),\n\n    # Disaster recovery backup\n    SmartMessage::Transport.create(:redis, url: backup_redis_url)\n  ]\nend\n</code></pre>"},{"location":"transports/multi-transport/#3-environment-specific-configuration","title":"3. Environment-Specific Configuration","text":"<p>Use environment variables for transport configuration:</p> <pre><code>class ConfigurableMessage &lt; SmartMessage::Base\n  transport_configs = []\n\n  # Always include primary transport\n  transport_configs &lt;&lt; SmartMessage::Transport.create(:redis_queue,\n    url: ENV['PRIMARY_REDIS_URL']\n  )\n\n  # Add backup transport in production\n  if Rails.env.production?\n    transport_configs &lt;&lt; SmartMessage::Transport.create(:redis,\n      url: ENV['BACKUP_REDIS_URL'] \n    )\n  end\n\n  # Add stdout transport in development\n  if Rails.env.development? \n    transport_configs &lt;&lt; SmartMessage::Transport::StdoutTransport.new\n  end\n\n  transport transport_configs\nend\n</code></pre>"},{"location":"transports/multi-transport/#4-health-monitoring","title":"4. Health Monitoring","text":"<p>Monitor the health of your multi-transport setup:</p> <pre><code>class HealthCheckMessage &lt; SmartMessage::Base\n  property :timestamp, default: -&gt; { Time.now }\n\n  transport [\n    PrimaryTransport.new,\n    BackupTransport.new\n  ]\n\n  # Class method to check transport health\n  def self.health_check\n    test_message = new(timestamp: Time.now)\n\n    begin\n      test_message.publish\n      { status: 'healthy', transports: 'all_operational' }\n    rescue SmartMessage::Errors::PublishError =&gt; e\n      { status: 'degraded', error: e.message }\n    end\n  end\nend\n</code></pre>"},{"location":"transports/multi-transport/#migration-strategies","title":"Migration Strategies","text":""},{"location":"transports/multi-transport/#gradual-migration","title":"Gradual Migration","text":"<p>When migrating from one transport to another:</p> <pre><code>class MigrationMessage &lt; SmartMessage::Base\n\n  # Phase 1: Dual publishing\n  transport [\n    OldTransport.new,      # Keep existing system running\n    NewTransport.new       # Start sending to new system\n  ]\n\n  # Phase 2: Monitor and validate new system\n  # Phase 3: Remove old transport when confident\nend\n</code></pre>"},{"location":"transports/multi-transport/#blue-green-deployment","title":"Blue-Green Deployment","text":"<p>Support blue-green deployments with transport switching:</p> <pre><code>class DeploymentMessage &lt; SmartMessage::Base\n  def self.configure_for_deployment(color)\n    case color\n    when :blue\n      transport BlueEnvironmentTransport.new\n    when :green  \n      transport GreenEnvironmentTransport.new\n    when :both\n      transport [\n        BlueEnvironmentTransport.new,\n        GreenEnvironmentTransport.new\n      ]\n    end\n  end\nend\n</code></pre>"},{"location":"transports/multi-transport/#troubleshooting","title":"Troubleshooting","text":""},{"location":"transports/multi-transport/#common-issues","title":"Common Issues","text":"<p>Issue: Publishing seems slow <pre><code># Check transport order - slow transports block subsequent ones\ntransport [\n  SlowTransport.new,     # \u274c Blocks others\n  FastTransport.new      # Must wait for slow one\n]\n\n# Solution: Reorder with fastest first\ntransport [\n  FastTransport.new,     # \u2705 Completes quickly  \n  SlowTransport.new      # Others don't wait\n]\n</code></pre></p> <p>Issue: Partial failures not logged <pre><code># Ensure proper logging configuration\nSmartMessage.configure do |config|\n  config.logger.level = :debug  # Show all transport operations\nend\n</code></pre></p> <p>Issue: All transports failing unexpectedly <pre><code># Test each transport individually\nmessage.transports.each_with_index do |transport, index|\n  begin\n    transport.publish(message)\n    puts \"Transport #{index} (#{transport.class.name}): \u2705 Success\"\n  rescue =&gt; e\n    puts \"Transport #{index} (#{transport.class.name}): \u274c Failed - #{e.message}\"\n  end\nend\n</code></pre></p>"},{"location":"transports/multi-transport/#see-also","title":"See Also","text":"<ul> <li>Transport Layer Overview</li> <li>Redis Queue Transport </li> <li>Memory Transport</li> <li>Error Handling and Dead Letter Queues</li> <li>Performance Optimization</li> </ul>"},{"location":"transports/redis-transport-comparison/","title":"Transport Comparison","text":"<p>SmartMessage provides multiple transport layers, each designed for different use cases and requirements. This document provides a comprehensive comparison to help you choose the right transport for your application.</p>"},{"location":"transports/redis-transport-comparison/#transport-overview","title":"Transport Overview","text":"Transport Type Best For Key Feature Memory In-Memory Queue Testing, development No external dependencies, fast STDOUT Logging/Debug Development, debugging Human-readable output Redis Pub/Sub Production messaging Distributed, persistent connections"},{"location":"transports/redis-transport-comparison/#memory-transport","title":"\ud83e\udde0 Memory Transport","text":"<p>Perfect for development, testing, and in-memory message queuing.</p>"},{"location":"transports/redis-transport-comparison/#architecture","title":"Architecture","text":"<pre><code>Publisher \u2192 Memory Queue \u2192 Subscriber\n         (thread-safe)   (auto-processing)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Message Persistence: In-memory only - lost on restart</li> <li>Pattern Support: None - direct message class routing</li> <li>Load Balancing: No - all subscribers receive all messages</li> <li>Threading: Thread-safe with mutex protection</li> <li>External Dependencies: None</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration","title":"Configuration","text":"<pre><code>SmartMessage::Transport.create(:memory,\n  auto_process: true,     # Automatically route messages to dispatcher\n  max_messages: 1000      # Maximum messages to store in memory\n)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#use-cases","title":"Use Cases","text":"<ul> <li>Unit testing - Predictable, isolated environment</li> <li>Development - Quick setup without external services</li> <li>In-memory queuing - Fast processing without persistence</li> <li>Message inspection - Easy access to all stored messages</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros","title":"Pros","text":"<ul> <li>\u2705 No external dependencies</li> <li>\u2705 Fastest performance (no serialization)</li> <li>\u2705 Thread-safe operations</li> <li>\u2705 Message inspection capabilities</li> <li>\u2705 Memory overflow protection</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons","title":"Cons","text":"<ul> <li>\u274c Messages lost on restart</li> <li>\u274c Single-process only</li> <li>\u274c Memory usage grows with message volume</li> <li>\u274c No network distribution</li> </ul>"},{"location":"transports/redis-transport-comparison/#example","title":"Example","text":"<pre><code>class TestMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\n\n  def self.process(decoded_message)\n    puts \"Processing: #{decoded_message.data}\"\n  end\nend\n\nTestMessage.subscribe\nTestMessage.new(data: \"Hello World\").publish\n</code></pre>"},{"location":"transports/redis-transport-comparison/#stdout-transport","title":"\ud83d\udcc4 STDOUT Transport","text":"<p>Ideal for development, debugging, and logging scenarios.</p>"},{"location":"transports/redis-transport-comparison/#architecture_1","title":"Architecture","text":"<pre><code>Publisher \u2192 Console/File Output \u2192 Optional Loopback \u2192 Subscriber\n         (JSON formatting)    (if enabled)      (local processing)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics_1","title":"Key Characteristics","text":"<ul> <li>Message Persistence: File-based if output specified</li> <li>Pattern Support: None - logging/debugging focused</li> <li>Load Balancing: No - single output destination</li> <li>Threading: Thread-safe file operations</li> <li>External Dependencies: None</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration_1","title":"Configuration","text":"<pre><code>SmartMessage::Transport.create(:stdout,\n  loopback: true,                    # Process messages locally\n  output: \"messages.log\"             # Output to file instead of console\n)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#use-cases_1","title":"Use Cases","text":"<ul> <li>Development debugging - See messages in real-time</li> <li>Application logging - Structured message logging</li> <li>Message tracing - Track message flow through system</li> <li>Integration testing - Verify message content</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros_1","title":"Pros","text":"<ul> <li>\u2705 Human-readable JSON output</li> <li>\u2705 File-based persistence option</li> <li>\u2705 Optional loopback for testing</li> <li>\u2705 No external dependencies</li> <li>\u2705 Structured message formatting</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons_1","title":"Cons","text":"<ul> <li>\u274c Not suitable for production messaging</li> <li>\u274c Single output destination</li> <li>\u274c No network distribution</li> <li>\u274c Limited throughput for high-volume scenarios</li> </ul>"},{"location":"transports/redis-transport-comparison/#example_1","title":"Example","text":"<pre><code>class LogMessage &lt; SmartMessage::Base\n  property :level\n  property :message\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, \n      output: \"app.log\",\n      loopback: false\n    )\n  end\nend\n\nLogMessage.new(level: \"INFO\", message: \"Application started\").publish\n</code></pre>"},{"location":"transports/redis-transport-comparison/#redis-transport","title":"\ud83d\udd34 Redis Transport","text":"<p>Production-ready Redis pub/sub transport for distributed messaging.</p>"},{"location":"transports/redis-transport-comparison/#architecture_2","title":"Architecture","text":"<pre><code>Publisher \u2192 Redis Channel \u2192 Subscriber\n         (pub/sub)       (thread-based)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics_2","title":"Key Characteristics","text":"<ul> <li>Message Persistence: No - fire-and-forget pub/sub</li> <li>Pattern Support: None - exact channel name matching</li> <li>Load Balancing: No - all subscribers receive all messages</li> <li>Threading: Traditional thread-per-subscriber model</li> <li>External Dependencies: Redis server</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration_2","title":"Configuration","text":"<pre><code>SmartMessage::Transport.create(:redis,\n  url: 'redis://localhost:6379',    # Redis connection URL\n  db: 0,                            # Redis database number\n  auto_subscribe: true,             # Automatically start subscriber\n  reconnect_attempts: 5,            # Connection retry attempts\n  reconnect_delay: 1                # Delay between retries (seconds)\n)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#use-cases_2","title":"Use Cases","text":"<ul> <li>Production messaging - Reliable distributed messaging</li> <li>Microservices communication - Service-to-service messaging</li> <li>Real-time applications - Low-latency message delivery</li> <li>Scalable architectures - Multiple publishers and subscribers</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros_2","title":"Pros","text":"<ul> <li>\u2705 Production-ready reliability</li> <li>\u2705 Distributed messaging support</li> <li>\u2705 Automatic reconnection handling</li> <li>\u2705 Low latency (~1ms)</li> <li>\u2705 High throughput (80K+ messages/second)</li> <li>\u2705 Automatic serialization (MessagePack/JSON)</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons_2","title":"Cons","text":"<ul> <li>\u274c Requires Redis server</li> <li>\u274c No message persistence</li> <li>\u274c No pattern-based routing</li> <li>\u274c No load balancing</li> <li>\u274c All subscribers receive all messages</li> </ul>"},{"location":"transports/redis-transport-comparison/#example_2","title":"Example","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: ENV['REDIS_URL'] || 'redis://localhost:6379',\n      db: 1\n    )\n  end\n\n  def self.process(decoded_message)\n    order = decoded_message\n    puts \"Processing order #{order.order_id} for $#{order.amount}\"\n  end\nend\n\nOrderMessage.subscribe\nOrderMessage.new(\n  order_id: \"ORD-123\",\n  customer_id: \"CUST-456\",\n  amount: 99.99\n).publish\n</code></pre>"},{"location":"transports/redis-transport-comparison/#feature-comparison-matrix","title":"\ud83d\udcca Feature Comparison Matrix","text":"Feature Memory STDOUT Redis Message Persistence \u274c Memory Only \u2705 File Optional \u274c No Network Distribution \u274c No \u274c No \u2705 Yes External Dependencies \u274c None \u274c None \u2705 Redis Pattern Matching \u274c No \u274c No \u274c No Load Balancing \u274c No \u274c No \u274c No Setup Complexity Easy Easy Medium Performance (Latency) ~0.1ms ~1ms ~1ms Performance (Throughput) Highest Medium High Serialization None JSON MessagePack/JSON Thread Safety \u2705 Yes \u2705 Yes \u2705 Yes Message Inspection \u2705 Yes \u2705 Yes \u274c No Production Ready \u274c Testing Only \u274c Logging Only \u2705 Yes Horizontal Scaling \u274c No \u274c No \u2705 Yes"},{"location":"transports/redis-transport-comparison/#choosing-the-right-transport","title":"\ud83c\udfaf Choosing the Right Transport","text":""},{"location":"transports/redis-transport-comparison/#use-memory-transport-when","title":"Use Memory Transport When:","text":"<ul> <li>\u2705 You're writing unit tests</li> <li>\u2705 You're developing locally</li> <li>\u2705 You need fast, in-memory message processing</li> <li>\u2705 You want to inspect messages for testing</li> <li>\u2705 You don't need persistence or distribution</li> </ul>"},{"location":"transports/redis-transport-comparison/#use-stdout-transport-when","title":"Use STDOUT Transport When:","text":"<ul> <li>\u2705 You're debugging message flow</li> <li>\u2705 You need human-readable message logging</li> <li>\u2705 You're building development tools</li> <li>\u2705 You want to trace messages in integration tests</li> <li>\u2705 You need simple file-based message storage</li> </ul>"},{"location":"transports/redis-transport-comparison/#use-redis-transport-when","title":"Use Redis Transport When:","text":"<ul> <li>\u2705 You're building production applications</li> <li>\u2705 You need distributed messaging</li> <li>\u2705 You have microservices that need to communicate</li> <li>\u2705 You need reliable, scalable messaging</li> <li>\u2705 You can manage a Redis server dependency</li> </ul>"},{"location":"transports/redis-transport-comparison/#migration-patterns","title":"\ud83d\udd04 Migration Patterns","text":""},{"location":"transports/redis-transport-comparison/#development-production","title":"Development \u2192 Production","text":"<pre><code># Development (Memory)\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\nend\n\n# Production (Redis)\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: ENV['REDIS_URL'] || 'redis://localhost:6379'\n    )\n  end\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>class MyMessage &lt; SmartMessage::Base\n  config do\n    transport case Rails.env\n              when 'test'\n                SmartMessage::Transport.create(:memory, auto_process: true)\n              when 'development'\n                SmartMessage::Transport.create(:stdout, loopback: true)\n              when 'production'\n                SmartMessage::Transport.create(:redis, url: ENV['REDIS_URL'])\n              end\n  end\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#performance-characteristics","title":"\ud83d\udcc8 Performance Characteristics","text":""},{"location":"transports/redis-transport-comparison/#latency-comparison","title":"Latency Comparison","text":"<ul> <li>Memory: ~0.1ms (fastest, no serialization)</li> <li>STDOUT: ~1ms (JSON formatting overhead)</li> <li>Redis: ~1ms (network + serialization)</li> </ul>"},{"location":"transports/redis-transport-comparison/#throughput-comparison","title":"Throughput Comparison","text":"<ul> <li>Memory: Highest (limited by CPU and memory)</li> <li>STDOUT: Medium (limited by I/O operations)</li> <li>Redis: High (limited by network and Redis performance)</li> </ul>"},{"location":"transports/redis-transport-comparison/#memory-usage","title":"Memory Usage","text":"<ul> <li>Memory: Grows with message volume (configurable limit)</li> <li>STDOUT: Minimal (immediate output/write)</li> <li>Redis: Low (messages not stored locally)</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration-examples","title":"\ud83d\udee0\ufe0f Configuration Examples","text":""},{"location":"transports/redis-transport-comparison/#test-environment","title":"Test Environment","text":"<pre><code>SmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport.create(:memory,\n    auto_process: true,\n    max_messages: 100\n  )\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#development-environment","title":"Development Environment","text":"<pre><code>SmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport.create(:stdout,\n    loopback: true,\n    output: \"log/messages.log\"\n  )\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#production-environment","title":"Production Environment","text":"<pre><code>SmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport.create(:redis,\n    url: ENV['REDIS_URL'],\n    db: ENV['REDIS_DB']&amp;.to_i || 0,\n    reconnect_attempts: 10,\n    reconnect_delay: 2\n  )\nend\n</code></pre> <p>This comparison should help you choose the right transport for your specific use case within the SmartMessage ecosystem. Each transport is optimized for different scenarios and provides the flexibility to grow your application from development to production.</p>"},{"location":"transports/redis-transport/","title":"Redis Transport","text":"<p>The Redis Transport is the foundational Redis-based transport implementation for SmartMessage. It uses Redis pub/sub channels for message distribution and provides reliable, high-performance messaging with minimal setup.</p>"},{"location":"transports/redis-transport/#overview","title":"Overview","text":"<p>Redis Transport is perfect for: - Simple pub/sub scenarios - Basic message broadcasting - Development and testing - Quick Redis-based messaging - Legacy compatibility - Original SmartMessage Redis implementation - High performance - Direct Redis pub/sub with minimal overhead</p>"},{"location":"transports/redis-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Direct Redis Pub/Sub - Uses native Redis PUBLISH/SUBSCRIBE</li> <li>\u26a1 High Performance - ~1ms latency, 80K+ messages/second</li> <li>\ud83d\udd04 Auto-Reconnection - Automatic Redis connection recovery</li> <li>\ud83e\uddf5 Thread-Based Subscribers - Traditional thread-per-subscriber model</li> <li>\ud83c\udff7\ufe0f Simple Channel Names - Uses message class name as channel</li> <li>\ud83d\udce1 Broadcast Delivery - All subscribers receive all messages</li> </ul>"},{"location":"transports/redis-transport/#architecture","title":"Architecture","text":"<pre><code>Publisher \u2192 Redis Channel \u2192 All Subscribers\n         (class name)     (thread-based)\n</code></pre> <p>The Redis Transport uses the message class name directly as the Redis channel name. For example, <code>OrderMessage</code> publishes to the <code>OrderMessage</code> channel.</p>"},{"location":"transports/redis-transport/#configuration","title":"Configuration","text":""},{"location":"transports/redis-transport/#basic-setup","title":"Basic Setup","text":"<pre><code># Minimal configuration\ntransport = SmartMessage::Transport::RedisTransport.new\n\n# With Redis URL\ntransport = SmartMessage::Transport::RedisTransport.new(\n  url: 'redis://localhost:6379'\n)\n\n# Full configuration\ntransport = SmartMessage::Transport::RedisTransport.new(\n  url: 'redis://redis.example.com:6379',\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n</code></pre>"},{"location":"transports/redis-transport/#using-with-smartmessage","title":"Using with SmartMessage","text":"<pre><code># Configure as default transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: ENV['REDIS_URL'] || 'redis://localhost:6379'\n  )\nend\n\n# Use in message class\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_email, required: true\n\n  transport :redis\n\n  def process\n    puts \"Processing order: #{order_id} for #{customer_email}\"\n    # Business logic here\n  end\nend\n</code></pre>"},{"location":"transports/redis-transport/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>url</code> String <code>redis://localhost:6379</code> Redis connection URL <code>db</code> Integer <code>0</code> Redis database number <code>auto_subscribe</code> Boolean <code>true</code> Automatically start subscriber thread <code>reconnect_attempts</code> Integer <code>5</code> Number of reconnection attempts <code>reconnect_delay</code> Integer <code>1</code> Seconds between reconnection attempts"},{"location":"transports/redis-transport/#usage-examples","title":"Usage Examples","text":""},{"location":"transports/redis-transport/#basic-message-processing","title":"Basic Message Processing","text":"<pre><code># Define message\nclass UserNotification &lt; SmartMessage::Base\n  property :user_id, required: true\n  property :message, required: true\n  property :type, default: 'info'\n\n  def process\n    user = User.find(user_id)\n    user.notifications.create!(\n      message: message,\n      type: type\n    )\n    puts \"Notification sent to user #{user_id}: #{message}\"\n  end\nend\n\n# Publish notification\nUserNotification.new(\n  user_id: 123,\n  message: \"Your order has been shipped!\",\n  type: \"success\"\n).publish\n\n# Output: Notification sent to user 123: Your order has been shipped!\n</code></pre>"},{"location":"transports/redis-transport/#multiple-publishers-and-subscribers","title":"Multiple Publishers and Subscribers","text":"<pre><code># Publisher 1 (Web Application)\nclass OrderCreated &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :user_id, required: true\n  property :total, required: true\n\n  def process\n    # This runs on all subscribers\n    puts \"Order #{order_id} created for user #{user_id}: $#{total}\"\n  end\nend\n\n# Publisher 2 (Admin Panel)\nclass OrderCancelled &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :reason, required: true\n\n  def process\n    puts \"Order #{order_id} cancelled: #{reason}\"\n  end\nend\n\n# Both services will receive both message types\n# All subscribers get all messages - broadcast behavior\n\n# Publish from web app\nOrderCreated.new(\n  order_id: \"ORD-001\", \n  user_id: 456, \n  total: 99.99\n).publish\n\n# Publish from admin panel\nOrderCancelled.new(\n  order_id: \"ORD-002\", \n  reason: \"Customer request\"\n).publish\n</code></pre>"},{"location":"transports/redis-transport/#connection-management","title":"Connection Management","text":"<pre><code># Check connection status\ntransport = SmartMessage::Transport::RedisTransport.new\nputs \"Connected: #{transport.connected?}\"\n\n# Manual connection control\ntransport.stop_subscriber\ntransport.start_subscriber\n\n# Access Redis connections directly\npub_redis = transport.redis_pub\nsub_redis = transport.redis_sub\n\n# Test connection\nbegin\n  pub_redis.ping\n  puts \"Redis connection healthy\"\nrescue Redis::ConnectionError\n  puts \"Redis connection failed\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#error-handling","title":"Error Handling","text":"<pre><code>class ReliableMessage &lt; SmartMessage::Base\n  property :data, required: true\n\n  def process\n    begin\n      # Potentially failing operation\n      external_api_call(data)\n    rescue =&gt; e\n      logger.error \"Failed to process message: #{e.message}\"\n      # Message processing failed, but won't retry\n      # Use dead letter queue for failed messages\n    end\n  end\n\n  private\n\n  def external_api_call(data)\n    # Simulate external API call\n    raise \"API unavailable\" if rand &lt; 0.1\n    puts \"Processed: #{data}\"\n  end\nend\n\n# Publish messages - some may fail processing\n10.times do |i|\n  ReliableMessage.new(data: \"item-#{i}\").publish\nend\n</code></pre>"},{"location":"transports/redis-transport/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Latency: ~1ms average message delivery</li> <li>Throughput: 80,000+ messages/second</li> <li>Memory per Subscriber: ~1MB baseline</li> <li>Concurrent Subscribers: ~200 practical limit</li> <li>Connection Overhead: 2 Redis connections (pub + sub)</li> <li>Message Persistence: None (fire-and-forget)</li> <li>Message Ordering: No guarantees</li> </ul>"},{"location":"transports/redis-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/redis-transport/#instance-methods","title":"Instance Methods","text":""},{"location":"transports/redis-transport/#connected","title":"<code>#connected?</code>","text":"<p>Checks if Redis connections are healthy.</p> <pre><code>if transport.connected?\n  puts \"Redis transport ready\"\nelse\n  puts \"Redis transport offline\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#start_subscriber","title":"<code>#start_subscriber</code>","text":"<p>Manually starts the subscriber thread (if <code>auto_subscribe: false</code>).</p> <pre><code>transport = SmartMessage::Transport::RedisTransport.new(auto_subscribe: false)\n# ... do setup ...\ntransport.start_subscriber\n</code></pre>"},{"location":"transports/redis-transport/#stop_subscriber","title":"<code>#stop_subscriber</code>","text":"<p>Stops the subscriber thread gracefully.</p> <pre><code>transport.stop_subscriber\nputs \"Subscriber stopped\"\n</code></pre>"},{"location":"transports/redis-transport/#subscriber_running","title":"<code>#subscriber_running?</code>","text":"<p>Checks if the subscriber thread is active.</p> <pre><code>if transport.subscriber_running?\n  puts \"Actively listening for messages\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#channel-naming","title":"Channel Naming","text":"<p>Redis Transport uses simple channel naming: - Message Class: <code>OrderMessage</code> - Redis Channel: <code>\"OrderMessage\"</code> - Subscription: Exact channel name match</p> <pre><code># These all use the \"UserMessage\" channel\nclass UserMessage &lt; SmartMessage::Base\n  property :user_id\nend\n\n# Publishing\nUserMessage.new(user_id: 123).publish\n# \u2192 Publishes to Redis channel \"UserMessage\"\n\n# Subscribing  \nUserMessage.subscribe\n# \u2192 Subscribes to Redis channel \"UserMessage\"\n</code></pre>"},{"location":"transports/redis-transport/#use-cases","title":"Use Cases","text":""},{"location":"transports/redis-transport/#simple-applications","title":"Simple Applications","text":"<pre><code># Perfect for straightforward pub/sub needs\nclass SystemAlert &lt; SmartMessage::Base\n  property :level, required: true\n  property :message, required: true\n\n  def process\n    case level\n    when 'critical'\n      send_pager_alert(message)\n    when 'warning'  \n      log_warning(message)\n    else\n      log_info(message)\n    end\n  end\nend\n\nSystemAlert.new(level: 'critical', message: 'Database offline').publish\n</code></pre>"},{"location":"transports/redis-transport/#development-environment","title":"Development Environment","text":"<pre><code># config/environments/development.rb\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: 'redis://localhost:6379',\n    db: 1  # Separate dev database\n  )\n  config.logger.level = Logger::DEBUG\nend\n</code></pre>"},{"location":"transports/redis-transport/#legacy-system-integration","title":"Legacy System Integration","text":"<pre><code># Maintaining compatibility with existing Redis pub/sub systems\nclass LegacyEvent &lt; SmartMessage::Base\n  property :event_type, required: true\n  property :payload, required: true\n\n  def process\n    # Process in SmartMessage format\n    LegacyEventProcessor.new(event_type, payload).process\n  end\nend\n\n# External systems can still publish to \"LegacyEvent\" channel\n# SmartMessage will automatically process them\n</code></pre>"},{"location":"transports/redis-transport/#performance-tuning","title":"Performance Tuning","text":""},{"location":"transports/redis-transport/#connection-pooling","title":"Connection Pooling","text":"<pre><code># For high-throughput applications, consider connection pooling\nrequire 'connection_pool'\n\nredis_pool = ConnectionPool.new(size: 10) do\n  Redis.new(url: 'redis://localhost:6379')\nend\n\n# Use custom Redis instance\ntransport = SmartMessage::Transport::RedisTransport.new\ntransport.instance_variable_set(:@redis_pub, redis_pool.with { |r| r })\n</code></pre>"},{"location":"transports/redis-transport/#monitoring","title":"Monitoring","text":"<pre><code># Monitor Redis transport health\nclass HealthCheck\n  def self.redis_transport_status\n    transport = SmartMessage.configuration.default_transport\n    {\n      connected: transport.connected?,\n      subscriber_running: transport.subscriber_running?,\n      redis_info: transport.redis_pub.info\n    }\n  end\nend\n\nputs HealthCheck.redis_transport_status\n</code></pre>"},{"location":"transports/redis-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/redis-transport/#configuration_1","title":"Configuration","text":"<ul> <li>Use environment variables for Redis URLs</li> <li>Set appropriate database numbers for different environments</li> <li>Configure reasonable reconnection settings</li> </ul>"},{"location":"transports/redis-transport/#error-handling_1","title":"Error Handling","text":"<ul> <li>Implement proper error handling in message processing</li> <li>Use logging to track message failures</li> <li>Consider implementing dead letter queue pattern</li> </ul>"},{"location":"transports/redis-transport/#monitoring_1","title":"Monitoring","text":"<ul> <li>Monitor Redis connection health</li> <li>Track message throughput and processing times</li> <li>Set up alerts for subscriber thread failures</li> </ul>"},{"location":"transports/redis-transport/#testing","title":"Testing","text":"<ul> <li>Use separate Redis databases for testing</li> <li>Clear Redis data between tests</li> <li>Mock Redis for unit tests</li> </ul>"},{"location":"transports/redis-transport/#limitations","title":"Limitations","text":""},{"location":"transports/redis-transport/#no-pattern-matching","title":"No Pattern Matching","text":"<p>Redis Transport requires exact channel name matches:</p> <pre><code># This works - exact match\nOrderMessage.subscribe  # Subscribes to \"OrderMessage\"\n\n# This doesn't work - no wildcard support\n# Can't subscribe to \"Order*\" or \"*Message\"\n</code></pre>"},{"location":"transports/redis-transport/#no-message-persistence","title":"No Message Persistence","text":"<p>Messages are lost if no subscribers are listening:</p> <pre><code># If no subscribers are running, this message is lost\nOrderMessage.new(order_id: 'ORD-001').publish\n</code></pre>"},{"location":"transports/redis-transport/#broadcasting-only","title":"Broadcasting Only","text":"<p>All subscribers receive all messages:</p> <pre><code># If 3 services subscribe to OrderMessage,\n# all 3 will process every OrderMessage\n# No load balancing between subscribers\n</code></pre>"},{"location":"transports/redis-transport/#examples","title":"Examples","text":"<p>The <code>examples/redis/</code> directory contains production-ready examples demonstrating Redis Transport capabilities:</p>"},{"location":"transports/redis-transport/#iot-and-real-time-messaging","title":"IoT and Real-Time Messaging","text":"<ul> <li>01_smart_home_iot_demo.rb - Complete smart home IoT system with Redis pub/sub</li> <li>Real-time sensor data publishing (temperature, motion, battery levels)</li> <li>Device command routing with prefix-based filtering</li> <li>Alert generation and dashboard monitoring</li> <li>Multi-process distributed architecture</li> </ul>"},{"location":"transports/redis-transport/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The IoT example showcases all Redis Transport capabilities: - Direct Redis Pub/Sub - High-performance message broadcasting - Channel-Based Routing - Each message type uses dedicated channels - Device-Specific Filtering - Commands routed by device ID prefixes - Real-Time Data Flow - Continuous sensor data streaming - Multi-Process Communication - Distributed system simulation</p>"},{"location":"transports/redis-transport/#running-examples","title":"Running Examples","text":"<pre><code># Prerequisites: Start Redis server\nredis-server\n\n# Navigate to the SmartMessage directory\ncd smart_message\n\n# Run the Redis Transport IoT demo\nruby examples/redis/01_smart_home_iot_demo.rb\n\n# Monitor Redis channels during the demo\nredis-cli MONITOR\n</code></pre>"},{"location":"transports/redis-transport/#example-architecture","title":"Example Architecture","text":"<p>The IoT demo creates a complete distributed system: - 5 IoT processes - Sensors publishing data every 3-5 seconds - Dashboard process - Aggregating and displaying system status - Redis channels - <code>SensorDataMessage</code>, <code>DeviceCommandMessage</code>, <code>AlertMessage</code> - Device filtering - THERM-, CAM-, LOCK- prefix routing</p> <p>Each example includes comprehensive logging and demonstrates production-ready patterns for Redis-based messaging systems.</p>"},{"location":"transports/redis-transport/#additional-resources","title":"Additional Resources","text":"<p>For more Redis Transport examples and patterns, also see: - Memory Transport Examples - Can be adapted to Redis Transport by changing configuration - Complete Documentation - Detailed data flow analysis with SVG diagrams</p>"},{"location":"transports/redis-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Transport Overview - All available transports</li> <li>Examples &amp; Use Cases - Practical usage patterns</li> <li>Architecture Overview - How SmartMessage works</li> </ul>"}]}