{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SmartMessage Documentation","text":"SmartMessage is a powerful Ruby framework that transforms ordinary messages into intelligent, self-aware entities capable of routing themselves, validating their contents, and executing business logic. By abstracting away the complexities of transport mechanisms (Redis, RabbitMQ, Kafka) and serialization formats (JSON, MessagePack), SmartMessage lets you focus on what matters: your business logic.  Think of SmartMessage as ActiveRecord for messaging - just as ActiveRecord frees you from database-specific SQL, SmartMessage liberates your messages from transport-specific implementations. Each message knows how to validate itself, where it came from, where it's going, and what to do when it arrives. With built-in support for filtering, versioning, deduplication, and concurrent processing, SmartMessage provides enterprise-grade messaging capabilities with the simplicity Ruby developers love."},{"location":"#table-of-contents","title":"Table of Contents","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start</li> <li>Basic Usage Examples</li> </ul>"},{"location":"#core-concepts","title":"Core Concepts","text":"<ul> <li>Architecture Overview</li> <li>Property System</li> <li>Entity Addressing</li> <li>Message Filtering</li> <li>Message Processing</li> <li>Dispatcher &amp; Routing</li> </ul>"},{"location":"#transports","title":"Transports","text":"<ul> <li>Transport Layer</li> <li>Redis Queue Transport \u2b50 Featured</li> <li>Redis Transport Comparison</li> </ul>"},{"location":"#guides","title":"Guides","text":"<ul> <li>Redis Queue Getting Started</li> <li>Advanced Routing Patterns</li> <li>Production Deployment</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>Serializers</li> <li>Logging System</li> <li>Dead Letter Queue</li> <li>Message Deduplication</li> <li>Proc Handlers</li> </ul>"},{"location":"#development","title":"Development","text":"<ul> <li>Troubleshooting</li> <li>Ideas &amp; Roadmap</li> </ul>"},{"location":"#quick-navigation","title":"Quick Navigation","text":"<ul> <li>New to SmartMessage? Start with Quick Start</li> <li>Need examples? Check out Examples</li> <li>Understanding the architecture? Read Architecture Overview</li> <li>Having issues? Visit Troubleshooting</li> </ul>"},{"location":"#version","title":"Version","text":"<p>This documentation is for SmartMessage v0.0.8.</p> <p>For older versions, please check the git tags and corresponding documentation.</p>"},{"location":"core-concepts/addressing/","title":"Entity Addressing","text":"<p>SmartMessage supports entity-to-entity addressing through built-in FROM/TO/REPLY_TO fields in message headers. This enables sophisticated messaging patterns including point-to-point communication, broadcast messaging, and request-reply workflows.</p>"},{"location":"core-concepts/addressing/#overview","title":"Overview","text":"<p>Entity addressing in SmartMessage provides:</p> <ul> <li>Sender Identification: Required <code>from</code> field identifies the sending entity</li> <li>Recipient Targeting: Optional <code>to</code> field for point-to-point messaging  </li> <li>Response Routing: Optional <code>reply_to</code> field for request-reply patterns</li> <li>Broadcast Support: Omitting <code>to</code> field enables broadcast to all subscribers</li> <li>Dual-Level Configuration: Class and instance-level addressing configuration</li> </ul>"},{"location":"core-concepts/addressing/#address-fields","title":"Address Fields","text":""},{"location":"core-concepts/addressing/#from-required","title":"FROM (Required)","text":"<p>The <code>from</code> field identifies the entity sending the message. This is required for all messages.</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  from 'order-service'  # Required sender identity\n\n  property :data\nend\n</code></pre>"},{"location":"core-concepts/addressing/#to-optional","title":"TO (Optional)","text":"<p>The <code>to</code> field specifies the intended recipient entity. When present, creates point-to-point messaging. When <code>nil</code>, the message is broadcast to all subscribers.</p> <pre><code># Point-to-point messaging\nclass DirectMessage &lt; SmartMessage::Base\n  from 'sender-service'\n  to 'recipient-service'  # Specific target\n\n  property :content\nend\n\n# Broadcast messaging\nclass AnnouncementMessage &lt; SmartMessage::Base\n  from 'admin-service'\n  # No 'to' field = broadcast to all subscribers\n\n  property :announcement\nend\n</code></pre>"},{"location":"core-concepts/addressing/#reply_to-optional","title":"REPLY_TO (Optional)","text":"<p>The <code>reply_to</code> field specifies where responses should be sent. Defaults to the <code>from</code> entity if not specified.</p> <pre><code>class RequestMessage &lt; SmartMessage::Base\n  from 'client-service'\n  to 'api-service'\n  reply_to 'client-callback-service'  # Responses go here\n\n  property :request_data\nend\n</code></pre>"},{"location":"core-concepts/addressing/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"core-concepts/addressing/#class-level-configuration","title":"Class-Level Configuration","text":"<p>Set default addressing for all instances of a message class using three different approaches:</p>"},{"location":"core-concepts/addressing/#method-1-direct-class-methods","title":"Method 1: Direct Class Methods","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # Class-level addressing using direct methods\n  from 'payment-service'\n  to 'bank-gateway'\n  reply_to 'payment-service'\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n</code></pre>"},{"location":"core-concepts/addressing/#method-2-header-block-dsl","title":"Method 2: Header Block DSL","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # Class-level addressing using header block\n  header do\n    from 'payment-service'\n    to 'bank-gateway'\n    reply_to 'payment-service'\n  end\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n</code></pre>"},{"location":"core-concepts/addressing/#method-3-mixed-approach","title":"Method 3: Mixed Approach","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  version 1\n\n  # You can mix approaches if needed\n  header do\n    from 'payment-service'\n    to 'bank-gateway'\n  end\n\n  # Additional addressing outside the block\n  reply_to 'payment-service'\n\n  property :amount, required: true\n  property :account_id, required: true\nend\n\n# All instances inherit class addressing\npayment = PaymentMessage.new(amount: 100.00, account_id: \"ACCT-123\")\nputs payment._sm_header.from     # =&gt; 'payment-service'\nputs payment._sm_header.to       # =&gt; 'bank-gateway'\nputs payment._sm_header.reply_to # =&gt; 'payment-service'\n</code></pre>"},{"location":"core-concepts/addressing/#instance-level-overrides","title":"Instance-Level Overrides","text":"<p>Override addressing for specific message instances using multiple approaches:</p>"},{"location":"core-concepts/addressing/#method-chaining","title":"Method Chaining","text":"<pre><code>class FlexibleMessage &lt; SmartMessage::Base\n  header do\n    from 'service-a'\n    to 'service-b'\n  end\n\n  property :data\nend\n\n# Override addressing using method chaining\nmessage = FlexibleMessage.new(data: \"test\")\nmessage.from('different-sender')\n       .to('different-recipient')\n       .reply_to('different-reply-service')\n\nputs message.from     # =&gt; 'different-sender'\nputs message.to       # =&gt; 'different-recipient' \nputs message.reply_to # =&gt; 'different-reply-service'\n</code></pre>"},{"location":"core-concepts/addressing/#setter-methods","title":"Setter Methods","text":"<pre><code># Override addressing using setter syntax\nmessage = FlexibleMessage.new(data: \"test\")\nmessage.from = 'different-sender'\nmessage.to = 'different-recipient'\nmessage.reply_to = 'different-reply-service'\n</code></pre>"},{"location":"core-concepts/addressing/#accessing-addressing-values","title":"Accessing Addressing Values","text":"<pre><code># Three ways to access addressing values\n\n# 1. Direct shortcut methods\nputs message.from      # =&gt; 'different-sender'\nputs message.to        # =&gt; 'different-recipient'\nputs message.reply_to  # =&gt; 'different-reply-service'\n\n# 2. Via header object\nputs message._sm_header.from      # =&gt; 'different-sender'\nputs message._sm_header.to        # =&gt; 'different-recipient'\nputs message._sm_header.reply_to  # =&gt; 'different-reply-service'\n\n# 3. Class defaults remain unchanged\nputs FlexibleMessage.from # =&gt; 'service-a'\nputs FlexibleMessage.to   # =&gt; 'service-b'\n</code></pre>"},{"location":"core-concepts/addressing/#messaging-patterns","title":"Messaging Patterns","text":""},{"location":"core-concepts/addressing/#point-to-point-messaging","title":"Point-to-Point Messaging","text":"<p>Direct communication between two specific entities:</p> <pre><code>class OrderProcessingMessage &lt; SmartMessage::Base\n  from 'order-service'\n  to 'inventory-service'  # Direct target\n  reply_to 'order-service'\n\n  property :order_id, required: true\n  property :items, required: true\nend\n\n# Message goes directly to inventory-service\norder = OrderProcessingMessage.new(\n  order_id: \"ORD-123\", \n  items: [\"widget-1\", \"widget-2\"]\n)\norder.publish  # Only inventory-service receives this\n</code></pre>"},{"location":"core-concepts/addressing/#broadcast-messaging","title":"Broadcast Messaging","text":"<p>Send message to all subscribers by omitting the <code>to</code> field:</p> <pre><code>class SystemMaintenanceMessage &lt; SmartMessage::Base\n  from 'admin-service'\n  # No 'to' field = broadcast\n\n  property :message, required: true\n  property :scheduled_time, required: true\nend\n\n# Message goes to all subscribers\nmaintenance = SystemMaintenanceMessage.new(\n  message: \"System maintenance tonight at 2 AM\",\n  scheduled_time: Time.parse(\"2024-01-15 02:00:00\")\n)\nmaintenance.publish  # All subscribers receive this\n</code></pre>"},{"location":"core-concepts/addressing/#request-reply-pattern","title":"Request-Reply Pattern","text":"<p>Structured request-response communication:</p> <pre><code># Request message\nclass UserLookupRequest &lt; SmartMessage::Base\n  from 'web-service'\n  to 'user-service'\n  reply_to 'web-service'  # Responses come back here\n\n  property :user_id, required: true\n  property :request_id, required: true  # For correlation\nend\n\n# Response message  \nclass UserLookupResponse &lt; SmartMessage::Base\n  from 'user-service'\n  # 'to' will be set to the original 'reply_to' value\n\n  property :user_id, required: true\n  property :request_id, required: true  # Correlation ID\n  property :user_data\n  property :success, default: true\nend\n\n# Send request\nrequest = UserLookupRequest.new(\n  user_id: \"USER-123\",\n  request_id: SecureRandom.uuid\n)\nrequest.publish\n\n# In user-service handler:\nclass UserLookupRequest\n  def self.process(decoded_message)\n    # Process lookup...\n    user_data = UserService.find(decoded_message.user_id)\n\n    # Send response back to reply_to address\n    response = UserLookupResponse.new(\n      user_id: decoded_message.user_id,\n      request_id: decoded_message.request_id,\n      user_data: user_data\n    )\n    response.to(decoded_message._sm_header.reply_to)  # Send to original reply_to\n    response.publish\n  end\nend\n</code></pre>"},{"location":"core-concepts/addressing/#gateway-pattern","title":"Gateway Pattern","text":"<p>Forward messages between different transports/formats:</p> <pre><code>class GatewayMessage &lt; SmartMessage::Base\n  from 'gateway-service'\n\n  property :original_message\n  property :source_format\n  property :target_format\nend\n\n# Receive from one transport/format\nincoming = SomeMessage.new(data: \"from system A\")\n\n# Forward to different system with different addressing\ngateway_msg = GatewayMessage.new(\n  original_message: incoming.to_h,\n  source_format: 'json',\n  target_format: 'xml'\n)\n\n# Override transport and addressing for forwarding\ngateway_msg.config do\n  transport DifferentTransport.new\n  serializer DifferentSerializer.new\nend\ngateway_msg.to('system-b')\ngateway_msg.publish\n</code></pre>"},{"location":"core-concepts/addressing/#address-validation","title":"Address Validation","text":"<p>The <code>from</code> field is required and validated automatically:</p> <pre><code>class InvalidMessage &lt; SmartMessage::Base\n  # No 'from' specified - will fail validation\n  property :data\nend\n\nmessage = InvalidMessage.new(data: \"test\")\nmessage.publish  # Raises SmartMessage::Errors::ValidationError\n# =&gt; \"The property 'from' From entity ID is required for message routing and replies\"\n</code></pre>"},{"location":"core-concepts/addressing/#checking-address-configuration","title":"Checking Address Configuration","text":"<pre><code>class ValidatedMessage &lt; SmartMessage::Base\n  header do\n    from 'my-service'\n    to 'target-service'\n  end\n\n  property :data\nend\n\n# Class-level checks\nputs ValidatedMessage.from_configured?     # =&gt; true\nputs ValidatedMessage.to_configured?       # =&gt; true\nputs ValidatedMessage.reply_to_configured? # =&gt; false\nputs ValidatedMessage.reply_to_missing?    # =&gt; true\n\n# Instance-level checks\nmessage = ValidatedMessage.new(data: \"test\")\nputs message.from_configured?     # =&gt; true\nputs message.to_missing?          # =&gt; false\n\n# Reset addressing\nmessage.reset_from\nputs message.from_configured?     # =&gt; false\nputs message.from                 # =&gt; nil\n</code></pre>"},{"location":"core-concepts/addressing/#header-access","title":"Header Access","text":"<p>Access addressing information from message headers:</p> <pre><code>class SampleMessage &lt; SmartMessage::Base\n  # Using header block for configuration\n  header do\n    from 'sample-service'\n    to 'target-service'\n    reply_to 'callback-service'\n  end\n\n  property :content\nend\n\nmessage = SampleMessage.new(content: \"Hello\")\n\n# Access via shortcut methods (recommended)\nputs message.from      # =&gt; 'sample-service'\nputs message.to        # =&gt; 'target-service'  \nputs message.reply_to  # =&gt; 'callback-service'\n\n# Access via header object\nheader = message._sm_header\nputs header.from      # =&gt; 'sample-service'\nputs header.to        # =&gt; 'target-service'  \nputs header.reply_to  # =&gt; 'callback-service'\nputs header.uuid      # =&gt; Generated UUID\nputs header.message_class  # =&gt; 'SampleMessage'\n\n# Headers automatically sync with instance changes\nmessage.to = 'new-target'\nputs message.to           # =&gt; 'new-target'\nputs header.to            # =&gt; 'new-target' (automatically updated)\n</code></pre>"},{"location":"core-concepts/addressing/#integration-with-dispatcher","title":"Integration with Dispatcher","text":"<p>The dispatcher can use addressing metadata for advanced routing logic:</p> <pre><code># Future enhancement: Dispatcher filtering by recipient\n# dispatcher.route(message_header, payload) do |header|\n#   if header.to.nil?\n#     # Broadcast to all subscribers\n#     route_to_all_subscribers(header.message_class)\n#   else\n#     # Route only to specific recipient\n#     route_to_entity(header.to, header.message_class)\n#   end\n# end\n</code></pre>"},{"location":"core-concepts/addressing/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/addressing/#entity-naming","title":"Entity Naming","text":"<p>Use consistent, descriptive entity identifiers:</p> <pre><code># Good: Descriptive service names\nfrom 'order-management-service'\nto 'inventory-tracking-service'\nreply_to 'order-status-service'\n\n# Avoid: Generic or unclear names\nfrom 'service1'\nto 'app'\n</code></pre>"},{"location":"core-concepts/addressing/#address-consistency","title":"Address Consistency","text":"<p>Maintain consistent addressing patterns across your application:</p> <pre><code># Consistent pattern for microservices\nclass OrderMessage &lt; SmartMessage::Base\n  from 'order-service'\n  to 'fulfillment-service'\n  reply_to 'order-service'\nend\n\nclass PaymentMessage &lt; SmartMessage::Base  \n  from 'payment-service'\n  to 'billing-service'\n  reply_to 'payment-service'\nend\n</code></pre>"},{"location":"core-concepts/addressing/#gateway-configuration","title":"Gateway Configuration","text":"<p>For gateway patterns, use instance-level overrides:</p> <pre><code># Class defines default routing\nclass APIMessage &lt; SmartMessage::Base\n  from 'api-gateway'\n  to 'internal-service'\nend\n\n# Override for external routing\nmessage = APIMessage.new(data: \"external request\")\nmessage.to('external-partner-service')\nmessage.config do\n  transport ExternalTransport.new\n  serializer SecureSerializer.new\nend\nmessage.publish\n</code></pre>"},{"location":"core-concepts/addressing/#future-enhancements","title":"Future Enhancements","text":"<p>The addressing system provides the foundation for advanced features:</p> <ul> <li>Dispatcher Filtering: Route messages based on recipient targeting</li> <li>Security Integration: Entity-based authentication and authorization</li> <li>Audit Trails: Track message flow between entities</li> <li>Load Balancing: Distribute messages across entity instances</li> <li>Circuit Breakers: Per-entity failure handling</li> </ul> <p>Entity addressing enables sophisticated messaging architectures while maintaining the simplicity and flexibility that makes SmartMessage powerful.</p>"},{"location":"core-concepts/architecture/","title":"SmartMessage Architecture","text":"<p>SmartMessage follows a plugin-based architecture that cleanly separates message concerns from transport and serialization mechanisms.</p>"},{"location":"core-concepts/architecture/#design-philosophy","title":"Design Philosophy","text":"<p>SmartMessage is designed around the principle that messages should be independent of their delivery mechanism. Just as ActiveRecord abstracts database operations from business logic, SmartMessage abstracts message delivery from message content.</p>"},{"location":"core-concepts/architecture/#core-principles","title":"Core Principles","text":"<ol> <li>Separation of Concerns: Message content, transport, and serialization are independent</li> <li>Plugin Architecture: Pluggable transports and serializers</li> <li>Dual Configuration: Both class-level and instance-level configuration</li> <li>Thread Safety: Concurrent message processing with thread pools</li> <li>Gateway Support: Messages can flow between different transports/serializers</li> </ol>"},{"location":"core-concepts/architecture/#architecture-overview","title":"Architecture Overview","text":""},{"location":"core-concepts/architecture/#core-components","title":"Core Components","text":""},{"location":"core-concepts/architecture/#1-smartmessagebase","title":"1. SmartMessage::Base","text":"<p>The foundation class that all messages inherit from, built on <code>Hashie::Dash</code>.</p> <p>Key Responsibilities: - Property management and validation - Plugin configuration (transport, serializer, logger) - Message lifecycle management - Header generation and management</p> <p>Location: <code>lib/smart_message/base.rb:17-199</code></p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  description \"Handles custom message processing for my application\"\n\n  property :data\n\n  config do\n    transport MyTransport.new\n    serializer MySerializer.new\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#2-transport-layer","title":"2. Transport Layer","text":"<p>Handles message delivery and routing between systems.</p> <p>Key Responsibilities: - Message publishing and receiving - Subscription management - Connection handling - Transport-specific configuration</p> <p>Location: <code>lib/smart_message/transport/</code></p> <pre><code># Transport interface\nclass CustomTransport &lt; SmartMessage::Transport::Base\n  def do_publish(message_class, serialized_message)\n    # Send message via your transport\n  end\n\n  def subscribe(message_class, process_method, filter_options = {})\n    # Set up subscription via dispatcher\n    @dispatcher.add(message_class, process_method, filter_options)\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#3-serializer-system","title":"3. Serializer System","text":"<p>Handles encoding and decoding of message content.</p> <p>Key Responsibilities: - Message encoding (Ruby object \u2192 wire format) - Message decoding (wire format \u2192 Ruby object) - Format-specific handling</p> <p>Location: <code>lib/smart_message/serializer/</code></p> <pre><code>class CustomSerializer &lt; SmartMessage::Serializer::Base\n  def do_encode(message_instance)\n    # Convert message instance to wire format\n    # Default implementation uses message_instance.to_h\n  end\n\n  def do_decode(payload)\n    # Convert from wire format back to hash\n    # Must return hash compatible with message initialization\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#4-dispatcher","title":"4. Dispatcher","text":"<p>Routes incoming messages to appropriate handlers using concurrent processing with integrated deduplication.</p> <p>Key Responsibilities: - Message routing based on class - Thread pool management - Subscription catalog management - Handler-scoped DDQ management - Message filtering and statistics collection</p> <p>Location: <code>lib/smart_message/dispatcher.rb</code></p> <pre><code>dispatcher = SmartMessage::Dispatcher.new\ndispatcher.add(\"MyMessage\", \"MyMessage.process\")\ndispatcher.route(decoded_message)\n\n# DDQ integration is automatic when enabled\nMyMessage.enable_deduplication!\n</code></pre>"},{"location":"core-concepts/architecture/#5-deduplication-queue-ddq","title":"5. Deduplication Queue (DDQ)","text":"<p>Handler-scoped message deduplication system preventing duplicate processing.</p> <p>Key Responsibilities: - UUID-based duplicate detection - Handler isolation (each handler gets own DDQ) - Memory and Redis storage backends - O(1) performance with hybrid Array + Set data structure</p> <p>Architecture:</p> <p></p> <p>Location: <code>lib/smart_message/deduplication.rb</code>, <code>lib/smart_message/ddq/</code></p> <p>Key Features: - Handler-scoped deduplication (each handler gets its own DDQ) - UUID-based duplicate detection - Multiple storage backends (Memory, Redis) - O(1) performance with hybrid Array + Set data structure - Thread-safe operations with mutex locks</p>"},{"location":"core-concepts/architecture/#6-message-headers","title":"6. Message Headers","text":"<p>Standard metadata attached to every message with entity addressing support.</p> <p>Key Responsibilities: - Message identification (UUID) - Routing information (message class, version) - Tracking data (timestamps, process IDs) - Entity addressing (from, to, reply_to)</p> <p>Location: <code>lib/smart_message/header.rb</code></p> <pre><code>header = message._sm_header\nputs header.uuid          # \"550e8400-e29b-41d4-a716-446655440000\"\nputs header.message_class # \"MyMessage\"\nputs header.published_at  # 2025-08-17 10:30:00 UTC\nputs header.publisher_pid # 12345\nputs header.from          # \"payment-service\"\nputs header.to            # \"order-service\"\nputs header.reply_to      # \"payment-service\" (defaults to from)\nputs header.version       # 1\nputs header.serializer    # \"SmartMessage::Serializer::JSON\"\n</code></pre>"},{"location":"core-concepts/architecture/#message-lifecycle","title":"Message Lifecycle","text":""},{"location":"core-concepts/architecture/#1-definition-phase","title":"1. Definition Phase","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#2-subscription-phase","title":"2. Subscription Phase","text":"<pre><code># Basic subscription\nOrderMessage.subscribe\n\n# Subscription with filtering\nOrderMessage.subscribe(from: /^payment-.*/, to: 'order-service')\nOrderMessage.subscribe('PaymentService.process', broadcast: true)\n\n# Each subscription gets its own DDQ automatically\n# DDQ Key: \"OrderMessage:OrderMessage.process\"\n# DDQ Key: \"OrderMessage:PaymentService.process\"\n</code></pre>"},{"location":"core-concepts/architecture/#3-publishing-phase","title":"3. Publishing Phase","text":"<pre><code>order = OrderMessage.new(order_id: \"123\", amount: 99.99)\norder.from(\"order-service\").to(\"payment-service\")\norder.publish\n# 1. Creates header with UUID, timestamp, addressing\n# 2. Encodes message via serializer  \n# 3. Sends via transport\n# 4. Circuit breaker monitors for failures\n</code></pre>"},{"location":"core-concepts/architecture/#4-receiving-phase","title":"4. Receiving Phase","text":"<pre><code># Transport receives serialized message\ntransport.receive(message_class, serialized_message)\n# 1. Decodes message using class's configured serializer\n# 2. Routes decoded message to dispatcher\n# 3. Dispatcher checks DDQ for duplicates per handler\n# 4. Applies message filters (from/to/broadcast)\n# 5. Spawns thread for processing matching handlers\n# 6. Marks UUID as processed in handler's DDQ after successful processing\n</code></pre>"},{"location":"core-concepts/architecture/#5-message-handler-processing","title":"5. Message Handler Processing","text":"<p>SmartMessage supports multiple handler types, routed through the dispatcher:</p> <pre><code># Default handler (self.process method) - receives decoded message instance\ndef self.process(decoded_message)\n  order = decoded_message  # Already a fully decoded OrderMessage instance\n  fulfill_order(order)\nend\n\n# Block handler (inline processing) - receives decoded message instance\nOrderMessage.subscribe do |decoded_message|\n  quick_processing(decoded_message)\nend\n\n# Proc handler (reusable across message types) - receives decoded message instance\naudit_proc = proc do |decoded_message|\n  AuditService.log_message(decoded_message.class.name, decoded_message)\nend\nOrderMessage.subscribe(audit_proc)\n\n# Method handler (service class processing) - receives decoded message instance\nclass OrderService\n  def self.process_order(decoded_message)\n    complex_business_logic(decoded_message)\n  end\nend\nOrderMessage.subscribe(\"OrderService.process_order\")\n</code></pre> <p>Handler Routing Process: 1. Dispatcher receives decoded message instance 2. Looks up all registered handlers for message class 3. For each handler that matches filters:    - Checks DDQ for duplicates (handler-scoped)    - String handlers: Resolves to class method via constantize    - Proc handlers: Calls proc directly from registry 4. Executes handlers in parallel threads with circuit breaker protection 5. Marks UUID as processed in handler's DDQ after successful completion 6. Collects statistics and handles errors</p>"},{"location":"core-concepts/architecture/#plugin-system-architecture","title":"Plugin System Architecture","text":""},{"location":"core-concepts/architecture/#dual-level-configuration","title":"Dual-Level Configuration","text":"<p>SmartMessage supports configuration at both class and instance levels:</p> <pre><code># Class-level (default for all instances)\nclass PaymentMessage &lt; SmartMessage::Base\n  config do\n    transport ProductionTransport.new\n    serializer SecureSerializer.new\n  end\nend\n\n# Instance-level (overrides class configuration)\ntest_payment = PaymentMessage.new(amount: 1.00)\ntest_payment.config do\n  transport TestTransport.new  # Override for this instance\nend\n</code></pre> <p>This enables sophisticated gateway patterns where messages can be: - Received from one transport (e.g., RabbitMQ) - Processed with business logic - Republished to another transport (e.g., Kafka)</p>"},{"location":"core-concepts/architecture/#plugin-registration","title":"Plugin Registration","text":"<p>Transports are registered in a central registry:</p> <pre><code># Register custom transport\nSmartMessage::Transport.register(:redis, RedisTransport)\n\n# Use registered transport\nMyMessage.config do\n  transport SmartMessage::Transport.create(:redis, url: \"redis://localhost\")\nend\n</code></pre>"},{"location":"core-concepts/architecture/#thread-safety-concurrency","title":"Thread Safety &amp; Concurrency","text":""},{"location":"core-concepts/architecture/#thread-pool-management","title":"Thread Pool Management","text":"<p>The dispatcher uses <code>Concurrent::CachedThreadPool</code> for processing:</p> <pre><code># Each message processing happens in its own thread with circuit breaker protection\n@router_pool.post do\n  circuit_result = circuit(:message_processor).wrap do\n    if proc_handler?(message_processor)\n      SmartMessage::Base.call_proc_handler(message_processor, decoded_message)\n    else\n      target_class.constantize.method(class_method).call(decoded_message)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#thread-safety-considerations","title":"Thread Safety Considerations","text":"<ol> <li>Message Instances: Each message is processed in isolation</li> <li>Shared State: Avoid shared mutable state in message classes</li> <li>Statistics: Thread-safe statistics collection via <code>SimpleStats</code></li> <li>Graceful Shutdown: Automatic cleanup on process exit</li> </ol>"},{"location":"core-concepts/architecture/#monitoring-thread-pools","title":"Monitoring Thread Pools","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\nstatus = dispatcher.status\n\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\n</code></pre>"},{"location":"core-concepts/architecture/#error-handling-architecture","title":"Error Handling Architecture","text":""},{"location":"core-concepts/architecture/#exception-isolation","title":"Exception Isolation","text":"<p>Processing exceptions are isolated to prevent cascade failures:</p> <pre><code>circuit_result = circuit(:message_processor).wrap do\n  # Handler execution with circuit breaker protection\nend\n\n# Handle circuit breaker fallback responses\nif circuit_result.is_a?(Hash) &amp;&amp; circuit_result[:circuit_breaker]\n  handle_circuit_breaker_fallback(circuit_result, decoded_message, message_processor)\nend\n</code></pre>"},{"location":"core-concepts/architecture/#custom-error-types","title":"Custom Error Types","text":"<p>SmartMessage defines specific error types for different failure modes:</p> <pre><code>module SmartMessage::Errors\n  class TransportNotConfigured &lt; RuntimeError; end\n  class SerializerNotConfigured &lt; RuntimeError; end\n  class NotImplemented &lt; RuntimeError; end\n  class ReceivedMessageNotSubscribed &lt; RuntimeError; end\n  class UnknownMessageClass &lt; RuntimeError; end\n  class ValidationError &lt; RuntimeError; end\nend\n</code></pre>"},{"location":"core-concepts/architecture/#reliability-fault-tolerance","title":"Reliability &amp; Fault Tolerance","text":""},{"location":"core-concepts/architecture/#circuit-breaker-integration","title":"Circuit Breaker Integration","text":"<p>SmartMessage integrates BreakerMachines for production-grade reliability:</p> <pre><code># Circuit breakers are automatically configured for all transports\nclass MyTransport &lt; SmartMessage::Transport::Base\n  # Inherits circuit breaker configuration:\n  # - :transport_publish for publishing operations\n  # - :transport_subscribe for subscription operations\n  # - Automatic DLQ fallback for failed publishes\nend\n</code></pre> <p>Circuit Breaker States: - Closed: Normal operation, requests pass through - Open: Threshold exceeded, requests fail fast - Half-Open: Testing if service recovered</p>"},{"location":"core-concepts/architecture/#dead-letter-queue","title":"Dead Letter Queue","text":"<p>Failed messages are automatically captured in the Dead Letter Queue:</p> <pre><code># Automatic capture when circuit breaker trips\nmessage.publish  # If transport fails, goes to DLQ\n\n# Manual capture for business logic failures\ndlq = SmartMessage::DeadLetterQueue.default\ndlq.enqueue(decoded_message, error: \"Validation failed\", transport: \"manual\")\n</code></pre> <p>DLQ Architecture:</p> <p></p> <p>DLQ Features: - JSON Lines format for efficient append operations - FIFO queue operations with thread safety - Replay capabilities with transport override - Administrative tools for filtering and analysis</p>"},{"location":"core-concepts/architecture/#statistics-monitoring","title":"Statistics &amp; Monitoring","text":""},{"location":"core-concepts/architecture/#built-in-statistics","title":"Built-in Statistics","text":"<p>SmartMessage automatically collects processing statistics including DDQ metrics:</p> <pre><code># Statistics are collected for:\nSS.add(message_class, 'publish')\nSS.add(message_class, process_method, 'routed')\n\n# Access statistics\nputs SS.stat\nputs SS.get(\"MyMessage\", \"publish\")\n\n# DDQ-specific statistics\nstats = OrderMessage.ddq_stats\nputs \"DDQ utilization: #{stats[:utilization]}%\"\nputs \"Current count: #{stats[:current_count]}\"\n</code></pre>"},{"location":"core-concepts/architecture/#monitoring-points","title":"Monitoring Points","text":"<ol> <li>Message Publishing: Count of published messages per class</li> <li>Message Routing: Count of routed messages per processor</li> <li>Thread Pool: Queue length, completed tasks, running status</li> <li>Transport Status: Connection status, message counts</li> <li>DDQ Metrics: Utilization, duplicate detection rates, memory usage</li> <li>Message Filtering: Filter match rates, entity-aware routing statistics</li> </ol>"},{"location":"core-concepts/architecture/#configuration-architecture","title":"Configuration Architecture","text":""},{"location":"core-concepts/architecture/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<ol> <li>Class-level defaults: Set via <code>MyMessage.config</code></li> <li>Instance-level overrides: Set via <code>message.config</code></li> <li>Runtime configuration: Dynamic plugin switching</li> </ol>"},{"location":"core-concepts/architecture/#configuration-objects","title":"Configuration Objects","text":"<p>Configuration uses method-based DSL:</p> <pre><code>config do\n  transport MyTransport.new(option1: value1)\n  serializer MySerializer.new(option2: value2)\n  logger MyLogger.new(level: :debug)\nend\n</code></pre>"},{"location":"core-concepts/architecture/#plugin-resolution","title":"Plugin Resolution","text":"<p>When a message needs a plugin:</p> <ol> <li>Check instance-level configuration</li> <li>Fall back to class-level configuration</li> <li>Raise error if not configured</li> </ol> <pre><code>def transport\n  @transport || self.class.class_variable_get(:@@transport) || raise(Errors::TransportNotConfigured)\nrescue NameError\n  raise(Errors::TransportNotConfigured)\nend\n</code></pre> <p>This architecture provides flexibility while maintaining clear fallback behavior.</p>"},{"location":"core-concepts/dispatcher/","title":"Dispatcher &amp; Message Routing","text":"<p>The dispatcher is the heart of SmartMessage's message routing system. It manages subscriptions, routes incoming messages to appropriate handlers, and coordinates concurrent processing using thread pools.</p>"},{"location":"core-concepts/dispatcher/#overview","title":"Overview","text":"<p>The dispatcher handles: - Subscription Management: Tracking which classes want to receive which messages - Message Routing: Directing incoming messages to registered handlers - Concurrent Processing: Using thread pools for parallel message processing - Statistics Collection: Tracking message processing metrics - Error Isolation: Preventing individual message failures from affecting the system</p>"},{"location":"core-concepts/dispatcher/#core-components","title":"Core Components","text":""},{"location":"core-concepts/dispatcher/#smartmessagedispatcher","title":"SmartMessage::Dispatcher","text":"<p>Located at <code>lib/smart_message/dispatcher.rb:11-147</code>, the dispatcher is the central routing engine.</p> <p>Key Features: - Thread-safe subscription management - Concurrent message processing via <code>Concurrent::CachedThreadPool</code> - Automatic thread pool lifecycle management - Built-in statistics collection - Graceful shutdown handling</p>"},{"location":"core-concepts/dispatcher/#subscription-management","title":"Subscription Management","text":""},{"location":"core-concepts/dispatcher/#adding-subscriptions","title":"Adding Subscriptions","text":"<p>SmartMessage supports multiple subscription patterns:</p> <pre><code># 1. Default handler - uses self.process method\nMyMessage.subscribe\n# Registers \"MyMessage.process\" as the handler\n\n# 2. Custom method handler\nMyMessage.subscribe(\"MyService.handle_message\")\n# Registers \"MyService.handle_message\" as the handler\n\n# 3. Block handler (NEW!)\nhandler_id = MyMessage.subscribe do |header, payload|\n  puts \"Processing: #{JSON.parse(payload)}\"\nend\n# Registers a proc handler with generated ID like \"MyMessage.proc_abc123\"\n\n# 4. Proc handler (NEW!)\nmy_proc = proc { |header, payload| log_message(payload) }\nproc_id = MyMessage.subscribe(my_proc)\n# Registers the proc with generated ID\n\n# 5. Lambda handler (NEW!)\nmy_lambda = lambda { |header, payload| validate_message(payload) }\nlambda_id = MyMessage.subscribe(my_lambda)\n\n# Multiple handlers for the same message\nMyMessage.subscribe(\"MyMessage.audit\")\nMyMessage.subscribe(\"MyMessage.notify\")\nMyMessage.subscribe { |h,p| puts \"Quick log\" }\n# All handlers will receive the message\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-filtering-new","title":"Message Filtering (NEW!)","text":"<p>SmartMessage supports advanced message filtering using exact strings, regular expressions, or arrays for precise message routing:</p> <pre><code># Basic string filtering (exact match)\nMyMessage.subscribe(from: 'payment-service')\nMyMessage.subscribe(to: 'order-processor')\n\n# Regular expression filtering\nMyMessage.subscribe(from: /^payment-.*/)        # All payment services\nMyMessage.subscribe(to: /^(dev|staging)-.*/)    # Development environments\n\n# Array filtering (multiple options)\nMyMessage.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed exact and pattern matching\nMyMessage.subscribe(from: ['admin', /^system-.*/, 'legacy-service'])\n\n# Combined filtering\nMyMessage.subscribe(\n  from: /^admin-.*/, \n  to: ['order-service', /^fulfillment-.*/]\n)\n\n# Broadcast + directed filtering\nMyMessage.subscribe(broadcast: true, to: 'api-service')\n</code></pre>"},{"location":"core-concepts/dispatcher/#filter-types","title":"Filter Types","text":"<p>String Filters (Exact Match) <pre><code># Subscribe only to messages from specific sender\nOrderMessage.subscribe(from: 'payment-service')\n\n# Subscribe only to messages directed to specific recipient\nOrderMessage.subscribe(to: 'order-processor')\n</code></pre></p> <p>Regular Expression Filters (Pattern Match) <pre><code># Environment-based routing\nDevService.subscribe(to: /^(dev|staging)-.*/)\nProdService.subscribe(to: /^prod-.*/)\n\n# Service pattern routing\nPaymentProcessor.subscribe(from: /^payment-.*/)\nApiService.subscribe(from: /^(web|mobile|api)-.*/)\n</code></pre></p> <p>Array Filters (Multiple Options) <pre><code># Multiple specific services\nAdminService.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed patterns and exact matches\nAlertService.subscribe(from: ['admin', /^system-.*/, 'security'])\n</code></pre></p> <p>Combined Filters <pre><code># Complex multi-criteria filtering\nOrderMessage.subscribe(\n  from: /^(admin|system)-.*/, \n  to: ['order-service', /^fulfillment-.*/]\n)\n\n# Admin services to production only\nAdminMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)\n</code></pre></p>"},{"location":"core-concepts/dispatcher/#filter-validation","title":"Filter Validation","text":"<p>Filters are validated at subscription time:</p> <pre><code># Valid filters\nMyMessage.subscribe(from: 'service')           # String\nMyMessage.subscribe(from: /^service-.*/)       # Regexp  \nMyMessage.subscribe(from: ['a', /^b-.*/])      # Array of String/Regexp\n\n# Invalid filters (raise ArgumentError)\nMyMessage.subscribe(from: 123)                 # Invalid type\nMyMessage.subscribe(from: ['valid', 123])      # Invalid array element\n</code></pre>"},{"location":"core-concepts/dispatcher/#removing-subscriptions","title":"Removing Subscriptions","text":"<pre><code># Remove specific method handler\nMyMessage.unsubscribe(\"MyMessage.custom_handler\")\n\n# Remove specific proc/block handler using returned ID\nblock_id = MyMessage.subscribe { |h,p| puts p }\nMyMessage.unsubscribe(block_id)  # Cleans up proc from registry too\n\n# Remove ALL handlers for a message class\nMyMessage.unsubscribe!\n\n# Remove all subscriptions (useful for testing)\ndispatcher = SmartMessage::Dispatcher.new\ndispatcher.drop_all!\n</code></pre>"},{"location":"core-concepts/dispatcher/#viewing-subscriptions","title":"Viewing Subscriptions","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# View all subscriptions\nputs dispatcher.subscribers\n# =&gt; {\"MyMessage\" =&gt; [\"MyMessage.process\", \"MyMessage.audit\"]}\n\n# Check specific message subscriptions\nputs dispatcher.subscribers[\"MyMessage\"]\n# =&gt; [\"MyMessage.process\", \"MyMessage.audit\"]\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-routing-process","title":"Message Routing Process","text":""},{"location":"core-concepts/dispatcher/#1-message-reception","title":"1. Message Reception","text":"<p>When a transport receives a message, it calls the dispatcher:</p> <pre><code># Transport receives serialized message and routes it\ntransport.receive(message_class, serialized_message)\n# This internally decodes the message and calls:\ndispatcher.route(decoded_message)\n</code></pre>"},{"location":"core-concepts/dispatcher/#2-subscription-lookup","title":"2. Subscription Lookup","text":"<p>The dispatcher finds all registered handlers:</p> <pre><code>def route(decoded_message)\n  message_klass = decoded_message._sm_header.message_class\n  return nil if @subscribers[message_klass].empty?\n\n  @subscribers[message_klass].each do |subscription|\n    # Process each handler with filters\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#3-concurrent-processing","title":"3. Concurrent Processing","text":"<p>Each handler is processed in its own thread, with support for both method and proc handlers:</p> <pre><code>@subscribers[message_klass].each do |subscription|\n  message_processor = subscription[:process_method]\n  SS.add(message_klass, message_processor, 'routed')\n\n  @router_pool.post do\n    # This runs in a separate thread with circuit breaker protection\n    circuit_result = circuit(:message_processor).wrap do\n      # Check if this is a proc handler or a regular method call\n      if proc_handler?(message_processor)\n        # Call the proc handler via SmartMessage::Base\n        SmartMessage::Base.call_proc_handler(message_processor, decoded_message)\n      else\n        # Original method call logic\n        parts = message_processor.split('.')\n        target_klass = parts[0]  # \"MyMessage\" \n        class_method = parts[1]  # \"process\"\n\n        target_klass.constantize\n                    .method(class_method)\n                    .call(decoded_message)\n      end\n    end\n\n    # Handle circuit breaker fallback if triggered\n    if circuit_result.is_a?(Hash) &amp;&amp; circuit_result[:circuit_breaker]\n      handle_circuit_breaker_fallback(circuit_result, decoded_message, message_processor)\n    end\n  end\nend\n</code></pre> <p>Handler Types Processed: - Method handlers: <code>\"ClassName.method_name\"</code> \u2192 resolved via constantize - Proc handlers: <code>\"ClassName.proc_abc123\"</code> \u2192 looked up in proc registry - Block handlers: <code>\"ClassName.proc_def456\"</code> \u2192 treated as proc handlers - Lambda handlers: <code>\"ClassName.proc_ghi789\"</code> \u2192 treated as proc handlers</p>"},{"location":"core-concepts/dispatcher/#thread-pool-management","title":"Thread Pool Management","text":""},{"location":"core-concepts/dispatcher/#thread-pool-configuration","title":"Thread Pool Configuration","text":"<p>The dispatcher uses <code>Concurrent::CachedThreadPool</code> which automatically manages thread creation and destruction:</p> <pre><code>def initialize\n  @router_pool = Concurrent::CachedThreadPool.new\n\n  # Automatic cleanup on exit\n  at_exit do\n    shutdown_thread_pool\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#monitoring-thread-pool-status","title":"Monitoring Thread Pool Status","text":"<pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# Get comprehensive status\nstatus = dispatcher.status\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Scheduled tasks: #{status[:scheduled_task_count]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\nputs \"Current threads: #{status[:length]}\"\n\n# Individual status methods\nputs dispatcher.running?              # Is the pool active?\nputs dispatcher.queue_length          # How many tasks are waiting?\nputs dispatcher.scheduled_task_count  # Total tasks scheduled\nputs dispatcher.completed_task_count  # Total tasks completed\nputs dispatcher.current_length        # Current number of threads\n</code></pre>"},{"location":"core-concepts/dispatcher/#thread-pool-lifecycle","title":"Thread Pool Lifecycle","text":"<pre><code># Automatic shutdown handling\nat_exit do\n  print \"Shutting down the dispatcher's thread pool...\"\n  @router_pool.shutdown\n\n  while @router_pool.shuttingdown?\n    print '.'\n    sleep 1\n  end\n\n  puts \" done.\"\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-processing-patterns","title":"Message Processing Patterns","text":""},{"location":"core-concepts/dispatcher/#standard-processing","title":"Standard Processing","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :items\n\n  # Standard process method\n  def self.process(message_header, message_payload)\n    # 1. Decode the message\n    data = JSON.parse(message_payload)\n    order = new(data)\n\n    # 2. Execute business logic\n    fulfill_order(order)\n\n    # 3. Optional: publish follow-up messages\n    ShippingMessage.new(\n      order_id: order.order_id,\n      address: get_shipping_address(order.customer_id)\n    ).publish\n  end\n\n  private\n\n  def self.fulfill_order(order)\n    # Business logic here\n  end\nend\n\n# Subscribe to receive messages\nOrderMessage.subscribe\n</code></pre>"},{"location":"core-concepts/dispatcher/#multiple-handlers","title":"Multiple Handlers","text":"<pre><code>class PaymentMessage &lt; SmartMessage::Base\n  property :payment_id\n  property :amount\n  property :customer_id\n\n  # Primary payment processing\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    process_payment(payment)\n  end\n\n  # Audit logging handler\n  def self.audit(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    log_payment_attempt(payment)\n  end\n\n  # Fraud detection handler\n  def self.fraud_check(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    payment = new(data)\n\n    if suspicious_payment?(payment)\n      flag_for_review(payment)\n    end\n  end\nend\n\n# Register all handlers\nPaymentMessage.subscribe(\"PaymentMessage.process\")\nPaymentMessage.subscribe(\"PaymentMessage.audit\")\nPaymentMessage.subscribe(\"PaymentMessage.fraud_check\")\n</code></pre>"},{"location":"core-concepts/dispatcher/#error-handling-in-processors","title":"Error Handling in Processors","text":"<pre><code>class RobustMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    begin\n      data = JSON.parse(message_payload)\n      message = new(data)\n\n      # Main processing logic\n      process_business_logic(message)\n\n    rescue JSON::ParserError =&gt; e\n      # Handle malformed messages\n      log_error(\"Invalid message format\", message_header, e)\n\n    rescue BusinessLogicError =&gt; e\n      # Handle business logic failures\n      log_error(\"Business logic failed\", message_header, e)\n\n      # Optionally republish to error queue\n      ErrorMessage.new(\n        original_message: message_payload,\n        error: e.message,\n        retry_count: get_retry_count(message_header)\n      ).publish\n\n    rescue =&gt; e\n      # Handle unexpected errors\n      log_error(\"Unexpected error\", message_header, e)\n      raise  # Re-raise to trigger dispatcher error handling\n    end\n  end\n\n  private\n\n  def self.log_error(type, header, error)\n    puts \"#{type}: #{error.message}\"\n    puts \"Message class: #{header.message_class}\"\n    puts \"Message UUID: #{header.uuid}\"\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#advanced-routing-patterns","title":"Advanced Routing Patterns","text":""},{"location":"core-concepts/dispatcher/#conditional-processing","title":"Conditional Processing","text":"<pre><code>class ConditionalMessage &lt; SmartMessage::Base\n  property :environment\n  property :data\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Route based on message content\n    case message.environment\n    when 'production'\n      production_handler(message)\n    when 'staging'\n      staging_handler(message)\n    when 'development'\n      development_handler(message)\n    else\n      default_handler(message)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-transformation-and-republishing","title":"Message Transformation and Republishing","text":"<pre><code>class TransformMessage &lt; SmartMessage::Base\n  property :raw_data\n  property :format\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Transform the message\n    case message.format\n    when 'csv'\n      transformed = transform_csv(message.raw_data)\n    when 'xml'\n      transformed = transform_xml(message.raw_data)\n    else\n      transformed = message.raw_data\n    end\n\n    # Republish as a different message type\n    ProcessedMessage.new(\n      original_id: message_header.uuid,\n      processed_data: transformed,\n      processed_at: Time.now\n    ).publish\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#fan-out-processing","title":"Fan-out Processing","text":"<pre><code>class EventMessage &lt; SmartMessage::Base\n  property :event_type\n  property :user_id\n  property :data\n\n  def self.process(message_header, message_payload)\n    data = JSON.parse(message_payload)\n    event = new(data)\n\n    # Fan out to multiple specialized handlers\n    case event.event_type\n    when 'user_signup'\n      WelcomeEmailMessage.new(user_id: event.user_id).publish\n      AnalyticsMessage.new(event: 'signup', user_id: event.user_id).publish\n      AuditMessage.new(action: 'user_created', user_id: event.user_id).publish\n\n    when 'purchase'\n      InventoryMessage.new(items: event.data['items']).publish\n      ReceiptMessage.new(user_id: event.user_id, total: event.data['total']).publish\n      LoyaltyMessage.new(user_id: event.user_id, points: calculate_points(event.data)).publish\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#statistics-and-monitoring","title":"Statistics and Monitoring","text":""},{"location":"core-concepts/dispatcher/#built-in-statistics","title":"Built-in Statistics","text":"<p>The dispatcher automatically collects statistics via the <code>SimpleStats</code> (<code>SS</code>) system:</p> <pre><code># Statistics are automatically collected for:\n# - Message publishing: SS.add(message_class, 'publish')\n# - Message routing: SS.add(message_class, process_method, 'routed')\n\n# View all statistics\nputs SS.stat\n\n# Get specific statistics\npublish_count = SS.get(\"MyMessage\", \"publish\")\nprocess_count = SS.get(\"MyMessage\", \"MyMessage.process\", \"routed\")\n\n# Reset statistics\nSS.reset  # Clear all\nSS.reset(\"MyMessage\", \"publish\")  # Clear specific stat\n</code></pre>"},{"location":"core-concepts/dispatcher/#custom-monitoring","title":"Custom Monitoring","text":"<pre><code>class MonitoredMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    start_time = Time.now\n\n    begin\n      # Process the message\n      data = JSON.parse(message_payload)\n      message = new(data)\n\n      process_business_logic(message)\n\n      # Record success metrics\n      record_processing_time(Time.now - start_time)\n      increment_success_counter\n\n    rescue =&gt; e\n      # Record failure metrics\n      record_error(e)\n      increment_failure_counter\n      raise\n    end\n  end\n\n  private\n\n  def self.record_processing_time(duration)\n    SS.add(\"MonitoredMessage\", \"processing_time\", how_many: duration)\n  end\n\n  def self.increment_success_counter\n    SS.add(\"MonitoredMessage\", \"success\")\n  end\n\n  def self.increment_failure_counter\n    SS.add(\"MonitoredMessage\", \"failure\")\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#performance-considerations","title":"Performance Considerations","text":""},{"location":"core-concepts/dispatcher/#thread-pool-sizing","title":"Thread Pool Sizing","text":"<p>The <code>CachedThreadPool</code> automatically manages thread creation, but you can influence behavior:</p> <pre><code># For high-throughput scenarios, consider a custom thread pool\nclass CustomDispatcher &lt; SmartMessage::Dispatcher\n  def initialize(min_threads: 5, max_threads: 50)\n    @router_pool = Concurrent::ThreadPoolExecutor.new(\n      min_threads: min_threads,\n      max_threads: max_threads,\n      max_queue: 1000,\n      fallback_policy: :caller_runs\n    )\n\n    # Rest of initialization\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#processing-optimization","title":"Processing Optimization","text":"<pre><code>class OptimizedMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(message_header, message_payload)\n    # Parse once, use multiple times\n    data = JSON.parse(message_payload)\n    message = new(data)\n\n    # Batch operations when possible\n    batch_operations(message)\n\n    # Use connection pooling for database operations\n    connection_pool.with do |conn|\n      save_to_database(message, conn)\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#testing-dispatcher-behavior","title":"Testing Dispatcher Behavior","text":""},{"location":"core-concepts/dispatcher/#dispatcher-testing","title":"Dispatcher Testing","text":"<pre><code>RSpec.describe SmartMessage::Dispatcher do\n  let(:dispatcher) { SmartMessage::Dispatcher.new }\n\n  before do\n    dispatcher.drop_all!  # Clear subscriptions\n  end\n\n  describe \"subscription management\" do\n    it \"adds subscriptions\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n\n      expect(dispatcher.subscribers[\"TestMessage\"]).to include(\"TestMessage.process\")\n    end\n\n    it \"removes subscriptions\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n      dispatcher.drop(\"TestMessage\", \"TestMessage.process\")\n\n      expect(dispatcher.subscribers[\"TestMessage\"]).not_to include(\"TestMessage.process\")\n    end\n  end\n\n  describe \"message routing\" do\n    let(:header) { double(\"header\", message_class: \"TestMessage\") }\n    let(:payload) { '{\"data\": \"test\"}' }\n\n    before do\n      # Mock the message class\n      stub_const(\"TestMessage\", Class.new do\n        def self.process(header, payload)\n          @processed_messages ||= []\n          @processed_messages &lt;&lt; [header, payload]\n        end\n\n        def self.processed_messages\n          @processed_messages || []\n        end\n      end)\n    end\n\n    it \"routes messages to subscribers\" do\n      dispatcher.add(\"TestMessage\", \"TestMessage.process\")\n      dispatcher.route(header, payload)\n\n      # Wait for async processing\n      sleep 0.1\n\n      expect(TestMessage.processed_messages).to have(1).message\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#message-processing-testing","title":"Message Processing Testing","text":"<pre><code>RSpec.describe \"Message Processing\" do\n  let(:transport) { SmartMessage::Transport.create(:memory, auto_process: true) }\n\n  before do\n    TestMessage.config do\n      transport transport\n      serializer SmartMessage::Serializer::Json.new\n    end\n\n    TestMessage.subscribe\n  end\n\n  it \"processes published messages\" do\n    expect(TestMessage).to receive(:process).once\n\n    TestMessage.new(data: \"test\").publish\n\n    # Wait for async processing\n    sleep 0.1\n  end\nend\n</code></pre>"},{"location":"core-concepts/dispatcher/#next-steps","title":"Next Steps","text":"<ul> <li>Troubleshooting - Common dispatcher issues</li> </ul>"},{"location":"core-concepts/message-filtering/","title":"Message Filtering","text":"<p>SmartMessage provides powerful message filtering capabilities that allow subscribers to receive only messages that match specific criteria. This enables sophisticated routing patterns for microservices architectures, environment-based deployment, and fine-grained message processing control.</p>"},{"location":"core-concepts/message-filtering/#overview","title":"Overview","text":"<p>Message filtering works at the subscription level, allowing you to specify criteria that incoming messages must match before being routed to your handlers. Filters support:</p> <ul> <li>Exact string matching for precise service identification</li> <li>Regular expression patterns for flexible service groups and environments</li> <li>Arrays combining strings and regexps for complex matching scenarios</li> <li>Multi-criteria filtering using both <code>from</code> and <code>to</code> constraints</li> </ul>"},{"location":"core-concepts/message-filtering/#filter-dimensions","title":"Filter Dimensions","text":"<p>Messages can be filtered on two main dimensions:</p>"},{"location":"core-concepts/message-filtering/#from-message-sender-filtering","title":"<code>from:</code> - Message Sender Filtering","text":"<p>Filter messages based on who sent them:</p> <pre><code># Exact sender\nPaymentService.subscribe(from: 'payment-gateway')\n\n# Pattern matching for sender groups\nPaymentService.subscribe(from: /^payment-.*/)\n\n# Multiple specific senders\nAdminService.subscribe(from: ['admin', 'system', 'monitoring'])\n</code></pre>"},{"location":"core-concepts/message-filtering/#to-message-recipient-filtering","title":"<code>to:</code> - Message Recipient Filtering","text":"<p>Filter messages based on their intended recipient:</p> <pre><code># Exact recipient\nOrderService.subscribe(to: 'order-processor')\n\n# Environment-based routing\nDevService.subscribe(to: /^(dev|staging)-.*/)\nProdService.subscribe(to: /^prod-.*/)\n\n# Multiple target patterns\nApiService.subscribe(to: [/^api-.*/, /^web-.*/, 'gateway'])\n</code></pre>"},{"location":"core-concepts/message-filtering/#broadcast-broadcast-message-filtering","title":"<code>broadcast:</code> - Broadcast Message Filtering","text":"<p>Filter for broadcast messages (messages with <code>to: nil</code>):</p> <pre><code># Only broadcast messages\nNotificationService.subscribe(broadcast: true)\n\n# Broadcast OR directed messages (OR logic)\nAlertService.subscribe(broadcast: true, to: 'alert-service')\n</code></pre>"},{"location":"core-concepts/message-filtering/#filter-types","title":"Filter Types","text":""},{"location":"core-concepts/message-filtering/#string-filters-exact-match","title":"String Filters (Exact Match)","text":"<p>String filters match exactly:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  # Configure message\nend\n\n# Subscribe to messages from exactly 'payment-service'\nOrderMessage.subscribe(from: 'payment-service')\n\n# Subscribe to messages directed to exactly 'order-processor'\nOrderMessage.subscribe(to: 'order-processor')\n\n# Combined exact matching\nOrderMessage.subscribe(from: 'admin', to: 'order-service')\n</code></pre>"},{"location":"core-concepts/message-filtering/#regular-expression-filters-pattern-match","title":"Regular Expression Filters (Pattern Match)","text":"<p>Regex filters provide flexible pattern matching:</p> <pre><code># Environment-based routing\nOrderMessage.subscribe(to: /^(dev|staging)-.*/)  # dev-api, staging-worker, etc.\nOrderMessage.subscribe(to: /^prod-.*/)           # prod-api, prod-worker, etc.\n\n# Service type routing  \nOrderMessage.subscribe(from: /^payment-.*/)      # payment-gateway, payment-processor\nOrderMessage.subscribe(from: /^(api|web)-.*/)    # api-server, web-frontend\n\n# Complex patterns\nOrderMessage.subscribe(from: /^admin-(dev|staging)-.+/)  # admin-dev-panel, admin-staging-api\n</code></pre>"},{"location":"core-concepts/message-filtering/#array-filters-multiple-options","title":"Array Filters (Multiple Options)","text":"<p>Arrays allow combining exact strings and regex patterns:</p> <pre><code># Multiple exact matches\nOrderMessage.subscribe(from: ['admin', 'system', 'monitoring'])\n\n# Mixed strings and patterns\nOrderMessage.subscribe(from: [\n  'admin',              # Exact match\n  /^system-.*/, # Pattern match\n  'legacy-service'      # Another exact match\n])\n\n# Multiple patterns\nOrderMessage.subscribe(to: [\n  /^api-.*/,     # All API services  \n  /^web-.*/,     # All web services\n  'gateway'      # Plus specific gateway\n])\n</code></pre>"},{"location":"core-concepts/message-filtering/#combined-filters-multi-criteria","title":"Combined Filters (Multi-Criteria)","text":"<p>Combine <code>from</code>, <code>to</code>, and <code>broadcast</code> filters:</p> <pre><code># Admin services to production environments only\nOrderMessage.subscribe(\n  from: /^admin-.*/, \n  to: /^prod-.*/\n)\n\n# Specific senders to multiple recipient types\nOrderMessage.subscribe(\n  from: ['payment-gateway', 'billing-service'],\n  to: [/^order-.*/, /^fulfillment-.*/]\n)\n\n# Complex routing scenarios\nOrderMessage.subscribe(\n  from: /^(admin|system)-.*/,\n  to: ['critical-service', /^prod-.*/]\n)\n</code></pre>"},{"location":"core-concepts/message-filtering/#use-cases-and-patterns","title":"Use Cases and Patterns","text":""},{"location":"core-concepts/message-filtering/#environment-based-routing","title":"Environment-Based Routing","text":"<p>Route messages based on deployment environments:</p> <pre><code># Development services\nclass DevOrderProcessor &lt; SmartMessage::Base\n  # Only receive messages to dev/staging environments\n  DevOrderProcessor.subscribe(to: /^(dev|staging)-.*/)\nend\n\n# Production services  \nclass ProdOrderProcessor &lt; SmartMessage::Base\n  # Only receive messages to production environments\n  ProdOrderProcessor.subscribe(to: /^prod-.*/)\nend\n\n# Cross-environment admin tools\nclass AdminDashboard &lt; SmartMessage::Base\n  # Receive admin messages from any environment\n  AdminDashboard.subscribe(from: /^admin-.*/)\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#service-pattern-routing","title":"Service Pattern Routing","text":"<p>Route based on service naming conventions:</p> <pre><code># Payment services ecosystem\nclass PaymentProcessor &lt; SmartMessage::Base\n  # Receive from all payment-related services\n  PaymentProcessor.subscribe(from: /^payment-.*/)\nend\n\n# API layer services\nclass ApiGateway &lt; SmartMessage::Base\n  # Receive from web frontends and mobile apps\n  ApiGateway.subscribe(from: /^(web|mobile|api)-.*/)\nend\n\n# Monitoring and alerting\nclass MonitoringService &lt; SmartMessage::Base\n  # Receive from all system monitoring components\n  MonitoringService.subscribe(from: /^(system|monitor|health)-.*/)\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#administrative-and-security-routing","title":"Administrative and Security Routing","text":"<p>Route administrative and security messages:</p> <pre><code># Security monitoring\nclass SecurityService &lt; SmartMessage::Base\n  # Admin + security services + any system monitoring\n  SecurityService.subscribe(from: ['admin', /^security-.*/, /^system-monitor.*/])\nend\n\n# Audit logging\nclass AuditService &lt; SmartMessage::Base\n  # Capture all admin actions across environments\n  AuditService.subscribe(from: /^admin-.*/)\nend\n\n# Operations dashboard\nclass OpsDashboard &lt; SmartMessage::Base\n  # Operational messages + broadcasts\n  OpsDashboard.subscribe(\n    broadcast: true,\n    from: /^(ops|admin|system)-.*/\n  )\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#gateway-and-transformation-patterns","title":"Gateway and Transformation Patterns","text":"<p>Filter for message transformation and routing:</p> <pre><code># Message format gateway\nclass FormatGateway &lt; SmartMessage::Base\n  # Receive legacy format messages for transformation\n  FormatGateway.subscribe(from: ['legacy-system', /^old-.*/, 'mainframe'])\n\n  def self.process(header, payload)\n    # Transform and republish\n    transformed = transform_legacy_format(payload)\n    ModernMessage.new(transformed).publish\n  end\nend\n\n# Environment promotion gateway\nclass PromotionGateway &lt; SmartMessage::Base\n  # Receive staging-approved messages for prod promotion\n  PromotionGateway.subscribe(\n    from: /^staging-.*/, \n    to: 'promotion-queue'\n  )\n\n  def self.process(header, payload)\n    # Republish to production\n    data = JSON.parse(payload)\n    republish_to_production(data)\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#filter-validation","title":"Filter Validation","text":"<p>SmartMessage validates filter parameters at subscription time to prevent runtime errors:</p>"},{"location":"core-concepts/message-filtering/#valid-filter-types","title":"Valid Filter Types","text":"<pre><code># String filters\nMyMessage.subscribe(from: 'service-name')\n\n# Regex filters  \nMyMessage.subscribe(from: /^service-.*/)\n\n# Array filters with strings and regexes\nMyMessage.subscribe(from: ['exact-service', /^pattern-.*/, 'another-service'])\n\n# Combined filters\nMyMessage.subscribe(from: /^admin-.*/, to: ['service-a', /^prod-.*/])\n</code></pre>"},{"location":"core-concepts/message-filtering/#invalid-filter-types","title":"Invalid Filter Types","text":"<p>These will raise <code>ArgumentError</code> at subscription time:</p> <pre><code># Invalid primitive types\nMyMessage.subscribe(from: 123)                    # Numbers not allowed\nMyMessage.subscribe(from: true)                   # Booleans not allowed  \nMyMessage.subscribe(from: {key: 'value'})         # Hashes not allowed\n\n# Invalid array elements\nMyMessage.subscribe(from: ['valid', 123])         # Mixed valid/invalid\nMyMessage.subscribe(from: [/valid/, Object.new])  # Mixed valid/invalid\n</code></pre>"},{"location":"core-concepts/message-filtering/#implementation-details","title":"Implementation Details","text":""},{"location":"core-concepts/message-filtering/#filter-processing","title":"Filter Processing","text":"<p>Internally, filters are processed by the dispatcher's <code>message_matches_filters?</code> method:</p> <ol> <li>Normalization: String and Regexp values are converted to arrays</li> <li>Validation: Array elements are validated to be String or Regexp only</li> <li>Matching: For each filter array, check if message value matches any element:</li> <li>String elements: exact equality (<code>filter == value</code>)</li> <li>Regexp elements: pattern matching (<code>filter.match?(value)</code>)</li> </ol>"},{"location":"core-concepts/message-filtering/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>String matching: Very fast hash-based equality</li> <li>Regex matching: Slightly slower but still performant for typical patterns</li> <li>Array processing: Linear scan through filter array (typically small)</li> <li>Filter caching: Normalized filters are cached in subscription objects</li> </ul>"},{"location":"core-concepts/message-filtering/#memory-usage","title":"Memory Usage","text":"<ul> <li>Filter arrays are stored per subscription</li> <li>Regex objects are shared (Ruby optimizes identical regex literals)</li> <li>No dynamic regex compilation during message processing</li> </ul>"},{"location":"core-concepts/message-filtering/#testing-filtered-subscriptions","title":"Testing Filtered Subscriptions","text":""},{"location":"core-concepts/message-filtering/#basic-filter-testing","title":"Basic Filter Testing","text":"<pre><code>class FilterTest &lt; Minitest::Test\n  def setup\n    @transport = SmartMessage::Transport.create(:memory, auto_process: true)\n    TestMessage.config do\n      transport @transport\n      serializer SmartMessage::Serializer::Json.new\n    end\n    TestMessage.unsubscribe!\n  end\n\n  def test_string_filter\n    TestMessage.subscribe(from: 'payment-service')\n\n    # Should match\n    message = TestMessage.new(data: 'test')\n    message.from('payment-service')\n    message.publish\n\n    # Should not match\n    message = TestMessage.new(data: 'test')  \n    message.from('user-service')\n    message.publish\n\n    # Verify only one message was processed\n    assert_equal 1, processed_message_count\n  end\n\n  def test_regex_filter\n    TestMessage.subscribe(from: /^payment-.*/)\n\n    # Should match\n    ['payment-gateway', 'payment-processor'].each do |sender|\n      message = TestMessage.new(data: 'test')\n      message.from(sender)\n      message.publish\n    end\n\n    # Should not match\n    message = TestMessage.new(data: 'test')\n    message.from('user-service')\n    message.publish\n\n    # Verify two messages were processed\n    assert_equal 2, processed_message_count\n  end\n\n  def test_combined_filter\n    TestMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)\n\n    # Should match\n    message = TestMessage.new(data: 'test')\n    message.from('admin-panel')\n    message.to('prod-api')\n    message.publish\n\n    # Should not match (wrong from)\n    message = TestMessage.new(data: 'test')\n    message.from('user-panel')\n    message.to('prod-api')\n    message.publish\n\n    # Should not match (wrong to)\n    message = TestMessage.new(data: 'test')\n    message.from('admin-panel')\n    message.to('dev-api')\n    message.publish\n\n    # Verify only one message was processed\n    assert_equal 1, processed_message_count\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#performance-testing","title":"Performance Testing","text":"<pre><code>def test_filter_performance\n  # Setup large number of subscriptions with different filters\n  1000.times do |i|\n    TestMessage.subscribe(\"TestMessage.handler_#{i}\", from: \"service-#{i}\")\n  end\n\n  start_time = Time.now\n\n  # Publish many messages\n  100.times do |i|\n    message = TestMessage.new(data: i)\n    message.from(\"service-#{i % 10}\")  # Will match some filters\n    message.publish\n  end\n\n  processing_time = Time.now - start_time\n\n  # Verify performance is acceptable\n  assert processing_time &lt; 1.0, \"Filter processing took too long: #{processing_time}s\"\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#migration-guide","title":"Migration Guide","text":""},{"location":"core-concepts/message-filtering/#upgrading-from-string-only-filters","title":"Upgrading from String-Only Filters","text":"<p>If you're upgrading from a version that only supported string filters:</p> <pre><code># Old (still works)\nMyMessage.subscribe(from: 'exact-service')\nMyMessage.subscribe(from: ['service-a', 'service-b'])\n\n# New capabilities\nMyMessage.subscribe(from: /^service-.*/)                    # Regex patterns\nMyMessage.subscribe(from: ['exact', /^pattern-.*/])         # Mixed arrays\nMyMessage.subscribe(from: /^admin-.*/, to: /^prod-.*/)      # Combined criteria\n</code></pre>"},{"location":"core-concepts/message-filtering/#error-handling-changes","title":"Error Handling Changes","text":"<p>Previous versions may have failed silently with invalid filters. The new implementation validates at subscription time:</p> <pre><code># This will now raise ArgumentError instead of failing silently\nbegin\n  MyMessage.subscribe(from: 123)  # Invalid type\nrescue ArgumentError =&gt; e\n  puts \"Filter validation failed: #{e.message}\"\nend\n</code></pre>"},{"location":"core-concepts/message-filtering/#next-steps","title":"Next Steps","text":"<ul> <li>Dispatcher Documentation - How filtering integrates with message routing</li> <li>Entity Addressing - Understanding <code>from</code>, <code>to</code>, and <code>reply_to</code> fields  </li> <li>Examples - Complete working examples with filtering</li> </ul>"},{"location":"core-concepts/message-processing/","title":"Message Processing in SmartMessage","text":""},{"location":"core-concepts/message-processing/#understanding-the-selfprocess-method","title":"Understanding the <code>self.process</code> Method","text":"<p>The <code>self.process</code> method in SmartMessage classes serves as the default message handler. It defines what should happen when a message of that type is received by a subscriber.</p>"},{"location":"core-concepts/message-processing/#purpose-of-selfprocess","title":"Purpose of <code>self.process</code>","text":"<p>The <code>self.process</code> method defines what happens when a message is received. It's the entry point for processing incoming messages of that type.</p>"},{"location":"core-concepts/message-processing/#how-it-works","title":"How it Works","text":""},{"location":"core-concepts/message-processing/#1-message-publishing-flow","title":"1. Message Publishing Flow","text":"<pre><code># Someone publishes a message\nSensorDataMessage.new(device_id: \"THERM-001\", value: 22.5).publish\n</code></pre>"},{"location":"core-concepts/message-processing/#2-subscription-routing","title":"2. Subscription &amp; Routing","text":"<pre><code># A class subscribes to receive messages\nSensorDataMessage.subscribe  # Uses default \"SensorDataMessage.process\"\n# OR with custom method\nSensorDataMessage.subscribe(\"MyService.custom_handler\")\n</code></pre>"},{"location":"core-concepts/message-processing/#3-message-processing","title":"3. Message Processing","text":"<p>When a message arrives, the dispatcher calls the registered handler method with: - <code>message_header</code> - metadata (timestamp, UUID, message class, etc.) - <code>message_payload</code> - the serialized message data (usually JSON)</p>"},{"location":"core-concepts/message-processing/#message-handler-options","title":"Message Handler Options","text":"<p>SmartMessage supports multiple ways to handle incoming messages:</p>"},{"location":"core-concepts/message-processing/#1-default-handler-pattern-using-selfprocess","title":"1. Default Handler Pattern (using <code>self.process</code>)","text":"<pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # This gets called when a SensorDataMessage is received\n    # decoded_message is already a message instance\n    puts \"Sensor reading: #{data['value']}\"\n  end\nend\n\nSensorDataMessage.subscribe  # Uses \"SensorDataMessage.process\"\n</code></pre>"},{"location":"core-concepts/message-processing/#2-custom-method-handler-pattern","title":"2. Custom Method Handler Pattern","text":"<pre><code>class ThermostatService\n  def self.handle_sensor_data(message_header, message_payload)\n    # Custom processing logic\n    # decoded_message is already a message instance\n    adjust_temperature(data)\n  end\nend\n\nSensorDataMessage.subscribe(\"ThermostatService.handle_sensor_data\")\n</code></pre>"},{"location":"core-concepts/message-processing/#3-block-handler-pattern-new","title":"3. Block Handler Pattern (NEW)","text":"<pre><code># Subscribe with a block - perfect for simple handlers\nSensorDataMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"Temperature: #{data['value']}\u00b0C from #{data['device_id']}\"\n\n  # You can access header information too\n  puts \"Received at: #{header.published_at}\"\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#4-proclambda-handler-pattern-new","title":"4. Proc/Lambda Handler Pattern (NEW)","text":"<pre><code># Create a reusable handler\ntemperature_handler = proc do |header, payload|\n  data = JSON.parse(payload)\n  if data['value'] &gt; 30\n    puts \"\u26a0\ufe0f High temperature alert: #{data['value']}\u00b0C\"\n  end\nend\n\n# Use the proc as a handler\nSensorDataMessage.subscribe(temperature_handler)\n\n# Or use a lambda\nalert_handler = lambda do |header, payload|\n  data = JSON.parse(payload)\n  AlertService.process_sensor_data(data)\nend\n\nSensorDataMessage.subscribe(alert_handler)\n</code></pre>"},{"location":"core-concepts/message-processing/#real-example-from-iot-code","title":"Real Example from IoT Code","text":"<p>Looking at the smart home IoT example:</p> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    sensor_# decoded_message is already a message instance\n    icon = case sensor_data['device_type']\n           when 'thermostat' then '\ud83c\udf21\ufe0f'\n           when 'security_camera' then '\ud83d\udcf9'\n           when 'door_lock' then '\ud83d\udeaa'\n           end\n\n    puts \"#{icon} Sensor data: #{sensor_data['device_id']} - #{sensor_data['value']}\"\n  end\nend\n</code></pre> <p>This <code>process</code> method gets called every time a <code>SensorDataMessage</code> is published and received by a subscriber.</p>"},{"location":"core-concepts/message-processing/#message-handler-parameters","title":"Message Handler Parameters","text":""},{"location":"core-concepts/message-processing/#message_header","title":"<code>message_header</code>","text":"<p>Contains metadata about the message: <pre><code>message_header.uuid           # Unique message ID\nmessage_header.message_class  # \"SensorDataMessage\"\nmessage_header.published_at   # Timestamp when published\nmessage_header.publisher_pid  # Process ID of publisher\n</code></pre></p>"},{"location":"core-concepts/message-processing/#message_payload","title":"<code>message_payload</code>","text":"<p>The serialized message content (typically JSON): <pre><code># Example payload\n{\n  \"device_id\": \"THERM-001\",\n  \"device_type\": \"thermostat\",\n  \"value\": 22.5,\n  \"unit\": \"celsius\",\n  \"timestamp\": \"2025-08-18T10:30:00Z\"\n}\n</code></pre></p>"},{"location":"core-concepts/message-processing/#multiple-handlers-for-one-message-type","title":"Multiple Handlers for One Message Type","text":"<p>A single message type can have multiple subscribers with different handlers using any combination of the handler patterns:</p> <pre><code># Default handler for logging\nclass SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    puts \"\ud83d\udcca Sensor data logged: #{data['device_id']}\"\n  end\nend\n\n# Custom method handler for specific services\nclass ThermostatService\n  def self.handle_sensor_data(message_header, message_payload)\n    # decoded_message is already a message instance\n    return unless data['device_type'] == 'thermostat'\n    adjust_temperature(data['value'])\n  end\nend\n\n# Register all handlers - mix of different types\nSensorDataMessage.subscribe  # Uses default process method\n\nSensorDataMessage.subscribe(\"ThermostatService.handle_sensor_data\")  # Method handler\n\nSensorDataMessage.subscribe do |header, payload|  # Block handler\n  data = JSON.parse(payload)\n  if data['value'] &gt; 30\n    puts \"\ud83d\udea8 High temperature alert: #{data['value']}\u00b0C\"\n  end\nend\n\n# Proc handler for reusable logic\ndatabase_logger = proc do |header, payload|\n  data = JSON.parse(payload)\n  Database.insert(:sensor_readings, data)\nend\n\nSensorDataMessage.subscribe(database_logger)  # Proc handler\n</code></pre>"},{"location":"core-concepts/message-processing/#message-processing-lifecycle","title":"Message Processing Lifecycle","text":"<ol> <li>Message Published: <code>message.publish</code> is called</li> <li>Transport Delivery: Message is sent via configured transport (Redis, stdout, etc.)</li> <li>Dispatcher Routing: Dispatcher receives message and looks up subscribers</li> <li>Handler Execution: Each registered handler is called in its own thread</li> <li>Business Logic: Your <code>process</code> method executes the business logic</li> </ol>"},{"location":"core-concepts/message-processing/#threading-and-concurrency","title":"Threading and Concurrency","text":"<ul> <li>Each message handler runs in its own thread from the dispatcher's thread pool</li> <li>Multiple handlers for the same message run concurrently</li> <li>Handlers should be thread-safe if they access shared resources</li> </ul> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    # This runs in its own thread\n    # Be careful with shared state\n    # decoded_message is already a message instance\n\n    # Thread-safe operations\n    update_local_cache(data)\n\n    # Avoid shared mutable state without synchronization\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#error-handling-in-handlers","title":"Error Handling in Handlers","text":"<p>Handlers should include proper error handling:</p> <pre><code>class SensorDataMessage &lt; SmartMessage::Base\n  def self.process(decoded_message)\n    begin\n      # decoded_message is already a message instance\n\n      # Validate required fields\n      raise \"Missing device_id\" unless data['device_id']\n\n      # Process the message\n      process_sensor_reading(data)\n\n    rescue JSON::ParserError =&gt; e\n      logger.error \"Invalid JSON in sensor message: #{e.message}\"\n    rescue =&gt; e\n      logger.error \"Error processing sensor data: #{e.message}\"\n      # Consider dead letter queue or retry logic\n    end\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#choosing-the-right-handler-type","title":"Choosing the Right Handler Type","text":""},{"location":"core-concepts/message-processing/#when-to-use-each-handler-type","title":"When to Use Each Handler Type","text":"<p>Default <code>self.process</code> method: - Simple message types with basic processing - When you want a standard handler for the message class - Good for prototyping and simple applications</p> <p>Custom method handlers (<code>\"ClassName.method_name\"</code>): - Complex business logic that belongs in a service class - When you need testable, organized code - Handlers that need to be called from multiple places - Enterprise applications with well-defined service layers</p> <p>Block handlers (<code>subscribe do |header, payload|</code>): - Simple, one-off processing logic - Quick prototyping and experimentation - Inline filtering or formatting - When the logic is specific to the subscription point</p> <p>Proc/Lambda handlers: - Reusable handlers across multiple message types - Dynamic handler creation based on configuration - Functional programming patterns - When you need to pass handlers as parameters</p>"},{"location":"core-concepts/message-processing/#examples-of-each-use-case","title":"Examples of Each Use Case","text":"<pre><code># Default - simple logging\nclass UserEventMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    puts \"User event: #{JSON.parse(payload)['event_type']}\"\n  end\nend\n\n# Method handler - complex business logic\nclass EmailService\n  def self.send_welcome_email(header, payload)\n    user_data = JSON.parse(payload)\n    return unless user_data['event_type'] == 'user_registered'\n\n    EmailTemplate.render(:welcome, user_data)\n                 .deliver_to(user_data['email'])\n  end\nend\n\nUserEventMessage.subscribe(\"EmailService.send_welcome_email\")\n\n# Block handler - simple inline logic\nUserEventMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"\ud83c\udf89 Welcome #{data['username']}!\" if data['event_type'] == 'user_registered'\nend\n\n# Proc handler - reusable across message types\naudit_logger = proc do |header, payload|\n  AuditLog.create(\n    message_type: header.message_class,\n    timestamp: header.published_at,\n    data: payload\n  )\nend\n\nUserEventMessage.subscribe(audit_logger)\nOrderEventMessage.subscribe(audit_logger)  # Reuse the same proc\nPaymentEventMessage.subscribe(audit_logger)\n</code></pre>"},{"location":"core-concepts/message-processing/#best-practices","title":"Best Practices","text":""},{"location":"core-concepts/message-processing/#1-keep-handlers-fast","title":"1. Keep Handlers Fast","text":"<pre><code>def self.process(decoded_message)\n  # Quick validation\n  # decoded_message is already a message instance\n  return unless valid_message?(data)\n\n  # Delegate heavy work to background jobs\n  BackgroundJob.perform_async(data)\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#2-use-descriptive-handler-names","title":"2. Use Descriptive Handler Names","text":"<pre><code># Good method names\nSensorDataMessage.subscribe(\"ThermostatService.handle_temperature_reading\")\nSensorDataMessage.subscribe(\"AlertService.monitor_for_anomalies\")\n\n# Good block handlers with comments\nSensorDataMessage.subscribe do |header, payload|  # Temperature monitoring\n  data = JSON.parse(payload)\n  monitor_temperature_thresholds(data)\nend\n\n# Good proc handlers with descriptive variable names\ntemperature_validator = proc do |header, payload|\n  data = JSON.parse(payload)\n  validate_temperature_range(data)\nend\n\nSensorDataMessage.subscribe(temperature_validator)\n\n# Less clear\nSensorDataMessage.subscribe(\"Service1.method1\")\nSensorDataMessage.subscribe do |h, p|; process_stuff(p); end\n</code></pre>"},{"location":"core-concepts/message-processing/#3-filter-messages-early","title":"3. Filter Messages Early","text":"<pre><code>def self.handle_thermostat_data(message_header, message_payload)\n  # decoded_message is already a message instance\n\n  # Filter early to avoid unnecessary processing\n  return unless data['device_type'] == 'thermostat'\n  return unless data['device_id']&amp;.start_with?('THERM-')\n\n  # Process only relevant messages\n  adjust_temperature(data)\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#4-include-logging-and-monitoring","title":"4. Include Logging and Monitoring","text":"<pre><code>def self.process(decoded_message)\n  start_time = Time.now\n\n  begin\n    # decoded_message is already a message instance\n    logger.info \"Processing sensor data from #{data['device_id']}\"\n\n    # Business logic here\n    result = process_sensor_reading(data)\n\n    # Success metrics\n    duration = Time.now - start_time\n    metrics.histogram('message.processing.duration', duration)\n\n  rescue =&gt; e\n    logger.error \"Failed to process sensor data: #{e.message}\"\n    metrics.increment('message.processing.errors')\n    raise\n  end\nend\n</code></pre>"},{"location":"core-concepts/message-processing/#summary","title":"Summary","text":"<p>SmartMessage provides flexible options for handling incoming messages, from simple default handlers to sophisticated proc-based solutions.</p>"},{"location":"core-concepts/message-processing/#handler-types-summary","title":"Handler Types Summary:","text":"<ol> <li>Default Handler (<code>self.process</code>): Built-in method for basic message processing</li> <li>Method Handler (<code>\"Class.method\"</code>): Organized, testable handlers in service classes  </li> <li>Block Handler (<code>subscribe do |h,p|</code>): Inline logic perfect for simple processing</li> <li>Proc Handler (<code>subscribe(proc {...})</code>): Reusable, composable handlers</li> </ol>"},{"location":"core-concepts/message-processing/#key-points","title":"Key Points:","text":"<ul> <li>Flexibility: Choose the right handler type for your use case</li> <li>Parameters: All handlers receive <code>(message_header, message_payload)</code></li> <li>Payload: Usually JSON that needs to be parsed back into Ruby objects  </li> <li>Multiple Handlers: One message type can have multiple subscribers with different handler types</li> <li>Threading: Each handler runs in its own thread via the dispatcher's thread pool</li> <li>Error Handling: Include proper error handling for production reliability</li> <li>Unsubscription: All handler types can be unsubscribed using their returned identifiers</li> </ul>"},{"location":"core-concepts/message-processing/#return-values","title":"Return Values:","text":"<p>The <code>subscribe</code> method always returns a string identifier that can be used for unsubscription:</p> <pre><code># All of these return identifiers for unsubscription\ndefault_id = MyMessage.subscribe\nmethod_id = MyMessage.subscribe(\"Service.handle\")\nblock_id = MyMessage.subscribe { |h,p| puts p }\nproc_id = MyMessage.subscribe(my_proc)\n\n# Unsubscribe any handler type\nMyMessage.unsubscribe(block_id)\nMyMessage.unsubscribe(proc_id)\n</code></pre> <p>This enhanced subscription system provides the foundation for building sophisticated, event-driven applications while maintaining simplicity for basic use cases.</p>"},{"location":"core-concepts/properties/","title":"SmartMessage Property System","text":"<p>The SmartMessage property system builds on Hashie::Dash to provide a robust, declarative way to define message attributes. This document covers all available property options and features.</p>"},{"location":"core-concepts/properties/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Basic Property Definition</li> <li>Schema Versioning</li> <li>Class-Level Description</li> <li>Property Options</li> <li>Accessing Property Information</li> <li>Hashie Extensions</li> <li>Examples</li> </ul>"},{"location":"core-concepts/properties/#basic-property-definition","title":"Basic Property Definition","text":"<p>Properties are defined using the <code>property</code> method in your message class:</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  property :field_name\nend\n</code></pre>"},{"location":"core-concepts/properties/#schema-versioning","title":"Schema Versioning","text":"<p>SmartMessage supports schema versioning to enable message evolution while maintaining compatibility:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  version 2  # Declare schema version\n\n  property :order_id, required: true\n  property :customer_email  # Added in version 2\nend\n</code></pre>"},{"location":"core-concepts/properties/#version-management","title":"Version Management","text":"<pre><code># Version 1 message\nclass V1OrderMessage &lt; SmartMessage::Base\n  version 1  # or omit for default version 1\n\n  property :order_id, required: true\n  property :amount, required: true\nend\n\n# Version 2 message with additional field\nclass V2OrderMessage &lt; SmartMessage::Base\n  version 2\n\n  property :order_id, required: true\n  property :amount, required: true\n  property :customer_email  # New in version 2\nend\n\n# Version 3 message with validation\nclass V3OrderMessage &lt; SmartMessage::Base\n  version 3\n\n  property :order_id, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(String) &amp;&amp; v.length &gt; 0 }\n\n  property :amount, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(Numeric) &amp;&amp; v &gt; 0 }\n\n  property :customer_email,\n    validate: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\nend\n</code></pre>"},{"location":"core-concepts/properties/#version-validation","title":"Version Validation","text":"<p>The framework automatically validates version compatibility:</p> <pre><code>message = V2OrderMessage.new(order_id: \"123\", amount: 99.99)\n# Header automatically gets version: 2\n\n# Version validation happens automatically\nmessage.validate!  # Validates message + header + version compatibility\n\n# Manual version validation\nmessage.validate_header_version!  # Checks header version matches class version\n\n# Check version information\nV2OrderMessage.version                    # =&gt; 2\nV2OrderMessage.expected_header_version    # =&gt; 2\nmessage._sm_header.version               # =&gt; 2\n</code></pre>"},{"location":"core-concepts/properties/#version-evolution-patterns","title":"Version Evolution Patterns","text":"<pre><code># Pattern 1: Additive changes (safe)\nclass UserMessageV1 &lt; SmartMessage::Base\n  version 1\n  property :user_id, required: true\n  property :name, required: true\nend\n\nclass UserMessageV2 &lt; SmartMessage::Base\n  version 2\n  property :user_id, required: true\n  property :name, required: true\n  property :email  # Optional addition - backward compatible\nend\n\n# Pattern 2: Field validation evolution\nclass ProductMessageV1 &lt; SmartMessage::Base\n  version 1\n  property :product_id, required: true\n  property :price, required: true\nend\n\nclass ProductMessageV2 &lt; SmartMessage::Base\n  version 2\n  property :product_id, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(String) &amp;&amp; v.match?(/\\APROD-\\d+\\z/) }\n\n  property :price, \n    required: true,\n    validate: -&gt;(v) { v.is_a?(Numeric) &amp;&amp; v &gt; 0 }\nend\n</code></pre>"},{"location":"core-concepts/properties/#class-level-description","title":"Class-Level Description","text":"<p>In addition to property-level descriptions, you can add a description for the entire message class using the <code>description</code> DSL method:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Handles order processing and fulfillment workflow\"\n\n  property :order_id, description: \"Unique order identifier\"\n  property :amount, description: \"Total amount in cents\"\nend\n\n# Access the class description\nOrderMessage.description  # =&gt; \"Handles order processing and fulfillment workflow\"\n\n# Instance access to class description\norder = OrderMessage.new(order_id: \"123\", amount: 9999)\norder.description  # =&gt; \"Handles order processing and fulfillment workflow\"\n</code></pre>"},{"location":"core-concepts/properties/#setting-descriptions","title":"Setting Descriptions","text":"<p>Class descriptions can be set in multiple ways:</p> <pre><code># 1. During class definition\nclass PaymentMessage &lt; SmartMessage::Base\n  description \"Processes payment transactions\"\n  property :payment_id\nend\n\n# 2. After class definition\nclass RefundMessage &lt; SmartMessage::Base\n  property :refund_id\nend\nRefundMessage.description \"Handles payment refunds and reversals\"\n\n# 3. Within config block\nclass NotificationMessage &lt; SmartMessage::Base\n  config do\n    description \"Sends notifications to users\"\n    transport MyTransport.new\n    serializer MySerializer.new\n  end\nend\n</code></pre>"},{"location":"core-concepts/properties/#default-descriptions","title":"Default Descriptions","text":"<p>Classes without explicit descriptions automatically receive a default description:</p> <pre><code>class MyMessage &lt; SmartMessage::Base\n  property :data\nend\n\nMyMessage.description  # =&gt; \"MyMessage is a SmartMessage\"\n\n# This applies to all unnamed message classes\nclass SomeModule::ComplexMessage &lt; SmartMessage::Base\n  property :info\nend\n\nSomeModule::ComplexMessage.description  \n# =&gt; \"SomeModule::ComplexMessage is a SmartMessage\"\n</code></pre>"},{"location":"core-concepts/properties/#use-cases","title":"Use Cases","text":"<p>Class descriptions are useful for: - Documenting the overall purpose of a message class - Providing context for code generation tools - Integration with documentation systems - API documentation generation - Dynamic message introspection in gateway applications</p>"},{"location":"core-concepts/properties/#important-notes","title":"Important Notes","text":"<ul> <li>Class descriptions are not inherited by subclasses - each class maintains its own description</li> <li>Setting a description to <code>nil</code> will revert to the default description</li> <li>Descriptions are stored as strings and can include multiline content</li> <li>Both class and instance methods are available to access descriptions</li> </ul>"},{"location":"core-concepts/properties/#property-options","title":"Property Options","text":"<p>SmartMessage supports all Hashie::Dash property options plus additional features:</p>"},{"location":"core-concepts/properties/#1-default-values","title":"1. Default Values","text":"<p>Specify a default value for a property when not provided during initialization:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  # Static default\n  property :status, default: 'pending'\n\n  # Dynamic default using a Proc\n  property :created_at, default: -&gt; { Time.now }\n\n  # Default array\n  property :items, default: []\nend\n\norder = OrderMessage.new\norder.status     # =&gt; 'pending'\norder.created_at # =&gt; Current time\norder.items      # =&gt; []\n</code></pre>"},{"location":"core-concepts/properties/#2-required-properties","title":"2. Required Properties","text":"<p>Mark properties as required to ensure they're provided during initialization:</p> <pre><code>class PaymentMessage &lt; SmartMessage::Base\n  property :payment_id, required: true\n  property :amount, required: true\n  property :note  # Optional\nend\n\n# This raises ArgumentError: The property 'payment_id' is required\nPaymentMessage.new(amount: 100)\n\n# This works\nPaymentMessage.new(payment_id: 'PAY-123', amount: 100)\n</code></pre>"},{"location":"core-concepts/properties/#3-property-transformation","title":"3. Property Transformation","text":"<p>Transform property values when they're set:</p> <pre><code>class UserMessage &lt; SmartMessage::Base\n  property :email, transform_with: -&gt;(v) { v.to_s.downcase }\n  property :name, transform_with: -&gt;(v) { v.to_s.strip.capitalize }\n  property :tags, transform_with: -&gt;(v) { Array(v).map(&amp;:to_s) }\nend\n\nuser = UserMessage.new(\n  email: 'USER@EXAMPLE.COM',\n  name: '  john  ',\n  tags: 'admin'\n)\n\nuser.email # =&gt; 'user@example.com'\nuser.name  # =&gt; 'John'\nuser.tags  # =&gt; ['admin']\n</code></pre>"},{"location":"core-concepts/properties/#4-property-translation-from-hashieextensionsdashpropertytranslation","title":"4. Property Translation (from Hashie::Extensions::Dash::PropertyTranslation)","text":"<p>Map external field names to internal property names:</p> <pre><code>class ApiMessage &lt; SmartMessage::Base\n  property :user_id, from: :userId\n  property :order_date, from: 'orderDate'\n  property :total_amount, from: [:totalAmount, :total, :amount]\nend\n\n# All of these work\nmsg1 = ApiMessage.new(userId: 123)\nmsg2 = ApiMessage.new(user_id: 123)\nmsg3 = ApiMessage.new('orderDate' =&gt; '2024-01-01')\nmsg4 = ApiMessage.new(totalAmount: 100)  # or total: 100, or amount: 100\n\nmsg1.user_id # =&gt; 123\n</code></pre>"},{"location":"core-concepts/properties/#5-type-coercion-from-hashieextensionscoercion","title":"5. Type Coercion (from Hashie::Extensions::Coercion)","text":"<p>Automatically coerce property values to specific types:</p> <pre><code>class TypedMessage &lt; SmartMessage::Base\n  property :count\n  property :price\n  property :active\n  property :tags\n  property :metadata\n\n  coerce_key :count, Integer\n  coerce_key :price, Float\n  coerce_key :active, -&gt;(v) { v.to_s.downcase == 'true' }\n  coerce_key :tags, Array[String]\n  coerce_key :metadata, Hash\nend\n\nmsg = TypedMessage.new(\n  count: '42',\n  price: '19.99',\n  active: 'yes',\n  tags: 'important',\n  metadata: nil\n)\n\nmsg.count    # =&gt; 42 (Integer)\nmsg.price    # =&gt; 19.99 (Float)\nmsg.active   # =&gt; false (Boolean logic)\nmsg.tags     # =&gt; ['important'] (Array)\nmsg.metadata # =&gt; {} (Hash)\n</code></pre>"},{"location":"core-concepts/properties/#6-property-validation-smartmessage-enhancement","title":"6. Property Validation (SmartMessage Enhancement)","text":"<p>Add custom validation logic to ensure data integrity:</p> <pre><code>class ValidatedMessage &lt; SmartMessage::Base\n  # Lambda validation\n  property :age,\n           validate: -&gt;(v) { v.is_a?(Integer) &amp;&amp; v.between?(1, 120) },\n           validation_message: \"Age must be an integer between 1 and 120\"\n\n  # Regex validation for email\n  property :email,\n           validate: /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i,\n           validation_message: \"Must be a valid email address\"\n\n  # Array inclusion validation\n  property :status,\n           validate: ['active', 'inactive', 'pending'],\n           validation_message: \"Status must be active, inactive, or pending\"\n\n  # Range validation\n  property :score,\n           validate: (0..100),\n           validation_message: \"Score must be between 0 and 100\"\n\n  # Class type validation\n  property :created_at,\n           validate: Time,\n           validation_message: \"Must be a Time object\"\n\n  # Symbol method validation\n  property :username,\n           validate: :valid_username?,\n           validation_message: \"Username contains invalid characters\"\n\n  private\n\n  def valid_username?(value)\n    value.to_s.match?(/\\A[a-zA-Z0-9_]+\\z/)\n  end\nend\n\n# Validation usage\nmessage = ValidatedMessage.new(age: 25, email: \"test@example.com\")\n\n# Validate entire message\nmessage.validate!           # Raises SmartMessage::Errors::ValidationError on failure\nmessage.valid?              # Returns true/false\n\n# Get validation errors\nerrors = message.validation_errors\nerrors.each do |error|\n  puts \"#{error[:property]}: #{error[:message]}\"\nend\n</code></pre>"},{"location":"core-concepts/properties/#7-property-descriptions-smartmessage-enhancement","title":"7. Property Descriptions (SmartMessage Enhancement)","text":"<p>Add human-readable descriptions to document your properties for dynamic LLM integration:</p> <pre><code>class DocumentedMessage &lt; SmartMessage::Base\n  property :transaction_id,\n           required: true,\n           description: \"Unique identifier for the transaction\"\n\n  property :amount,\n           transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n           description: \"Transaction amount in the smallest currency unit\"\n\n  property :currency,\n           default: 'USD',\n           description: \"ISO 4217 currency code\"\n\n  property :status,\n           default: 'pending',\n           description: \"Current transaction status: pending, completed, failed\"\n\n  property :metadata,\n           default: {},\n           description: \"Additional transaction metadata as key-value pairs\"\nend\n\n# Access descriptions programmatically\nDocumentedMessage.property_description(:amount)\n# =&gt; \"Transaction amount in the smallest currency unit\"\n\nDocumentedMessage.property_descriptions\n# =&gt; {\n#      transaction_id: \"Unique identifier for the transaction\",\n#      amount: \"Transaction amount in the smallest currency unit\",\n#      currency: \"ISO 4217 currency code\",\n#      status: \"Current transaction status: pending, completed, failed\",\n#      metadata: \"Additional transaction metadata as key-value pairs\"\n#    }\n\nDocumentedMessage.described_properties\n# =&gt; [:transaction_id, :amount, :currency, :status, :metadata]\n</code></pre>"},{"location":"core-concepts/properties/#accessing-property-information","title":"Accessing Property Information","text":"<p>SmartMessage provides several methods to introspect properties:</p> <pre><code>class IntrospectionExample &lt; SmartMessage::Base\n  property :id, required: true, description: \"Unique identifier\"\n  property :name, description: \"Display name\"\n  property :created_at, default: -&gt; { Time.now }\n  property :tags\nend\n\n# Instance methods\ninstance = IntrospectionExample.new(id: 1, name: \"Test\")\ninstance.fields  # =&gt; Set[:id, :name, :created_at, :tags]\ninstance.to_h    # =&gt; Hash of all properties and values\n\n# Class methods\nIntrospectionExample.fields              # =&gt; Set[:id, :name, :created_at, :tags]\nIntrospectionExample.property_descriptions  # =&gt; Hash of descriptions\nIntrospectionExample.described_properties   # =&gt; [:id, :name]\n</code></pre>"},{"location":"core-concepts/properties/#hashie-extensions","title":"Hashie Extensions","text":"<p>SmartMessage::Base automatically includes these Hashie extensions:</p>"},{"location":"core-concepts/properties/#1-deepmerge","title":"1. DeepMerge","text":"<p>Allows deep merging of nested hash properties:</p> <pre><code>msg = MyMessage.new(config: { a: 1, b: { c: 2 } })\nmsg.deep_merge(config: { b: { d: 3 } })\n# =&gt; config: { a: 1, b: { c: 2, d: 3 } }\n</code></pre>"},{"location":"core-concepts/properties/#2-ignoreundeclared","title":"2. IgnoreUndeclared","text":"<p>Silently ignores properties that haven't been declared:</p> <pre><code># Won't raise an error for unknown properties\nmsg = MyMessage.new(known: 'value', unknown: 'ignored')\n</code></pre>"},{"location":"core-concepts/properties/#3-indifferentaccess","title":"3. IndifferentAccess","text":"<p>Access properties with strings or symbols:</p> <pre><code>msg = MyMessage.new('name' =&gt; 'John')\nmsg[:name]    # =&gt; 'John'\nmsg['name']   # =&gt; 'John'\nmsg.name      # =&gt; 'John'\n</code></pre>"},{"location":"core-concepts/properties/#4-methodaccess","title":"4. MethodAccess","text":"<p>Access properties as methods:</p> <pre><code>msg = MyMessage.new(name: 'John')\nmsg.name         # =&gt; 'John'\nmsg.name = 'Jane'\nmsg.name         # =&gt; 'Jane'\n</code></pre>"},{"location":"core-concepts/properties/#5-mergeinitializer","title":"5. MergeInitializer","text":"<p>Allows initializing with merged hash values:</p> <pre><code>defaults = { status: 'active', retries: 3 }\nmsg = MyMessage.new(defaults.merge(status: 'pending'))\n# =&gt; status: 'pending', retries: 3\n</code></pre>"},{"location":"core-concepts/properties/#examples","title":"Examples","text":""},{"location":"core-concepts/properties/#complete-example-order-processing-message","title":"Complete Example: Order Processing Message","text":"<pre><code>class OrderProcessingMessage &lt; SmartMessage::Base\n  description \"Manages the complete order lifecycle from placement to delivery\"\n\n  # Required fields with descriptions\n  property :order_id,\n           required: true,\n           description: \"Unique order identifier from the ordering system\"\n\n  property :customer_id,\n           required: true,\n           description: \"Customer who placed the order\"\n\n  # Amount with transformation and description\n  property :total_amount,\n           transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n           description: \"Total order amount including tax and shipping\"\n\n  # Status with default and validation description\n  property :status,\n           default: 'pending',\n           description: \"Order status: pending, processing, shipped, delivered, cancelled\"\n\n  # Items with coercion\n  property :items,\n           default: [],\n           description: \"Array of order line items\"\n\n  # Timestamps with dynamic defaults\n  property :created_at,\n           default: -&gt; { Time.now },\n           description: \"When the order was created\"\n\n  property :updated_at,\n           default: -&gt; { Time.now },\n           description: \"Last modification timestamp\"\n\n  # Optional fields\n  property :notes,\n           description: \"Optional order notes or special instructions\"\n\n  property :shipping_address,\n           description: \"Shipping address as a nested hash\"\n\n  # Field translation for external APIs\n  property :external_ref,\n           from: [:externalReference, :ext_ref],\n           description: \"Reference ID from external system\"\nend\n\n# Usage\norder = OrderProcessingMessage.new(\n  order_id: 'ORD-2024-001',\n  customer_id: 'CUST-123',\n  total_amount: '149.99',\n  items: [\n    { sku: 'WIDGET-A', quantity: 2, price: 49.99 },\n    { sku: 'WIDGET-B', quantity: 1, price: 50.01 }\n  ],\n  shipping_address: {\n    street: '123 Main St',\n    city: 'Springfield',\n    state: 'IL',\n    zip: '62701'\n  },\n  externalReference: 'EXT-789'  # Note: uses translated field name\n)\n\n# Access properties\norder.order_id         # =&gt; 'ORD-2024-001'\norder.total_amount     # =&gt; BigDecimal('149.99')\norder.status           # =&gt; 'pending' (default)\norder.external_ref     # =&gt; 'EXT-789' (translated)\norder.created_at       # =&gt; Time object\n\n# Get class and property information\nOrderProcessingMessage.description\n# =&gt; \"Manages the complete order lifecycle from placement to delivery\"\n\nOrderProcessingMessage.property_description(:total_amount)\n# =&gt; \"Total order amount including tax and shipping\"\n\nOrderProcessingMessage.property_descriptions.keys\n# =&gt; [:order_id, :customer_id, :total_amount, :status, :items, ...]\n</code></pre>"},{"location":"core-concepts/properties/#example-api-integration-message","title":"Example: API Integration Message","text":"<pre><code>class ApiWebhookMessage &lt; SmartMessage::Base\n  # Handle different API naming conventions\n  property :event_type,\n           from: [:eventType, :event, :type],\n           required: true,\n           description: \"Type of webhook event\"\n\n  property :payload,\n           required: true,\n           description: \"Event payload data\"\n\n  property :timestamp,\n           from: [:timestamp, :created_at, :occurredAt],\n           transform_with: -&gt;(v) { Time.parse(v.to_s) },\n           description: \"When the event occurred\"\n\n  property :retry_count,\n           from: :retryCount,\n           default: 0,\n           transform_with: -&gt;(v) { v.to_i },\n           description: \"Number of delivery attempts\"\n\n  property :signature,\n           description: \"HMAC signature for webhook validation\"\nend\n\n# Can initialize with various field names\nwebhook1 = ApiWebhookMessage.new(\n  eventType: 'order.completed',\n  payload: { order_id: 123 },\n  occurredAt: '2024-01-01T10:00:00Z',\n  retryCount: '2'\n)\n\nwebhook2 = ApiWebhookMessage.new(\n  type: 'order.completed',        # Alternative field name\n  payload: { order_id: 123 },\n  timestamp: Time.now,             # Alternative field name\n  retry_count: 2                   # Internal field name\n)\n</code></pre>"},{"location":"core-concepts/properties/#best-practices","title":"Best Practices","text":"<ol> <li>Always add descriptions to document the purpose and format of each property</li> <li>Use required properties for fields that must be present for valid messages</li> <li>Provide sensible defaults for optional fields to reduce boilerplate</li> <li>Use transformations to ensure data consistency and type safety</li> <li>Leverage field translation when integrating with external APIs that use different naming conventions</li> <li>Document valid values in descriptions for enum-like fields (e.g., status fields)</li> <li>Use type coercion for fields that may come from untrusted sources (like HTTP parameters)</li> </ol>"},{"location":"core-concepts/properties/#property-option-compatibility","title":"Property Option Compatibility","text":"<p>Multiple options can be combined on a single property:</p> <pre><code>property :amount,\n         required: true,\n         from: [:amount, :total, :value],\n         transform_with: -&gt;(v) { BigDecimal(v.to_s) },\n         description: \"Transaction amount in cents\"\n</code></pre> <p>The processing order is: 1. Field translation (from) 2. Default value (if not provided) 3. Required validation 4. Type coercion 5. Transformation 6. Value assignment</p>"},{"location":"core-concepts/properties/#limitations","title":"Limitations","text":"<ul> <li>Property names must be valid Ruby method names</li> <li>The <code>_sm_</code> prefix is reserved for internal SmartMessage properties</li> <li>Descriptions are metadata only and don't affect runtime behavior</li> <li>Some Hashie options may conflict if used incorrectly (e.g., required with default)</li> </ul>"},{"location":"development/ideas/","title":"Ideas to Think About","text":"<p>This document analyzes potential enhancements to SmartMessage based on a comparison between the current implementation and an idealized vision of intelligent messaging.</p>"},{"location":"development/ideas/#current-state-vs-vision","title":"Current State vs. Vision","text":"<p>A description was provided that envisioned SmartMessage as an advanced, intelligent messaging system. While the current implementation is solid and well-designed, there are significant opportunities for enhancement to move toward that vision.</p>"},{"location":"development/ideas/#what-currently-matches","title":"What Currently Matches:","text":"<p>\u2705 Message abstraction from transport mechanisms - The gem does abstract messages from their delivery systems</p> <p>\u2705 Pluggable architecture - Supports different transports and serializers</p> <p>\u2705 Multiple messaging patterns - Can handle 1-to-1, 1-to-many scenarios through subscription patterns</p> <p>\u2705 Error handling - Basic error isolation in the dispatcher</p>"},{"location":"development/ideas/#major-enhancement-opportunities","title":"Major Enhancement Opportunities:","text":"<p>The following features were described in the vision but are not currently implemented:</p>"},{"location":"development/ideas/#1-autonomous-self-publishing","title":"1. Autonomous Self-Publishing","text":"<p>Vision: Messages autonomously publish themselves based on predefined triggers Current: Messages require explicit <code>.publish</code> calls Potential Implementation: <pre><code>class SmartMessage::Base\n  # Add trigger-based publishing\n  def self.publish_on(event_type, condition = nil, &amp;block)\n    @auto_publish_triggers ||= []\n    @auto_publish_triggers &lt;&lt; {\n      event: event_type,\n      condition: condition || block,\n      target: self\n    }\n  end\n\n  # Monitor system events and auto-publish when triggered\n  def self.check_triggers(event_data)\n    @auto_publish_triggers&amp;.each do |trigger|\n      if trigger[:condition].call(event_data)\n        new(event_data).publish\n      end\n    end\n  end\nend\n\n# Usage example:\nclass OrderStatusUpdate &lt; SmartMessage::Base\n  property :order_id\n  property :status\n\n  # Automatically publish when order status changes\n  publish_on(:order_status_changed) do |event|\n    event[:status] == 'shipped'\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#2-dynamic-content-transformation","title":"2. Dynamic Content Transformation","text":"<p>Vision: On-the-fly format conversion for different subscribers Current: One serializer per message class Potential Implementation: <pre><code>class SmartMessage::Dispatcher\n  # Route with format transformation\n  def route_with_transformation(message_header, message_payload)\n    @subscribers[message_header.message_class].each do |processor|\n      # Get subscriber's preferred format\n      preferred_format = get_subscriber_format(processor)\n\n      # Transform if needed\n      if preferred_format != message_header.format\n        transformed_payload = transform_format(\n          message_payload,\n          from: message_header.format,\n          to: preferred_format\n        )\n        route_to_processor(processor, message_header, transformed_payload)\n      else\n        route_to_processor(processor, message_header, message_payload)\n      end\n    end\n  end\n\n  private\n\n  def transform_format(payload, from:, to:)\n    # Convert between formats (JSON -&gt; XML, XML -&gt; MessagePack, etc.)\n    case [from, to]\n    when ['json', 'xml']\n      json_to_xml(payload)\n    when ['xml', 'json']\n      xml_to_json(payload)\n    # Add more transformations as needed\n    end\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#3-contextual-awareness-and-routing-intelligence","title":"3. Contextual Awareness and Routing Intelligence","text":"<p>Vision: Intelligent routing based on context and subscriber relevance Current: Simple class-name-based dispatch Potential Implementation: <pre><code>class SmartMessage::IntelligentDispatcher &lt; SmartMessage::Dispatcher\n  def initialize\n    super\n    @subscriber_profiles = {}\n    @routing_intelligence = RoutingIntelligence.new\n  end\n\n  def subscribe_with_profile(message_class, processor, profile: {})\n    super(message_class, processor)\n    @subscriber_profiles[processor] = profile\n  end\n\n  def route(message_header, message_payload)\n    # Analyze message content\n    message_context = analyze_message_context(message_payload)\n\n    # Find relevant subscribers based on context\n    relevant_subscribers = find_relevant_subscribers(\n      message_header.message_class,\n      message_context\n    )\n\n    # Route only to relevant subscribers\n    relevant_subscribers.each do |processor|\n      route_to_processor(processor, message_header, message_payload)\n    end\n  end\n\n  private\n\n  def find_relevant_subscribers(message_class, context)\n    candidates = @subscribers[message_class] || []\n\n    candidates.select do |processor|\n      profile = @subscriber_profiles[processor]\n      @routing_intelligence.is_relevant?(context, profile)\n    end\n  end\nend\n\n# Usage:\ndispatcher.subscribe_with_profile(\n  \"OrderMessage\",\n  \"FulfillmentService.process\",\n  profile: {\n    interests: ['physical_goods'],\n    regions: ['US', 'CA'],\n    order_value_min: 100\n  }\n)\n</code></pre></p>"},{"location":"development/ideas/#4-feedback-mechanisms","title":"4. Feedback Mechanisms","text":"<p>Vision: Collect feedback from subscribers for continuous improvement Current: No feedback system Potential Implementation: <pre><code>class SmartMessage::Base\n  def self.process_with_feedback(message_header, message_payload)\n    start_time = Time.now\n\n    begin\n      result = process_without_feedback(message_header, message_payload)\n\n      # Collect success feedback\n      SmartMessage::FeedbackCollector.record_success(\n        processor: \"#{self}.process\",\n        message_class: message_header.message_class,\n        processing_time: Time.now - start_time,\n        result_quality: evaluate_result_quality(result)\n      )\n\n      result\n    rescue =&gt; e\n      # Collect failure feedback\n      SmartMessage::FeedbackCollector.record_failure(\n        processor: \"#{self}.process\",\n        message_class: message_header.message_class,\n        error: e,\n        processing_time: Time.now - start_time\n      )\n      raise\n    end\n  end\n\n  alias_method :process_without_feedback, :process\n  alias_method :process, :process_with_feedback\nend\n\nmodule SmartMessage::FeedbackCollector\n  def self.record_success(processor:, message_class:, processing_time:, result_quality:)\n    # Store feedback for analysis\n    feedback_store.record({\n      type: 'success',\n      processor: processor,\n      message_class: message_class,\n      processing_time: processing_time,\n      result_quality: result_quality,\n      timestamp: Time.now\n    })\n  end\n\n  def self.analyze_processor_performance(processor)\n    # Analyze collected feedback to provide insights\n    feedback_store.analyze(processor)\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#5-security-features","title":"5. Security Features","text":"<p>Vision: Built-in encryption and authentication Current: No security features Potential Implementation: <pre><code>class SmartMessage::SecureTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @encryption_key = options[:encryption_key]\n    @auth_provider = options[:auth_provider]\n  end\n\n  def publish(message_header, message_payload)\n    # Authenticate sender\n    unless @auth_provider.authenticate(message_header.publisher_pid)\n      raise SmartMessage::Errors::AuthenticationFailed\n    end\n\n    # Encrypt payload\n    encrypted_payload = encrypt_payload(message_payload)\n\n    # Add security metadata to header\n    secure_header = message_header.dup\n    secure_header.encrypted = true\n    secure_header.encryption_algorithm = 'AES-256-GCM'\n\n    super(secure_header, encrypted_payload)\n  end\n\n  protected\n\n  def receive(message_header, message_payload)\n    # Decrypt if needed\n    if message_header.encrypted\n      decrypted_payload = decrypt_payload(message_payload)\n      super(message_header, decrypted_payload)\n    else\n      super\n    end\n  end\n\n  private\n\n  def encrypt_payload(payload)\n    # Implement encryption logic\n  end\n\n  def decrypt_payload(encrypted_payload)\n    # Implement decryption logic\n  end\nend\n</code></pre></p>"},{"location":"development/ideas/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"development/ideas/#phase-1-foundation-enhancements","title":"Phase 1: Foundation Enhancements","text":"<ol> <li>Enhanced Statistics System - More detailed metrics collection</li> <li>Message Tracing - Correlation IDs and message flow tracking</li> <li>Improved Error Handling - Retry mechanisms and dead letter queues</li> <li>Configuration Management - More sophisticated configuration options</li> </ol>"},{"location":"development/ideas/#phase-2-intelligence-features","title":"Phase 2: Intelligence Features","text":"<ol> <li>Content Analysis - Message content classification and tagging</li> <li>Routing Intelligence - Context-aware subscriber matching</li> <li>Performance Optimization - Adaptive processing based on load</li> <li>Feedback Collection - Basic subscriber feedback mechanisms</li> </ol>"},{"location":"development/ideas/#phase-3-advanced-features","title":"Phase 3: Advanced Features","text":"<ol> <li>Dynamic Transformation - Format conversion between subscribers</li> <li>Autonomous Publishing - Event-driven message creation</li> <li>Security Layer - Encryption and authentication</li> <li>Machine Learning Integration - Predictive routing and optimization</li> </ol>"},{"location":"development/ideas/#phase-4-enterprise-features","title":"Phase 4: Enterprise Features","text":"<ol> <li>Distributed Processing - Multi-node message handling</li> <li>Advanced Analytics - Message flow analysis and optimization</li> <li>Integration APIs - Easy integration with existing systems</li> <li>Management Console - Web-based monitoring and configuration</li> </ol>"},{"location":"development/ideas/#technical-considerations","title":"Technical Considerations","text":""},{"location":"development/ideas/#architecture-changes-needed","title":"Architecture Changes Needed","text":"<ol> <li>Plugin System Enhancement - More sophisticated plugin architecture</li> <li>Event System - System-wide event broadcasting for triggers</li> <li>Metadata Framework - Rich message and subscriber metadata</li> <li>Processing Pipeline - Configurable message processing stages</li> </ol>"},{"location":"development/ideas/#performance-implications","title":"Performance Implications","text":"<ol> <li>Intelligence Overhead - Balance between smart features and performance</li> <li>Memory Usage - Feedback collection and context storage</li> <li>Processing Complexity - Multiple transformation and routing steps</li> <li>Scalability - Ensure enhancements don't impact horizontal scaling</li> </ol>"},{"location":"development/ideas/#backward-compatibility","title":"Backward Compatibility","text":"<ol> <li>Gradual Migration - All enhancements should be optional</li> <li>API Stability - Maintain existing API while adding new features</li> <li>Configuration Migration - Smooth upgrade path for existing installations</li> <li>Testing Strategy - Comprehensive testing for both old and new features</li> </ol>"},{"location":"development/ideas/#current-strengths-to-preserve","title":"Current Strengths to Preserve","text":"<p>The existing SmartMessage implementation has several strengths that should be maintained:</p> <ol> <li>Simplicity - Easy to understand and use</li> <li>Solid Architecture - Well-designed plugin system and separation of concerns</li> <li>Thread Safety - Proper concurrent processing</li> <li>Flexibility - Support for custom transports and serializers</li> <li>Testing - Good test coverage and patterns</li> </ol>"},{"location":"development/ideas/#conclusion","title":"Conclusion","text":"<p>While the current SmartMessage implementation is solid and functional, there's significant potential to evolve it toward a more intelligent messaging system. The key is to implement these enhancements gradually while preserving the simplicity and reliability that make the current system valuable.</p> <p>The vision of autonomous, context-aware messaging is achievable, but it requires careful planning to ensure that added intelligence doesn't compromise the system's core strengths of simplicity and reliability.</p>"},{"location":"development/troubleshooting/","title":"Troubleshooting Guide","text":"<p>This guide helps you diagnose and solve common issues when working with SmartMessage.</p>"},{"location":"development/troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"development/troubleshooting/#1-messages-not-being-processed","title":"1. Messages Not Being Processed","text":"<p>Symptoms: - Messages are published but process methods are never called - No errors are thrown - Statistics show messages published but not routed</p> <p>Possible Causes &amp; Solutions:</p>"},{"location":"development/troubleshooting/#missing-subscription","title":"Missing Subscription","text":"<pre><code># Problem: Forgot to subscribe\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(header, payload)\n    puts \"Processing message\"\n  end\nend\n\nMyMessage.new(data: \"test\").publish  # Nothing happens\n\n# Solution: Add subscription\nMyMessage.subscribe\nMyMessage.new(data: \"test\").publish  # Now it works\n</code></pre>"},{"location":"development/troubleshooting/#transport-not-configured-for-loopback","title":"Transport Not Configured for Loopback","text":"<pre><code># Problem: Using STDOUT without loopback\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)  # No loopback\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# Solution: Enable loopback for local testing\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#auto-process-disabled","title":"Auto-process Disabled","text":"<pre><code># Problem: Memory transport with auto_process disabled\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: false)\n  end\nend\n\n# Messages are stored but not processed\ntransport = MyMessage.transport\nputs transport.message_count  # Shows stored messages\n\n# Solution: Enable auto_process or manually process\nMyMessage.config do\n  transport SmartMessage::Transport.create(:memory, auto_process: true)\nend\n\n# Or manually trigger processing\ntransport.process_all\n</code></pre>"},{"location":"development/troubleshooting/#2-serialization-errors","title":"2. Serialization Errors","text":"<p>Symptoms: - <code>SmartMessage::Errors::SerializerNotConfigured</code> exceptions - Encoding/decoding failures - Malformed message data</p> <p>Solutions:</p>"},{"location":"development/troubleshooting/#missing-serializer-configuration","title":"Missing Serializer Configuration","text":"<pre><code># Problem: No serializer configured\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    # Missing serializer!\n  end\nend\n\n# Throws: SmartMessage::Errors::SerializerNotConfigured\nMyMessage.new(data: \"test\").publish\n\n# Solution: Add serializer\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#json-encoding-issues","title":"JSON Encoding Issues","text":"<pre><code># Problem: Objects that can't be serialized to JSON\nclass ProblematicMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# This will fail\nmessage = ProblematicMessage.new(data: Object.new)\nmessage.publish  # JSON::GeneratorError\n\n# Solution: Ensure data is JSON-serializable\nmessage = ProblematicMessage.new(data: { key: \"value\" })\nmessage.publish  # Works fine\n\n# Or implement custom serialization\nclass SafeMessage &lt; SmartMessage::Base\n  property :data\n\n  def to_h\n    hash = super\n    hash[:data] = hash[:data].to_s if hash[:data]\n    hash\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#3-transport-configuration-issues","title":"3. Transport Configuration Issues","text":"<p>Symptoms: - <code>SmartMessage::Errors::TransportNotConfigured</code> exceptions - Connection failures - Messages not being sent</p> <p>Solutions:</p>"},{"location":"development/troubleshooting/#missing-transport-configuration","title":"Missing Transport Configuration","text":"<pre><code># Problem: No transport configured\nclass MyMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    serializer SmartMessage::Serializer::Json.new\n    # Missing transport!\n  end\nend\n\nMyMessage.new(data: \"test\").publish  # Throws TransportNotConfigured\n\n# Solution: Add transport\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#transport-connection-issues","title":"Transport Connection Issues","text":"<pre><code># For custom transports that might fail to connect\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport CustomTransport.new(host: \"unreachable-host\")\n  end\nend\n\n# Check transport status\ntransport = MyMessage.transport\nputs \"Connected: #{transport.connected?}\"\n\n# Solution: Verify connection settings\nclass MyMessage &lt; SmartMessage::Base\n  config do\n    transport CustomTransport.new(\n      host: \"localhost\",\n      port: 5672,\n      retry_attempts: 3\n    )\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#4-thread-pool-issues","title":"4. Thread Pool Issues","text":"<p>Symptoms: - Messages processed very slowly - Application hangs on exit - High memory usage</p> <p>Debugging Thread Pool:</p> <pre><code>dispatcher = SmartMessage::Dispatcher.new\n\n# Check thread pool status\nstatus = dispatcher.status\nputs \"Running: #{status[:running]}\"\nputs \"Queue length: #{status[:queue_length]}\"\nputs \"Scheduled tasks: #{status[:scheduled_task_count]}\"\nputs \"Completed tasks: #{status[:completed_task_count]}\"\nputs \"Pool size: #{status[:length]}\"\n\n# If queue is growing, messages are being created faster than processed\nif status[:queue_length] &gt; 100\n  puts \"\u26a0\ufe0f  Large queue detected - consider optimizing message processing\"\nend\n\n# If pool is not running\nunless status[:running]\n  puts \"\u274c Thread pool is not running - check for shutdown issues\"\nend\n</code></pre> <p>Solutions:</p>"},{"location":"development/troubleshooting/#slow-message-processing","title":"Slow Message Processing","text":"<pre><code># Problem: Slow process method blocking thread pool\nclass SlowMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    sleep(10)  # Very slow operation\n    # Processing logic\n  end\nend\n\n# Solution: Optimize or use background jobs\nclass OptimizedMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    # Quick validation\n    data = JSON.parse(payload)\n\n    # Delegate heavy work to background job\n    BackgroundJob.perform_async(data)\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#application-hanging-on-exit","title":"Application Hanging on Exit","text":"<pre><code># Problem: Threads not shutting down gracefully\n# The dispatcher handles this automatically, but if you create custom threads:\n\nclass CustomMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    # Problem: Creating non-daemon threads\n    Thread.new do\n      loop do\n        # Long-running work\n        sleep(1)\n      end\n    end\n  end\nend\n\n# Solution: Use daemon threads or proper cleanup\nclass BetterMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    thread = Thread.new do\n      loop do\n        break if Thread.current[:stop_requested]\n        # Work with interruption points\n        sleep(1)\n      end\n    end\n\n    # Register cleanup\n    at_exit do\n      thread[:stop_requested] = true\n      thread.join(5)  # Wait up to 5 seconds\n    end\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#5-memory-issues","title":"5. Memory Issues","text":"<p>Symptoms: - Increasing memory usage over time - Out of memory errors - Slow performance</p> <p>Debugging Memory Usage:</p> <pre><code># Check message storage in memory transport\ntransport = SmartMessage::Transport.create(:memory)\nputs \"Stored messages: #{transport.message_count}\"\nputs \"Max messages: #{transport.instance_variable_get(:@options)[:max_messages]}\"\n\n# Check statistics storage\nputs \"Statistics entries: #{SS.stat.keys.length}\"\n\n# Monitor object creation\nclass MemoryMonitorMessage &lt; SmartMessage::Base\n  def self.process(header, payload)\n    puts \"Objects before: #{ObjectSpace.count_objects[:TOTAL]}\"\n\n    # Your processing logic\n    data = JSON.parse(payload)\n\n    puts \"Objects after: #{ObjectSpace.count_objects[:TOTAL]}\"\n  end\nend\n</code></pre> <p>Solutions:</p>"},{"location":"development/troubleshooting/#memory-transport-overflow","title":"Memory Transport Overflow","text":"<pre><code># Problem: Memory transport storing too many messages\ntransport = SmartMessage::Transport.create(:memory, max_messages: 10000)\n\n# Monitor and clean up\ndef cleanup_memory_transport(transport)\n  if transport.message_count &gt; 5000\n    puts \"Cleaning up old messages...\"\n    transport.clear_messages\n  end\nend\n\n# Or use smaller limits\ntransport = SmartMessage::Transport.create(:memory, max_messages: 100)\n</code></pre>"},{"location":"development/troubleshooting/#statistics-memory-growth","title":"Statistics Memory Growth","text":"<pre><code># Problem: Statistics growing without bounds\n# Check current statistics size\nputs \"Statistics size: #{SS.stat.size}\"\n\n# Solution: Periodic cleanup\ndef cleanup_statistics\n  # Keep only recent statistics\n  current_stats = SS.stat\n  important_stats = current_stats.select do |key, value|\n    # Keep publish counts and recent routing stats\n    key.include?('publish') || value &gt; 0\n  end\n\n  SS.reset\n  important_stats.each { |key, value| SS.add(*key.split('+'), how_many: value) }\nend\n\n# Run cleanup periodically\nThread.new do\n  loop do\n    sleep(3600)  # Every hour\n    cleanup_statistics\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#6-debugging-message-flow","title":"6. Debugging Message Flow","text":"<p>Enable Debug Logging:</p> <pre><code># Add debug output to your message classes\nclass DebugMessage &lt; SmartMessage::Base\n  property :data\n\n  def publish\n    puts \"\ud83d\ude80 Publishing #{self.class.name}: #{self.to_h}\"\n    super\n  end\n\n  def self.process(header, payload)\n    puts \"\ud83d\udce5 Processing #{header.message_class}: #{payload}\"\n\n    # Your processing logic\n    data = JSON.parse(payload)\n    message = new(data)\n\n    puts \"\u2705 Processed #{header.message_class}: #{message.data}\"\n  end\nend\n</code></pre> <p>Trace Message Path:</p> <pre><code># Add correlation IDs for tracing\nclass TrackedMessage &lt; SmartMessage::Base\n  property :data\n  property :correlation_id, default: -&gt; { SecureRandom.uuid }\n\n  def publish\n    puts \"[#{correlation_id}] Publishing message\"\n    super\n  end\n\n  def self.process(header, payload)\n    data = JSON.parse(payload)\n    message = new(data)\n\n    puts \"[#{message.correlation_id}] Processing message\"\n\n    # Your logic here\n\n    puts \"[#{message.correlation_id}] Processing complete\"\n  end\nend\n</code></pre> <p>Check Statistics:</p> <pre><code># Monitor message flow with statistics\ndef print_message_stats(message_class)\n  class_name = message_class.to_s\n  published = SS.get(class_name, 'publish')\n  routed = SS.get(class_name, \"#{class_name}.process\", 'routed')\n\n  puts \"#{class_name} Statistics:\"\n  puts \"  Published: #{published}\"\n  puts \"  Routed: #{routed}\"\n  puts \"  Success rate: #{routed.to_f / published * 100}%\" if published &gt; 0\nend\n\n# Usage\nprint_message_stats(MyMessage)\n</code></pre>"},{"location":"development/troubleshooting/#7-configuration-issues","title":"7. Configuration Issues","text":"<p>Debug Configuration:</p> <pre><code># Check current configuration\ndef debug_message_config(message_class)\n  puts \"#{message_class} Configuration:\"\n  puts \"  Transport: #{message_class.transport.class.name}\"\n  puts \"  Transport configured: #{message_class.transport_configured?}\"\n  puts \"  Serializer: #{message_class.serializer.class.name}\"\n  puts \"  Serializer configured: #{message_class.serializer_configured?}\"\n\n  # Check instance-level overrides\n  instance = message_class.new\n  puts \"  Instance transport: #{instance.transport.class.name}\"\n  puts \"  Instance serializer: #{instance.serializer.class.name}\"\nend\n\ndebug_message_config(MyMessage)\n</code></pre> <p>Reset Configuration:</p> <pre><code># If configuration gets corrupted, reset it\nclass MyMessage &lt; SmartMessage::Base\n  # Reset all configuration\n  reset_transport\n  reset_serializer\n  reset_logger\n\n  # Reconfigure\n  config do\n    transport SmartMessage::Transport.create(:memory)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"development/troubleshooting/#performance-troubleshooting","title":"Performance Troubleshooting","text":""},{"location":"development/troubleshooting/#slow-message-processing_1","title":"Slow Message Processing","text":"<pre><code># Benchmark message processing\nrequire 'benchmark'\n\ndef benchmark_message_processing(message_class, count = 100)\n  time = Benchmark.measure do\n    count.times do |i|\n      message_class.new(data: \"test #{i}\").publish\n    end\n\n    # Wait for processing to complete\n    sleep(1)\n  end\n\n  puts \"Processed #{count} messages in #{time.real.round(2)} seconds\"\n  puts \"Rate: #{(count / time.real).round(2)} messages/second\"\nend\n\nbenchmark_message_processing(MyMessage, 1000)\n</code></pre>"},{"location":"development/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<pre><code># Monitor memory during message processing\ndef monitor_memory_usage\n  require 'objspace'\n\n  initial_memory = ObjectSpace.count_objects[:TOTAL]\n\n  # Process some messages\n  100.times { |i| MyMessage.new(data: \"test #{i}\").publish }\n\n  # Force garbage collection\n  GC.start\n\n  final_memory = ObjectSpace.count_objects[:TOTAL]\n\n  puts \"Memory usage:\"\n  puts \"  Initial: #{initial_memory} objects\"\n  puts \"  Final: #{final_memory} objects\"\n  puts \"  Difference: #{final_memory - initial_memory} objects\"\nend\n\nmonitor_memory_usage\n</code></pre>"},{"location":"development/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"development/troubleshooting/#collect-debug-information","title":"Collect Debug Information","text":"<pre><code>def collect_debug_info\n  puts \"SmartMessage Debug Information\"\n  puts \"==============================\"\n  puts \"Version: #{SmartMessage::VERSION}\"\n  puts \"Ruby version: #{RUBY_VERSION}\"\n  puts \"Platform: #{RUBY_PLATFORM}\"\n  puts \"\"\n\n  # Available transports\n  puts \"Available transports: #{SmartMessage::Transport.available.join(', ')}\"\n  puts \"\"\n\n  # Current statistics\n  puts \"Current statistics:\"\n  SS.stat.each { |key, value| puts \"  #{key}: #{value}\" }\n  puts \"\"\n\n  # Thread pool status if dispatcher exists\n  begin\n    dispatcher = SmartMessage::Dispatcher.new\n    status = dispatcher.status\n    puts \"Dispatcher status:\"\n    status.each { |key, value| puts \"  #{key}: #{value}\" }\n  rescue =&gt; e\n    puts \"Dispatcher error: #{e.message}\"\n  end\nend\n\ncollect_debug_info\n</code></pre>"},{"location":"development/troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code># Enable debug output in test.log\nrequire 'debug_me'\ninclude DebugMe\n\n# This will log to test.log with detailed information\ndebug_me { \"Message published: #{message.to_h}\" }\n</code></pre> <p>If you're still experiencing issues after trying these troubleshooting steps, please open an issue on the GitHub repository with:</p> <ol> <li>Your debug information (use <code>collect_debug_info</code> above)</li> <li>A minimal code example that reproduces the issue</li> <li>The full error message and stack trace</li> <li>Your system environment details</li> </ol>"},{"location":"getting-started/examples/","title":"Examples &amp; Use Cases","text":"<p>This document provides practical examples of using SmartMessage in real-world scenarios.</p>"},{"location":"getting-started/examples/#basic-messaging-patterns","title":"Basic Messaging Patterns","text":""},{"location":"getting-started/examples/#simple-notification-system","title":"Simple Notification System","text":"<pre><code>require 'smart_message'\n\nclass NotificationMessage &lt; SmartMessage::Base\n  description \"Sends notifications to users via multiple channels\"\n\n  property :recipient\n  property :subject\n  property :body\n  property :priority, default: 'normal'\n  property :channel, default: 'email'\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    notification = decoded_message\n\n    case notification.channel\n    when 'email'\n      send_email(notification)\n    when 'sms'\n      send_sms(notification)\n    when 'push'\n      send_push_notification(notification)\n    end\n  end\n\n  private\n\n  def self.send_email(notification)\n    puts \"\ud83d\udce7 Sending email to #{notification.recipient}\"\n    puts \"Subject: #{notification.subject}\"\n    puts \"Priority: #{notification.priority}\"\n  end\n\n  def self.send_sms(notification)\n    puts \"\ud83d\udcf1 Sending SMS to #{notification.recipient}\"\n    puts \"Message: #{notification.body}\"\n  end\n\n  def self.send_push_notification(notification)\n    puts \"\ud83d\udd14 Sending push notification to #{notification.recipient}\"\n    puts \"Title: #{notification.subject}\"\n  end\nend\n\n# Setup\nNotificationMessage.subscribe\n\n# Send notifications\nNotificationMessage.new(\n  recipient: \"user@example.com\",\n  subject: \"Welcome!\",\n  body: \"Thanks for signing up!\",\n  priority: \"high\"\n).publish\n\nNotificationMessage.new(\n  recipient: \"+1234567890\",\n  subject: \"Alert\",\n  body: \"Your order has shipped!\",\n  channel: \"sms\"\n).publish\n</code></pre>"},{"location":"getting-started/examples/#event-driven-architecture","title":"Event-Driven Architecture","text":"<pre><code># User registration event\nclass UserRegisteredEvent &lt; SmartMessage::Base\n  property :user_id\n  property :email\n  property :name\n  property :registration_source\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    event = decoded_message\n\n    # Fan out to multiple handlers\n    send_welcome_email(event)\n    create_user_profile(event)\n    track_analytics(event)\n    setup_default_preferences(event)\n  end\n\n  private\n\n  def self.send_welcome_email(event)\n    WelcomeEmailMessage.new(\n      user_id: event.user_id,\n      email: event.email,\n      name: event.name\n    ).publish\n  end\n\n  def self.create_user_profile(event)\n    CreateProfileMessage.new(\n      user_id: event.user_id,\n      source: event.registration_source\n    ).publish\n  end\n\n  def self.track_analytics(event)\n    AnalyticsMessage.new(\n      event_type: 'user_registration',\n      user_id: event.user_id,\n      properties: {\n        source: event.registration_source,\n        timestamp: event.timestamp\n      }\n    ).publish\n  end\n\n  def self.setup_default_preferences(event)\n    PreferencesMessage.new(\n      user_id: event.user_id,\n      preferences: default_preferences\n    ).publish\n  end\n\n  def self.default_preferences\n    {\n      email_notifications: true,\n      marketing_emails: false,\n      theme: 'light'\n    }\n  end\nend\n\n# Supporting message classes\nclass WelcomeEmailMessage &lt; SmartMessage::Base\n  property :user_id\n  property :email\n  property :name\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n\n    puts \"\ud83d\udce7 Sending welcome email to #{message.email} (#{message.name})\"\n    # Email sending logic here\n  end\nend\n\nclass AnalyticsMessage &lt; SmartMessage::Base\n  property :event_type\n  property :user_id\n  property :properties\n\n  config do\n    transport SmartMessage::Transport.create(:stdout)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    event = decoded_message\n\n    puts \"\ud83d\udcca Tracking event: #{event.event_type} for user #{event.user_id}\"\n    # Analytics tracking logic here\n  end\nend\n\n# Setup and trigger\n[UserRegisteredEvent, WelcomeEmailMessage, AnalyticsMessage].each(&amp;:subscribe)\n\n# Simulate user registration\nUserRegisteredEvent.new(\n  user_id: 12345,\n  email: \"alice@example.com\",\n  name: \"Alice Johnson\",\n  registration_source: \"web_form\"\n).publish\n</code></pre>"},{"location":"getting-started/examples/#e-commerce-order-processing","title":"E-commerce Order Processing","text":"<pre><code># Order lifecycle management\nclass OrderCreatedMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :items\n  property :total_amount\n  property :shipping_address\n  property :created_at, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    order = decoded_message\n\n    # Validate order\n    if valid_order?(order)\n      # Reserve inventory\n      InventoryReservationMessage.new(\n        order_id: order.order_id,\n        items: order.items\n      ).publish\n\n      # Process payment\n      PaymentProcessingMessage.new(\n        order_id: order.order_id,\n        customer_id: order.customer_id,\n        amount: order.total_amount\n      ).publish\n    else\n      # Handle invalid order\n      OrderRejectedMessage.new(\n        order_id: order.order_id,\n        reason: \"Invalid order data\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.valid_order?(order)\n    order.items&amp;.any? &amp;&amp; order.total_amount&amp;.positive?\n  end\nend\n\nclass InventoryReservationMessage &lt; SmartMessage::Base\n  property :order_id\n  property :items\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    reservation = decoded_message\n\n    success = reserve_inventory(reservation.items)\n\n    if success\n      InventoryReservedMessage.new(\n        order_id: reservation.order_id\n      ).publish\n    else\n      InventoryFailedMessage.new(\n        order_id: reservation.order_id,\n        reason: \"Insufficient stock\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.reserve_inventory(items)\n    # Inventory reservation logic\n    puts \"\ud83c\udfea Reserving inventory for #{items.length} items\"\n    true  # Simulate success\n  end\nend\n\nclass PaymentProcessingMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    payment = decoded_message\n\n    success = process_payment(payment)\n\n    if success\n      PaymentSuccessMessage.new(\n        order_id: payment.order_id,\n        transaction_id: generate_transaction_id\n      ).publish\n    else\n      PaymentFailedMessage.new(\n        order_id: payment.order_id,\n        reason: \"Payment declined\"\n      ).publish\n    end\n  end\n\n  private\n\n  def self.process_payment(payment)\n    puts \"\ud83d\udcb3 Processing payment of $#{payment.amount} for order #{payment.order_id}\"\n    true  # Simulate success\n  end\n\n  def self.generate_transaction_id\n    \"txn_#{SecureRandom.hex(8)}\"\n  end\nend\n\n# Setup\n[\n  OrderCreatedMessage,\n  InventoryReservationMessage, \n  PaymentProcessingMessage\n].each(&amp;:subscribe)\n\n# Create an order\nOrderCreatedMessage.new(\n  order_id: \"ORD-001\",\n  customer_id: \"CUST-123\",\n  items: [\n    { sku: \"WIDGET-A\", quantity: 2, price: 19.99 },\n    { sku: \"GADGET-B\", quantity: 1, price: 49.99 }\n  ],\n  total_amount: 89.97,\n  shipping_address: {\n    street: \"123 Main St\",\n    city: \"Anytown\",\n    state: \"CA\",\n    zip: \"12345\"\n  }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#logging-and-monitoring","title":"Logging and Monitoring","text":"<pre><code># Centralized logging system\nclass LogMessage &lt; SmartMessage::Base\n  property :level\n  property :service\n  property :message\n  property :context\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n  property :correlation_id\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: \"application.log\")\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    log_entry = decoded_message\n\n    formatted_message = format_log_entry(log_entry)\n\n    case log_entry.level\n    when 'ERROR', 'FATAL'\n      send_alert(log_entry)\n    when 'WARN'\n      track_warning(log_entry)\n    end\n\n    puts formatted_message\n  end\n\n  private\n\n  def self.format_log_entry(log_entry)\n    \"[#{log_entry.timestamp}] #{log_entry.level} #{log_entry.service}: #{log_entry.message}\" +\n    (log_entry.correlation_id ? \" (#{log_entry.correlation_id})\" : \"\") +\n    (log_entry.context ? \" | #{log_entry.context.to_json}\" : \"\")\n  end\n\n  def self.send_alert(log_entry)\n    if log_entry.level == 'FATAL'\n      puts \"\ud83d\udea8 FATAL ERROR ALERT: #{log_entry.message}\"\n    else\n      puts \"\u26a0\ufe0f  ERROR ALERT: #{log_entry.message}\"\n    end\n  end\n\n  def self.track_warning(log_entry)\n    puts \"\ud83d\udcdd Warning tracked: #{log_entry.message}\"\n  end\nend\n\n# Application performance monitoring\nclass MetricMessage &lt; SmartMessage::Base\n  property :metric_name\n  property :value\n  property :unit\n  property :tags\n  property :timestamp, default: -&gt; { Time.now.to_f }\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    metric = decoded_message\n\n    # Store metric (would typically go to monitoring system)\n    store_metric(metric)\n\n    # Check for alerts\n    check_thresholds(metric)\n  end\n\n  private\n\n  def self.store_metric(metric)\n    puts \"\ud83d\udcca Metric: #{metric.metric_name} = #{metric.value} #{metric.unit} #{metric.tags}\"\n  end\n\n  def self.check_thresholds(metric)\n    case metric.metric_name\n    when 'response_time'\n      if metric.value &gt; 1000  # More than 1 second\n        puts \"\u26a0\ufe0f  High response time alert: #{metric.value}ms\"\n      end\n    when 'error_rate'\n      if metric.value &gt; 0.05  # More than 5% error rate\n        puts \"\ud83d\udea8 High error rate alert: #{(metric.value * 100).round(2)}%\"\n      end\n    end\n  end\nend\n\n# Setup\nLogMessage.subscribe\nMetricMessage.subscribe\n\n# Log some events\nLogMessage.new(\n  level: \"INFO\",\n  service: \"user-service\",\n  message: \"User login successful\",\n  context: { user_id: 123, ip: \"192.168.1.1\" },\n  correlation_id: \"req-abc123\"\n).publish\n\nLogMessage.new(\n  level: \"ERROR\",\n  service: \"payment-service\",\n  message: \"Payment gateway timeout\",\n  context: { order_id: \"ORD-001\", gateway: \"stripe\" },\n  correlation_id: \"req-def456\"\n).publish\n\n# Send some metrics\nMetricMessage.new(\n  metric_name: \"response_time\",\n  value: 1250,\n  unit: \"ms\",\n  tags: { service: \"api\", endpoint: \"/users\" }\n).publish\n\nMetricMessage.new(\n  metric_name: \"error_rate\",\n  value: 0.08,\n  unit: \"percentage\",\n  tags: { service: \"payment-service\" }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#gateway-pattern","title":"Gateway Pattern","text":"<pre><code># Bridge between different message systems\nclass MessageGateway &lt; SmartMessage::Base\n  property :source_system\n  property :destination_system\n  property :message_type\n  property :payload\n\n  # Receive from one transport\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    gateway_message = decoded_message\n\n    # Transform and forward to destination system\n    case gateway_message.destination_system\n    when 'email_system'\n      forward_to_email_system(gateway_message)\n    when 'sms_system'\n      forward_to_sms_system(gateway_message)\n    when 'audit_system'\n      forward_to_audit_system(gateway_message)\n    end\n  end\n\n  private\n\n  def self.forward_to_email_system(gateway_message)\n    # Create a new message instance with different transport\n    email_message = EmailSystemMessage.new(\n      original_payload: gateway_message.payload,\n      source: gateway_message.source_system\n    )\n\n    # Override transport for this instance\n    email_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"email_system.log\")\n    end\n\n    email_message.publish\n  end\n\n  def self.forward_to_sms_system(gateway_message)\n    sms_message = SMSSystemMessage.new(\n      original_payload: gateway_message.payload,\n      source: gateway_message.source_system\n    )\n\n    sms_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"sms_system.log\")\n    end\n\n    sms_message.publish\n  end\n\n  def self.forward_to_audit_system(gateway_message)\n    audit_message = AuditSystemMessage.new(\n      event_type: gateway_message.message_type,\n      data: gateway_message.payload,\n      source_system: gateway_message.source_system,\n      processed_at: Time.now.iso8601\n    )\n\n    audit_message.config do\n      transport SmartMessage::Transport.create(:stdout, output: \"audit_system.log\")\n    end\n\n    audit_message.publish\n  end\nend\n\n# Destination system message classes\nclass EmailSystemMessage &lt; SmartMessage::Base\n  property :original_payload\n  property :source\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udce7 Email system processed message from #{decoded_message.source}\"\n  end\nend\n\nclass SMSSystemMessage &lt; SmartMessage::Base\n  property :original_payload\n  property :source\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udcf1 SMS system processed message from #{decoded_message.source}\"\n  end\nend\n\nclass AuditSystemMessage &lt; SmartMessage::Base\n  property :event_type\n  property :data\n  property :source_system\n  property :processed_at\n\n  def self.process(decoded_message)\n    puts \"\ud83d\udccb Audit system logged event from #{decoded_message.source_system}\"\n  end\nend\n\n# Setup\n[MessageGateway, EmailSystemMessage, SMSSystemMessage, AuditSystemMessage].each(&amp;:subscribe)\n\n# Route messages through gateway\nMessageGateway.new(\n  source_system: \"web_app\",\n  destination_system: \"email_system\",\n  message_type: \"notification\",\n  payload: { recipient: \"user@example.com\", subject: \"Hello!\" }\n).publish\n\nMessageGateway.new(\n  source_system: \"mobile_app\",\n  destination_system: \"audit_system\",\n  message_type: \"user_action\",\n  payload: { action: \"login\", user_id: 123 }\n).publish\n</code></pre>"},{"location":"getting-started/examples/#error-handling-and-retry-patterns","title":"Error Handling and Retry Patterns","text":"<pre><code># Resilient message processing with retries\nclass ResilientMessage &lt; SmartMessage::Base\n  property :data\n  property :retry_count, default: 0\n  property :max_retries, default: 3\n  property :original_error\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n\n    begin\n      # Simulate potentially failing operation\n      if should_fail?(message)\n        raise StandardError, \"Simulated failure\"\n      end\n\n      puts \"\u2705 Successfully processed message: #{message.data}\"\n\n    rescue =&gt; e\n      handle_error(message, e)\n    end\n  end\n\n  private\n\n  def self.should_fail?(message)\n    # Simulate 30% failure rate\n    rand &lt; 0.3\n  end\n\n  def self.handle_error(message, error)\n    puts \"\u274c Error processing message: #{error.message}\"\n\n    if message.retry_count &lt; message.max_retries\n      # Retry with exponential backoff\n      delay = 2 ** message.retry_count\n      puts \"\ud83d\udd04 Retrying in #{delay} seconds (attempt #{message.retry_count + 1})\"\n\n      # In a real system, you'd use a delayed job or similar\n      Thread.new do\n        sleep(delay)\n\n        retry_message = new(\n          data: message.data,\n          retry_count: message.retry_count + 1,\n          max_retries: message.max_retries,\n          original_error: error.message\n        )\n\n        retry_message.publish\n      end\n    else\n      # Max retries exceeded, send to dead letter queue\n      DeadLetterMessage.new(\n        original_message: message.to_h,\n        final_error: error.message,\n        retry_attempts: message.retry_count,\n        failed_at: Time.now.iso8601\n      ).publish\n    end\n  end\nend\n\nclass DeadLetterMessage &lt; SmartMessage::Base\n  property :original_message\n  property :final_error\n  property :retry_attempts\n  property :failed_at\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: \"dead_letter_queue.log\")\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    dead_letter = decoded_message\n\n    puts \"\ud83d\udc80 Message sent to dead letter queue:\"\n    puts \"   Original: #{dead_letter.original_message}\"\n    puts \"   Error: #{dead_letter.final_error}\"\n    puts \"   Attempts: #{dead_letter.retry_attempts}\"\n    puts \"   Failed at: #{dead_letter.failed_at}\"\n\n    # Could trigger alerts, save to database, etc.\n  end\nend\n\n# Setup\nResilientMessage.subscribe\nDeadLetterMessage.subscribe\n\n# Send messages that might fail\n5.times do |i|\n  ResilientMessage.new(\n    data: \"Test message #{i + 1}\"\n  ).publish\n\n  sleep(0.1)  # Small delay between messages\nend\n</code></pre>"},{"location":"getting-started/examples/#testing-helpers","title":"Testing Helpers","text":"<pre><code># Test utilities for SmartMessage\nmodule SmartMessageTestHelpers\n  def self.with_test_transport\n    original_transports = {}\n\n    # Store original transports\n    SmartMessage::Base.descendants.each do |klass|\n      original_transports[klass] = klass.transport\n    end\n\n    # Set up test transport\n    test_transport = SmartMessage::Transport.create(:memory, auto_process: true)\n\n    SmartMessage::Base.descendants.each do |klass|\n      klass.config do\n        transport test_transport\n      end\n    end\n\n    yield test_transport\n\n  ensure\n    # Restore original transports\n    original_transports.each do |klass, transport|\n      klass.config do\n        transport transport\n      end\n    end\n  end\n\n  def self.clear_statistics\n    SS.reset\n  end\n\n  def self.wait_for_processing(timeout: 1.0)\n    start_time = Time.now\n\n    while Time.now - start_time &lt; timeout\n      # Check if any messages are still being processed\n      # This is a simplified check\n      sleep(0.01)\n    end\n  end\nend\n\n# Example test usage\ndef test_message_processing\n  SmartMessageTestHelpers.with_test_transport do |transport|\n    # Clear any existing messages\n    transport.clear_messages\n    SmartMessageTestHelpers.clear_statistics\n\n    # Set up subscriptions\n    TestMessage.subscribe\n\n    # Send test message\n    TestMessage.new(data: \"test\").publish\n\n    # Wait for processing\n    SmartMessageTestHelpers.wait_for_processing\n\n    # Check results\n    puts \"Messages in transport: #{transport.message_count}\"\n    puts \"Published count: #{SS.get('TestMessage', 'publish')}\"\n    puts \"Processed count: #{SS.get('TestMessage', 'TestMessage.process', 'routed')}\"\n  end\nend\n\nclass TestMessage &lt; SmartMessage::Base\n  property :data\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    message = decoded_message\n    puts \"Processed test message: #{message.data}\"\n  end\nend\n\n# Run the test\ntest_message_processing\n</code></pre> <p>These examples demonstrate the flexibility and power of SmartMessage for building robust, scalable messaging systems. Each pattern can be adapted to your specific needs and combined with other patterns for more complex workflows.</p>"},{"location":"getting-started/examples/#executable-example-programs","title":"Executable Example Programs","text":"<p>The <code>examples/</code> directory contains complete, runnable programs that demonstrate various SmartMessage features:</p>"},{"location":"getting-started/examples/#memory-transport-examples","title":"Memory Transport Examples","text":"<ul> <li><code>memory/03_point_to_point_orders.rb</code> - Point-to-point order processing with payment integration</li> <li><code>memory/04_publish_subscribe_events.rb</code> - Event broadcasting to multiple services (email, SMS, audit)</li> <li><code>memory/05_many_to_many_chat.rb</code> - Interactive chat system with rooms, bots, and human agents</li> <li><code>memory/07_proc_handlers_demo.rb</code> - Flexible message handlers (blocks, procs, lambdas, methods)</li> <li><code>memory/08_custom_logger_demo.rb</code> - Advanced logging with SmartMessage::Logger::Default</li> <li><code>memory/09_error_handling_demo.rb</code> - Comprehensive validation, version mismatch, and error handling</li> <li><code>memory/10_entity_addressing_basic.rb</code> - Basic FROM/TO/REPLY_TO message addressing</li> <li><code>memory/11_entity_addressing_with_filtering.rb</code> - Advanced entity-aware message filtering</li> <li><code>memory/02_dead_letter_queue_demo.rb</code> - Complete Dead Letter Queue system demonstration</li> <li><code>memory/01_message_deduplication_demo.rb</code> - Message deduplication patterns</li> <li><code>memory/12_regex_filtering_microservices.rb</code> - Advanced regex filtering for microservices</li> <li><code>memory/13_header_block_configuration.rb</code> - Header and block configuration examples</li> <li><code>memory/14_global_configuration_demo.rb</code> - Global configuration management</li> <li><code>memory/15_logger_demo.rb</code> - Advanced logging demonstrations</li> </ul>"},{"location":"getting-started/examples/#redis-transport-examples","title":"Redis Transport Examples","text":"<ul> <li><code>redis/01_smart_home_iot_demo.rb</code> - Redis-based IoT sensor monitoring with real-time data flow</li> </ul>"},{"location":"getting-started/examples/#redis-enhanced-transport-examples","title":"Redis Enhanced Transport Examples","text":"<ul> <li><code>redis_enhanced/enhanced_01_basic_patterns.rb</code> - Basic enhanced transport patterns</li> <li><code>redis_enhanced/enhanced_02_fluent_api.rb</code> - Fluent API usage examples</li> <li><code>redis_enhanced/enhanced_03_dual_publishing.rb</code> - Dual publishing strategies</li> <li><code>redis_enhanced/enhanced_04_advanced_routing.rb</code> - Advanced message routing</li> </ul>"},{"location":"getting-started/examples/#redis-queue-transport-examples","title":"Redis Queue Transport Examples","text":"<ul> <li><code>redis_queue/01_basic_messaging.rb</code> - Basic queue messaging patterns</li> <li><code>redis_queue/02_pattern_routing.rb</code> - Pattern-based message routing</li> <li><code>redis_queue/03_fluent_api.rb</code> - Fluent API for queue operations</li> <li><code>redis_queue/04_load_balancing.rb</code> - Load balancing across workers</li> <li><code>redis_queue/05_microservices.rb</code> - Microservices communication</li> <li><code>redis_queue/06_emergency_alerts.rb</code> - Emergency alert system</li> <li><code>redis_queue/07_queue_management.rb</code> - Queue management utilities</li> <li><code>redis_queue/01_comprehensive_examples.rb</code> - Comprehensive feature demonstration</li> </ul>"},{"location":"getting-started/examples/#city-scenario-comprehensive-demo","title":"City Scenario (Comprehensive Demo)","text":"<ul> <li><code>city_scenario/</code> - Complete emergency services simulation with multiple services and AI integration</li> </ul>"},{"location":"getting-started/examples/#performance-testing","title":"Performance Testing","text":"<ul> <li><code>performance_metrics/</code> - Benchmarking tools and performance comparisons</li> </ul>"},{"location":"getting-started/examples/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to the SmartMessage directory\ncd smart_message\n\n# Run examples from their respective transport directories\nruby examples/memory/03_point_to_point_orders.rb\nruby examples/memory/02_dead_letter_queue_demo.rb\nruby examples/redis/01_smart_home_iot_demo.rb\nruby examples/redis_queue/01_basic_messaging.rb\n\n# For city scenario comprehensive demo\ncd examples/city_scenario &amp;&amp; ./start_demo.sh\n</code></pre> <p>Each example is self-contained and includes: - Clear educational comments - Multiple message classes - Complete setup and teardown - Real-world scenarios - Best practices demonstration</p>"},{"location":"getting-started/examples/#example-features-demonstrated","title":"Example Features Demonstrated","text":"Example Transport Features Use Case memory/03 Memory/STDOUT Point-to-point, validation Order processing memory/04 Memory/STDOUT Pub-sub, multiple handlers Event broadcasting memory/05 Memory Many-to-many, bots Chat systems redis/01 Redis IoT, real-time, addressing Smart home monitoring memory/07 Memory Proc handlers, flexibility Dynamic message handling memory/08 Memory/STDOUT Custom logging, lifecycle Production logging memory/09 Memory/STDOUT Error handling, validation Robust message systems memory/10-11 Memory/STDOUT Entity addressing, filtering Microservice communication memory/02 Memory DLQ, circuit breakers, replay Production reliability redis_queue/* Redis Queue Load balancing, persistence Production messaging city_scenario/* Redis AI integration, health monitoring Emergency services <p>These examples provide practical, working code that you can use as a starting point for your own SmartMessage implementations.</p>"},{"location":"getting-started/quick-start/","title":"Getting Started with SmartMessage","text":"<p>This guide will help you get up and running with SmartMessage quickly.</p>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":"<p>Add SmartMessage to your Gemfile:</p> <pre><code>gem 'smart_message'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre> <p>Or install directly:</p> <pre><code>gem install smart_message\n</code></pre>"},{"location":"getting-started/quick-start/#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.0.0</li> <li>No additional system dependencies for basic usage</li> </ul>"},{"location":"getting-started/quick-start/#transport-options","title":"Transport Options","text":"<p>SmartMessage supports multiple transport layers:</p>"},{"location":"getting-started/quick-start/#built-in-transports","title":"Built-in Transports","text":"<ul> <li>Memory Transport - Perfect for development and testing. No external dependencies required.</li> <li>STDOUT Transport - Great for debugging and logging. No external dependencies.</li> <li>Redis Transport - Production-ready transport for distributed systems. Requires Redis server.</li> </ul>"},{"location":"getting-started/quick-start/#redis-installation-optional","title":"Redis Installation (Optional)","text":"<p>The Redis transport is built-in but requires Redis server to be installed. However, you don't need Redis just to play around - the Memory transport works great for development and testing.</p> <p>If you want to use Redis transport:</p> <p>macOS: <pre><code>brew install redis\nbrew services start redis\n</code></pre></p> <p>Ubuntu/Debian: <pre><code>sudo apt-get update\nsudo apt-get install redis-server\n</code></pre></p> <p>Other Transports: Additional transport layers (RabbitMQ, Kafka, etc.) are available as separate plugin repositories. Check the Transports documentation for more information.</p>"},{"location":"getting-started/quick-start/#your-first-message","title":"Your First Message","text":"<p>Let's create a simple message class and see it in action:</p>"},{"location":"getting-started/quick-start/#1-define-a-message-class","title":"1. Define a Message Class","text":"<pre><code>require 'smart_message'\n\nclass WelcomeMessage &lt; SmartMessage::Base\n  # Add a description for the message class\n  description \"Welcomes new users after successful signup\"\n\n  # Configure entity addressing (Method 1: Direct methods)\n  from 'user-service'           # Required: identifies sender\n  to 'notification-service'     # Optional: specific recipient\n  reply_to 'user-service'       # Optional: where responses go\n\n  # Alternative Method 2: Using header block\n  # header do\n  #   from 'user-service'\n  #   to 'notification-service'\n  #   reply_to 'user-service'\n  # end\n\n  # Define message properties\n  property :user_name\n  property :email\n  property :signup_date\n\n  # Configure the transport (where messages go)\n  config do\n    transport SmartMessage::Transport.create(:stdout, loopback: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  # Define how to process received messages\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    welcome = decoded_message\n\n    # Process the welcome message\n    puts \"\ud83c\udf89 Welcome #{welcome.user_name}!\"\n    puts \"\ud83d\udce7 Email: #{welcome.email}\"\n    puts \"\ud83d\udcc5 Signed up: #{welcome.signup_date}\"\n  end\nend\n</code></pre>"},{"location":"getting-started/quick-start/#2-subscribe-to-messages","title":"2. Subscribe to Messages","text":"<p>Before publishing, set up a subscription to receive messages. SmartMessage provides several ways to handle incoming messages:</p> <pre><code># 1. Default handler (uses the self.process method defined above)\nWelcomeMessage.subscribe\n\n# 2. Block handler (inline processing logic)\nWelcomeMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"\ud83d\udc4b Quick welcome for #{data['user_name']}\"\nend\n\n# 3. Proc handler (reusable processing logic)\nwelcome_processor = proc do |header, payload|\n  data = JSON.parse(payload)\n  EmailService.send_welcome_email(data['email'], data['user_name'])\nend\nWelcomeMessage.subscribe(welcome_processor)\n\n# 4. Custom method handler\nWelcomeMessage.subscribe(\"UserService.handle_welcome\")\n</code></pre>"},{"location":"getting-started/quick-start/#3-create-and-publish-a-message","title":"3. Create and Publish a Message","text":"<pre><code># Create a new welcome message\nwelcome = WelcomeMessage.new(\n  user_name: \"Alice Johnson\",\n  email: \"alice@example.com\", \n  signup_date: Date.today.to_s\n)\n\n# Publish the message\nwelcome.publish\n</code></pre>"},{"location":"getting-started/quick-start/#4-see-it-in-action","title":"4. See It in Action","text":"<p>Run your script and you should see:</p> <pre><code>===================================================\n== SmartMessage Published via STDOUT Transport\n== Header: #&lt;SmartMessage::Header:0x... @uuid=\"...\", @message_class=\"WelcomeMessage\", ...&gt;\n== Payload: {\"user_name\":\"Alice Johnson\",\"email\":\"alice@example.com\",\"signup_date\":\"2025-08-17\"}\n===================================================\n\n\ud83c\udf89 Welcome Alice Johnson!\n\ud83d\udce7 Email: alice@example.com\n\ud83d\udcc5 Signed up: 2025-08-17\n</code></pre>"},{"location":"getting-started/quick-start/#understanding-what-happened","title":"Understanding What Happened","text":"<ol> <li>Message Definition: We created a <code>WelcomeMessage</code> class with three properties</li> <li>Configuration: We configured it to use STDOUT transport with loopback enabled</li> <li>Subscription: We subscribed to process incoming messages of this type</li> <li>Publishing: We created an instance and published it</li> <li>Processing: Because loopback is enabled, the message was immediately routed back and processed</li> </ol>"},{"location":"getting-started/quick-start/#key-concepts","title":"Key Concepts","text":""},{"location":"getting-started/quick-start/#properties","title":"Properties","text":"<p>Messages use Hashie::Dash properties for type-safe attributes:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Represents customer orders for processing and fulfillment\"\n\n  property :order_id, required: true\n  property :amount, transform_with: -&gt;(v) { BigDecimal(v.to_s) }\n  property :items, default: []\n  property :created_at, default: -&gt; { Time.now }\nend\n</code></pre>"},{"location":"getting-started/quick-start/#headers","title":"Headers","text":"<p>Every message automatically gets a header with metadata:</p> <pre><code>message = WelcomeMessage.new(user_name: \"Bob\")\nputs message._sm_header.uuid          # Unique identifier\nputs message._sm_header.message_class # \"WelcomeMessage\"\nputs message._sm_header.published_at  # Timestamp when published\nputs message._sm_header.publisher_pid # Process ID of publisher\nputs message._sm_header.from          # 'user-service'\nputs message._sm_header.to            # 'notification-service'\nputs message._sm_header.reply_to      # 'user-service'\n</code></pre>"},{"location":"getting-started/quick-start/#transports","title":"Transports","text":"<p>Transports handle where messages go. Built-in options include:</p> <pre><code># STDOUT - for development/debugging\ntransport SmartMessage::Transport.create(:stdout, loopback: true)\n\n# Memory - for testing\ntransport SmartMessage::Transport.create(:memory, auto_process: true)\n</code></pre>"},{"location":"getting-started/quick-start/#serializers","title":"Serializers","text":"<p>Serializers handle message encoding/decoding:</p> <pre><code># JSON serialization (built-in)\nserializer SmartMessage::Serializer::Json.new\n</code></pre>"},{"location":"getting-started/quick-start/#message-handlers","title":"Message Handlers","text":"<p>SmartMessage supports four types of message handlers to give you flexibility in how you process messages:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  description \"Handles customer order processing and fulfillment\"\n\n  # Define your message properties\n  property :order_id\n  property :amount\n\n  # Default handler - processed when no custom handler specified\n  def self.process(header, payload)\n    puts \"Default processing for order\"\n  end\nend\n\n# 1. Default handler (uses self.process)\nOrderMessage.subscribe\n\n# 2. Block handler - great for simple, inline logic\nOrderMessage.subscribe do |header, payload|\n  data = JSON.parse(payload)\n  puts \"Block handler: Processing order #{data['order_id']}\"\nend\n\n# 3. Proc handler - reusable across message types\naudit_logger = proc do |header, payload|\n  puts \"Audit: #{header.message_class} at #{header.published_at}\"\nend\nOrderMessage.subscribe(audit_logger)\n\n# 4. Method handler - organized in service classes\nclass OrderService\n  def self.process_order(header, payload)\n    puts \"Service processing order\"\n  end\nend\nOrderMessage.subscribe(\"OrderService.process_order\")\n</code></pre> <p>When to use each type: - Default: Simple built-in processing for the message type - Block: Quick inline logic specific to one subscription - Proc: Reusable handlers that work across multiple message types - Method: Complex business logic organized in service classes</p>"},{"location":"getting-started/quick-start/#entity-addressing","title":"Entity Addressing","text":"<p>SmartMessage supports entity-to-entity addressing for sophisticated messaging patterns:</p> <pre><code># Point-to-point messaging\nclass PaymentMessage &lt; SmartMessage::Base\n  from 'payment-service'    # Required: sender identity\n  to 'bank-gateway'         # Optional: specific recipient\n  reply_to 'payment-service' # Optional: where responses go\n\n  property :amount, required: true\nend\n\n# Broadcast messaging (no 'to' field)\nclass AnnouncementMessage &lt; SmartMessage::Base\n  from 'admin-service'      # Required sender\n  # No 'to' = broadcast to all subscribers\n\n  property :message, required: true\nend\n\n# Instance-level addressing override\npayment = PaymentMessage.new(amount: 100.00)\npayment.to('backup-gateway')  # Override destination\npayment.publish\n</code></pre> <p>For more details, see Entity Addressing.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics working, explore:</p> <ul> <li>Architecture Overview - Understand how SmartMessage works</li> <li>Examples - See more practical use cases</li> <li>Transports - Learn about different transport options</li> </ul>"},{"location":"getting-started/quick-start/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quick-start/#simple-notification-system","title":"Simple Notification System","text":"<pre><code>class NotificationMessage &lt; SmartMessage::Base\n  description \"Sends notifications to users via email, SMS, or push\"\n\n  property :recipient\n  property :subject\n  property :body\n  property :priority, default: 'normal'\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    notification = decoded_message\n\n    # Send email, SMS, push notification, etc.\n    send_notification(notification)\n  end\n\n  private\n\n  def self.send_notification(notification)\n    puts \"Sending #{notification.priority} notification to #{notification.recipient}\"\n    puts \"Subject: #{notification.subject}\"\n  end\nend\n\n# Subscribe and send\nNotificationMessage.subscribe\n\nNotificationMessage.new(\n  recipient: \"user@example.com\",\n  subject: \"Welcome!\",\n  body: \"Thanks for signing up!\",\n  priority: \"high\"\n).publish\n</code></pre>"},{"location":"getting-started/quick-start/#event-logging","title":"Event Logging","text":"<pre><code>class EventMessage &lt; SmartMessage::Base\n  description \"Logs application events for monitoring and analytics\"\n\n  property :event_type\n  property :user_id\n  property :data\n  property :timestamp, default: -&gt; { Time.now.iso8601 }\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, output: 'events.log')\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# Log events\nEventMessage.new(\n  event_type: 'user_login',\n  user_id: 123,\n  data: { ip: '192.168.1.1', user_agent: 'Chrome' }\n).publish\n</code></pre>"},{"location":"getting-started/quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Check the Troubleshooting Guide</li> <li>Look at more Examples</li> </ul>"},{"location":"guides/redis-queue-getting-started/","title":"Redis Queue Transport - Getting Started","text":"<p>This guide will help you get started with SmartMessage's Redis Queue Transport, the most advanced transport offering RabbitMQ-style routing with Redis performance.</p>"},{"location":"guides/redis-queue-getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ruby 2.7 or higher</li> <li>Redis server running (localhost:6379 by default)</li> <li>SmartMessage gem installed</li> </ul>"},{"location":"guides/redis-queue-getting-started/#installation","title":"Installation","text":"<p>Add SmartMessage to your Gemfile:</p> <pre><code>gem 'smart_message', '~&gt; 0.1.0'\n</code></pre> <p>Or install directly:</p> <pre><code>gem install smart_message\n</code></pre> <p>Ensure Redis is running:</p> <pre><code># Start Redis server\nredis-server\n\n# Test Redis connection\nredis-cli ping\n# Should return: PONG\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#quick-start","title":"Quick Start","text":""},{"location":"guides/redis-queue-getting-started/#1-basic-configuration","title":"1. Basic Configuration","text":"<pre><code>require 'smart_message'\n\n# Configure SmartMessage to use Redis Queue transport\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: 'redis://localhost:6379',\n    db: 0,\n    queue_prefix: 'myapp_queues',\n    consumer_group: 'myapp_workers'\n  }\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#2-create-your-first-message","title":"2. Create Your First Message","text":"<pre><code>class WelcomeMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :user_name, required: true\n  property :email, required: true\n  property :signup_date, default: -&gt; { Time.now.strftime('%Y-%m-%d') }\n\n  def process\n    puts \"\ud83d\udc4b Welcome #{user_name} (#{email})! Signed up: #{signup_date}\"\n\n    # Your business logic here\n    UserMailer.welcome_email(email, user_name).deliver_now\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#3-subscribe-to-messages","title":"3. Subscribe to Messages","text":"<pre><code># Subscribe to all WelcomeMessage instances\nWelcomeMessage.subscribe\n\nputs \"\u2705 Subscribed to welcome messages. Waiting for messages...\"\n\n# Keep the script running\nsleep\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#4-publish-messages","title":"4. Publish Messages","text":"<pre><code># In another script or Rails console:\nWelcomeMessage.new(\n  user_name: 'Alice Johnson',\n  email: 'alice@example.com'\n).publish\n\nputs \"\ud83d\udce4 Welcome message sent!\"\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#understanding-the-basics","title":"Understanding the Basics","text":""},{"location":"guides/redis-queue-getting-started/#what-makes-redis-queue-different","title":"What Makes Redis Queue Different?","text":"<p>Unlike traditional Redis pub/sub, Redis Queue Transport provides:</p> <ol> <li>Persistent Queues: Messages survive service restarts</li> <li>Load Balancing: Multiple workers share message processing  </li> <li>Pattern Routing: Intelligent message routing like RabbitMQ</li> <li>Queue Management: Monitor and manage message queues</li> </ol>"},{"location":"guides/redis-queue-getting-started/#routing-keys","title":"Routing Keys","text":"<p>Every message gets an enhanced routing key:</p> <pre><code>namespace.message_type.from_uuid.to_uuid\n</code></pre> <p>For example: - <code>myapp.welcomemessage.signup_service.email_service</code> - <code>myapp.ordermessage.api_gateway.payment_service</code></p>"},{"location":"guides/redis-queue-getting-started/#basic-patterns","title":"Basic Patterns","text":""},{"location":"guides/redis-queue-getting-started/#1-simple-producer-consumer","title":"1. Simple Producer-Consumer","text":"<p>Producer: <pre><code>class TaskMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :task_id, required: true\n  property :task_type, required: true\n  property :priority, default: 'normal'\n\n  def process\n    puts \"\u2699\ufe0f Processing task #{task_id} [#{task_type}] - Priority: #{priority}\"\n\n    # Simulate work\n    sleep(rand(1..3))\n\n    puts \"\u2705 Task #{task_id} completed!\"\n  end\nend\n\n# Publish tasks\n5.times do |i|\n  TaskMessage.new(\n    task_id: \"TASK-#{sprintf('%03d', i + 1)}\",\n    task_type: ['import', 'export', 'backup', 'cleanup', 'report'][i],\n    priority: ['low', 'normal', 'high'][rand(3)]\n  ).publish\nend\n</code></pre></p> <p>Consumer: <pre><code># Start processing tasks\nTaskMessage.subscribe\n\nputs \"\ud83d\udd27 Task processor started. Waiting for tasks...\"\nsleep  # Keep running\n</code></pre></p>"},{"location":"guides/redis-queue-getting-started/#2-multiple-services-communication","title":"2. Multiple Services Communication","text":"<p>User Service: <pre><code>class UserCreated &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :user_id, required: true\n  property :name, required: true\n  property :email, required: true\n\n  def process\n    puts \"\ud83d\udc64 User created: #{name} (#{email})\"\n  end\nend\n\n# Simulate user creation\nUser.after_create do |user|\n  UserCreated.new(\n    user_id: user.id,\n    name: user.name,\n    email: user.email,\n    _sm_header: {\n      from: 'user_service',\n      to: 'notification_service'\n    }\n  ).publish\nend\n</code></pre></p> <p>Notification Service: <pre><code># Create transport for pattern subscription\ntransport = SmartMessage::Transport::RedisQueueTransport.new(\n  queue_prefix: 'notifications',\n  consumer_group: 'notification_workers'\n)\n\n# Subscribe to messages directed to notification service\ntransport.subscribe_pattern(\"#.*.notification_service\") do |message_class, message_data|\n  data = JSON.parse(message_data)\n\n  puts \"\ud83d\udce7 Notification service received: #{message_class}\"\n  puts \"   User: #{data['name']} (#{data['email']})\"\n\n  # Send welcome email\n  WelcomeMailer.send_email(data['email'], data['name'])\nend\n\nputs \"\ud83d\udce7 Notification service started. Waiting for user events...\"\nsleep\n</code></pre></p>"},{"location":"guides/redis-queue-getting-started/#3-load-balancing-workers","title":"3. Load Balancing Workers","text":"<p>Setup Multiple Workers: <pre><code># worker1.rb\nclass ProcessingTask &lt; SmartMessage::Base\n  transport :redis_queue, {\n    consumer_group: 'processing_workers'\n  }\n\n  property :data, required: true\n\n  def process\n    worker_id = Thread.current.object_id.to_s[-4..-1]\n    puts \"\u2699\ufe0f Worker-#{worker_id} processing: #{data}\"\n\n    # Simulate work\n    sleep(rand(0.5..2.0))\n\n    puts \"\u2705 Worker-#{worker_id} completed: #{data}\"\n  end\nend\n\nProcessingTask.subscribe\nputs \"\ud83d\udd27 Worker 1 started\"\nsleep\n</code></pre></p> <pre><code># worker2.rb (identical code, different process)\n# worker3.rb (identical code, different process)\n</code></pre> <p>Send Work: <pre><code># Send tasks that will be load balanced\n20.times do |i|\n  ProcessingTask.new(\n    data: \"Task #{i + 1}\",\n    _sm_header: {\n      from: 'task_scheduler',\n      to: 'worker_pool'\n    }\n  ).publish\nend\n\nputs \"\ud83d\udce4 Sent 20 tasks to worker pool\"\n</code></pre></p>"},{"location":"guides/redis-queue-getting-started/#pattern-based-routing","title":"Pattern-Based Routing","text":""},{"location":"guides/redis-queue-getting-started/#basic-patterns_1","title":"Basic Patterns","text":"<pre><code>transport = SmartMessage::Transport::RedisQueueTransport.new\n\n# Messages TO specific service\ntransport.subscribe_pattern(\"#.*.payment_service\") do |msg_class, data|\n  puts \"\ud83d\udcb3 Payment service: #{msg_class}\"\nend\n\n# Messages FROM specific service  \ntransport.subscribe_pattern(\"#.api_gateway.*\") do |msg_class, data|\n  puts \"\ud83c\udf10 From API Gateway: #{msg_class}\"\nend\n\n# Specific message types\ntransport.subscribe_pattern(\"order.#.*.*\") do |msg_class, data|\n  puts \"\ud83d\udce6 Order message: #{msg_class}\"\nend\n\n# Broadcast messages\ntransport.subscribe_pattern(\"#.*.broadcast\") do |msg_class, data|\n  puts \"\ud83d\udce2 Broadcast: #{msg_class}\"\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#wildcard-examples","title":"Wildcard Examples","text":"Pattern Matches Example <code>#.*.my_service</code> All messages TO my_service <code>order.ordermessage.api.my_service</code> <code>#.admin.*</code> All messages FROM admin <code>user.usercreated.admin.notification</code> <code>order.#.*.*</code> All order messages <code>order.ordercreated.api.payment</code> <code>*.*.*.broadcast</code> All broadcasts <code>alert.systemalert.monitor.broadcast</code> <code>#.#.#.urgent</code> All urgent messages <code>emergency.alert.security.urgent</code>"},{"location":"guides/redis-queue-getting-started/#fluent-api","title":"Fluent API","text":"<p>The fluent API provides an expressive way to build subscriptions:</p> <pre><code>transport = SmartMessage::Transport::RedisQueueTransport.new\n\n# Simple fluent subscriptions\ntransport.where\n  .from('api_service')\n  .subscribe { |msg, data| puts \"From API: #{msg}\" }\n\ntransport.where\n  .to('my_service')\n  .subscribe { |msg, data| puts \"To Me: #{msg}\" }\n\ntransport.where\n  .type('OrderMessage')\n  .subscribe { |msg, data| puts \"Order: #{msg}\" }\n\n# Combined criteria\ntransport.where\n  .from('web_app')\n  .to('analytics_service')\n  .subscribe { |msg, data| puts \"Web \u2192 Analytics: #{msg}\" }\n\n# Load balancing\ntransport.where\n  .to('shared_service')\n  .consumer_group('shared_workers')\n  .subscribe { |msg, data| puts \"Shared worker: #{msg}\" }\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#queue-management","title":"Queue Management","text":""},{"location":"guides/redis-queue-getting-started/#monitor-queue-status","title":"Monitor Queue Status","text":"<pre><code>transport = SmartMessage::Transport::RedisQueueTransport.new\n\n# Get queue statistics\nstats = transport.queue_stats\nputs \"\ud83d\udcca Queue Statistics:\"\nstats.each do |queue_name, info|\n  puts \"  #{queue_name}:\"\n  puts \"    Messages: #{info[:length]}\"\n  puts \"    Consumers: #{info[:consumers]}\"\n  puts \"    Pattern: #{info[:pattern]}\"\n  puts \"\"\nend\n\n# Show routing table\nrouting_table = transport.routing_table\nputs \"\ud83d\uddfa\ufe0f Routing Table:\"\nrouting_table.each do |pattern, queues|\n  puts \"  '#{pattern}' \u2192 #{queues.join(', ')}\"\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#health-monitoring","title":"Health Monitoring","text":"<pre><code>def monitor_queues(transport)\n  stats = transport.queue_stats\n\n  # Check for problems\n  problems = []\n\n  stats.each do |queue, info|\n    if info[:length] &gt; 100\n      problems &lt;&lt; \"\u26a0\ufe0f High load: #{queue} has #{info[:length]} messages\"\n    elsif info[:length] &gt; 0 &amp;&amp; info[:consumers] == 0\n      problems &lt;&lt; \"\ud83d\udd34 No consumers: #{queue} has #{info[:length]} pending messages\"\n    end\n  end\n\n  if problems.any?\n    puts \"Queue Issues:\"\n    problems.each { |problem| puts \"  #{problem}\" }\n  else\n    puts \"\u2705 All queues healthy\"\n  end\nend\n\n# Monitor periodically\nloop do\n  monitor_queues(transport)\n  sleep 30\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#production-configuration","title":"Production Configuration","text":""},{"location":"guides/redis-queue-getting-started/#environment-specific-settings","title":"Environment-Specific Settings","text":"<pre><code># config/environments/development.rb\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: 'redis://localhost:6379',\n    db: 15,  # Use test database\n    queue_prefix: 'myapp_dev',\n    consumer_group: 'dev_workers',\n    block_time: 1000,  # 1 second for quick debugging\n    debug: true\n  }\nend\n\n# config/environments/production.rb\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: ENV['REDIS_URL'] || 'redis://redis.prod.company.com:6379',\n    db: 0,\n    queue_prefix: 'myapp_prod',\n    consumer_group: 'prod_workers',\n    block_time: 5000,  # 5 seconds for efficiency\n    max_queue_length: 50000,  # Large queues\n    max_retries: 3,\n    dead_letter_queue: true,\n    pool_size: 10  # Connection pooling\n  }\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#worker-configuration","title":"Worker Configuration","text":"<pre><code># config/workers.rb\nclass ApplicationWorker\n  def self.start\n    # Start multiple worker types\n    start_order_workers(3)      # 3 order processing workers\n    start_email_workers(2)      # 2 email workers  \n    start_report_workers(1)     # 1 report worker\n    start_general_workers(5)    # 5 general purpose workers\n  end\n\n  def self.start_order_workers(count)\n    count.times do |i|\n      Thread.new do\n        transport = SmartMessage::Transport::RedisQueueTransport.new(\n          consumer_group: 'order_workers',\n          consumer_id: \"order_worker_#{i + 1}\"\n        )\n\n        transport.where\n          .to('order_service')\n          .consumer_group('order_workers')\n          .subscribe { |msg, data| puts \"Order Worker #{i + 1}: #{msg}\" }\n      end\n    end\n  end\n\n  # Similar methods for other worker types...\nend\n\n# Start all workers\nApplicationWorker.start\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#health-checks","title":"Health Checks","text":"<pre><code># lib/health_check.rb\nclass RedisQueueHealthCheck\n  def self.check\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    begin\n      # Test connectivity\n      connected = transport.connected?\n\n      # Check queue health\n      stats = transport.queue_stats\n      queue_issues = stats.select { |_, info| info[:length] &gt; 1000 || (info[:length] &gt; 0 &amp;&amp; info[:consumers] == 0) }\n\n      {\n        status: connected &amp;&amp; queue_issues.empty? ? 'healthy' : 'unhealthy',\n        connected: connected,\n        total_queues: stats.size,\n        total_messages: stats.values.sum { |info| info[:length] },\n        total_consumers: stats.values.sum { |info| info[:consumers] || 0 },\n        queue_issues: queue_issues\n      }\n    rescue =&gt; e\n      {\n        status: 'error',\n        error: e.message\n      }\n    ensure\n      transport.disconnect\n    end\n  end\nend\n\n# Use in Rails health check endpoint\nclass HealthController &lt; ApplicationController\n  def show\n    health_info = RedisQueueHealthCheck.check\n\n    if health_info[:status] == 'healthy'\n      render json: health_info, status: :ok\n    else\n      render json: health_info, status: :service_unavailable\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#common-patterns-and-best-practices","title":"Common Patterns and Best Practices","text":""},{"location":"guides/redis-queue-getting-started/#1-request-response-pattern","title":"1. Request-Response Pattern","text":"<pre><code># Request message\nclass ProcessingRequest &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :request_id, required: true\n  property :data, required: true\n  property :callback_service, required: true\n\n  def process\n    # Process the request\n    result = process_data(data)\n\n    # Send response back\n    ProcessingResponse.new(\n      request_id: request_id,\n      result: result,\n      status: 'success',\n      _sm_header: {\n        from: 'processing_service',\n        to: callback_service\n      }\n    ).publish\n  end\nend\n\n# Response message\nclass ProcessingResponse &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :request_id, required: true\n  property :result, required: true\n  property :status, required: true\n\n  def process\n    puts \"\ud83d\udce5 Response for request #{request_id}: #{status}\"\n    # Handle response\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#2-saga-pattern","title":"2. Saga Pattern","text":"<pre><code>class OrderSaga\n  def self.start_order(order_data)\n    # Step 1: Reserve inventory\n    ReserveInventory.new(\n      saga_id: order_data[:saga_id],\n      order_id: order_data[:order_id],\n      items: order_data[:items],\n      _sm_header: { from: 'order_saga', to: 'inventory_service' }\n    ).publish\n  end\nend\n\nclass ReserveInventory &lt; SmartMessage::Base\n  transport :redis_queue\n\n  def process\n    if inventory_available?\n      # Success - continue saga\n      ProcessPayment.new(\n        saga_id: saga_id,\n        order_id: order_id,\n        amount: calculate_amount,\n        _sm_header: { from: 'inventory_service', to: 'payment_service' }\n      ).publish\n    else\n      # Failure - compensate\n      OrderFailed.new(\n        saga_id: saga_id,\n        reason: 'Inventory not available',\n        _sm_header: { from: 'inventory_service', to: 'order_saga' }\n      ).publish\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#3-event-sourcing","title":"3. Event Sourcing","text":"<pre><code>class EventStore\n  def self.append_event(event)\n    EventAppended.new(\n      event_id: SecureRandom.uuid,\n      event_type: event.class.name,\n      event_data: event.to_h,\n      timestamp: Time.now,\n      _sm_header: { from: 'event_store', to: 'broadcast' }\n    ).publish\n  end\nend\n\n# Projections subscribe to events\nclass OrderProjection &lt; SmartMessage::Base\n  transport :redis_queue\n\n  def self.subscribe_to_events\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    transport.subscribe_pattern(\"event.#.*.*\") do |msg_class, data|\n      event = JSON.parse(data)\n\n      case event['event_type']\n      when 'OrderCreated'\n        update_order_projection(event['event_data'])\n      when 'OrderCancelled'\n        cancel_order_projection(event['event_data'])\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/redis-queue-getting-started/#debug-mode","title":"Debug Mode","text":"<pre><code># Enable detailed logging\ntransport = SmartMessage::Transport::RedisQueueTransport.new(\n  debug: true,\n  log_level: :debug\n)\n\n# Or set environment variable\nENV['SMART_MESSAGE_DEBUG'] = 'true'\n</code></pre>"},{"location":"guides/redis-queue-getting-started/#common-issues","title":"Common Issues","text":"<p>Messages not being processed: <pre><code># Check if anyone is subscribed\nstats = transport.queue_stats\nstats.each do |queue, info|\n  if info[:length] &gt; 0 &amp;&amp; info[:consumers] == 0\n    puts \"No consumers for #{queue}\"\n  end\nend\n</code></pre></p> <p>Pattern not matching: <pre><code># Test pattern matching\ntransport = SmartMessage::Transport::RedisQueueTransport.new\npattern = \"#.*.my_service\"\ntest_key = \"order.ordermessage.api.my_service\"\n\n# This uses private method for testing\nmatches = transport.send(:routing_key_matches_pattern?, test_key, pattern)\nputs \"Pattern matches: #{matches}\"\n</code></pre></p> <p>High memory usage: <pre><code># Check for large queues\nstats = transport.queue_stats\nlarge_queues = stats.select { |_, info| info[:length] &gt; 1000 }\nputs \"Large queues: #{large_queues}\"\n\n# Configure queue limits\ntransport = SmartMessage::Transport::RedisQueueTransport.new(\n  max_queue_length: 5000\n)\n</code></pre></p>"},{"location":"guides/redis-queue-getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you understand the basics, explore these advanced topics:</p> <ol> <li>Advanced Routing Patterns - Complex routing scenarios</li> <li>Production Deployment - Production-ready configurations</li> <li>Complete Transport Reference - Full API documentation</li> </ol> <p>Or dive into the complete examples to see real-world usage patterns.</p> <p>The Redis Queue Transport provides the perfect balance of performance, reliability, and intelligent routing for modern Ruby applications. Start with these patterns and gradually incorporate more advanced features as your needs grow.</p>"},{"location":"guides/redis-queue-patterns/","title":"Redis Queue Transport - Advanced Routing Patterns","text":"<p>This guide covers advanced routing patterns and use cases for the Redis Queue Transport, helping you implement sophisticated message routing architectures.</p>"},{"location":"guides/redis-queue-patterns/#pattern-syntax-reference","title":"Pattern Syntax Reference","text":""},{"location":"guides/redis-queue-patterns/#wildcard-meanings","title":"Wildcard Meanings","text":"Symbol Matches Examples <code>#</code> Zero or more words <code>#</code> matches <code>a</code>, <code>a.b</code>, <code>a.b.c</code> <code>*</code> Exactly one word <code>*</code> matches <code>a</code> but not <code>a.b</code> <code>.</code> Word separator Literal dot character"},{"location":"guides/redis-queue-patterns/#pattern-structure","title":"Pattern Structure","text":"<p>All patterns follow the routing key format: <pre><code>namespace.message_type.from_uuid.to_uuid\n</code></pre></p> <p>Common pattern examples: - <code>#.*.service_name</code> - All messages TO service_name - <code>#.sender.*</code> - All messages FROM sender - <code>namespace.#.*.*</code> - All messages in namespace - <code>#.#.#.broadcast</code> - All broadcast messages</p>"},{"location":"guides/redis-queue-patterns/#basic-routing-patterns","title":"Basic Routing Patterns","text":""},{"location":"guides/redis-queue-patterns/#1-service-to-service-communication","title":"1. Service-to-Service Communication","text":"<pre><code># API Gateway routing requests to services\ntransport = SmartMessage::Transport::RedisQueueTransport.new\n\nclass ServiceRequest &lt; SmartMessage::Base\n  transport :redis_queue\n  property :service, required: true\n  property :operation, required: true\n  property :payload, default: {}\nend\n\n# Route to user service\ntransport.subscribe_pattern(\"#.*.user_service\") do |msg_class, data|\n  request = JSON.parse(data)\n  puts \"\ud83d\udc64 User Service: #{request['operation']}\"\n\n  case request['operation']\n  when 'create_user'\n    create_user(request['payload'])\n  when 'get_user'\n    get_user(request['payload']['user_id'])\n  end\nend\n\n# Route to payment service\ntransport.subscribe_pattern(\"#.*.payment_service\") do |msg_class, data|\n  request = JSON.parse(data)\n  puts \"\ud83d\udcb3 Payment Service: #{request['operation']}\"\n\n  case request['operation']\n  when 'process_payment'\n    process_payment(request['payload'])\n  when 'refund_payment'\n    refund_payment(request['payload'])\n  end\nend\n\n# API Gateway publishes requests\nServiceRequest.new(\n  service: 'user_service',\n  operation: 'create_user',\n  payload: { name: 'John Doe', email: 'john@example.com' },\n  _sm_header: { from: 'api_gateway', to: 'user_service' }\n).publish\n</code></pre>"},{"location":"guides/redis-queue-patterns/#2-event-driven-architecture","title":"2. Event-Driven Architecture","text":"<pre><code># Domain events with smart routing\nclass OrderEvent &lt; SmartMessage::Base\n  transport :redis_queue\n  property :event_type, required: true\n  property :order_id, required: true\n  property :data, default: {}\nend\n\n# Multiple services react to order events\nclass InventoryService\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Listen for order events that affect inventory\n    transport.subscribe_pattern(\"order.#.*.*\") do |msg_class, data|\n      event = JSON.parse(data)\n\n      case event['event_type']\n      when 'order_placed'\n        reserve_inventory(event['order_id'], event['data']['items'])\n      when 'order_cancelled'\n        release_inventory(event['order_id'])\n      end\n    end\n  end\nend\n\nclass ShippingService\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Listen for paid orders\n    transport.subscribe_pattern(\"order.#.payment_service.*\") do |msg_class, data|\n      event = JSON.parse(data)\n\n      if event['event_type'] == 'payment_confirmed'\n        schedule_shipping(event['order_id'])\n      end\n    end\n  end\nend\n\n# Publish order events\nOrderEvent.new(\n  event_type: 'order_placed',\n  order_id: 'ORD-123',\n  data: { items: [{ sku: 'BOOK-001', qty: 2 }], customer_id: 'CUST-456' },\n  _sm_header: { from: 'order_service', to: 'inventory_service' }\n).publish\n</code></pre>"},{"location":"guides/redis-queue-patterns/#3-multi-tenant-routing","title":"3. Multi-Tenant Routing","text":"<pre><code># Tenant isolation through routing patterns\nclass TenantMessage &lt; SmartMessage::Base\n  transport :redis_queue\n  property :tenant_id, required: true\n  property :data, required: true\nend\n\nclass TenantService\n  def initialize(tenant_id)\n    @tenant_id = tenant_id\n    @transport = SmartMessage::Transport::RedisQueueTransport.new\n    setup_subscriptions\n  end\n\n  private\n\n  def setup_subscriptions\n    # Only receive messages for this tenant\n    pattern = \"#.#{@tenant_id}_*.*\"\n\n    @transport.subscribe_pattern(pattern) do |msg_class, data|\n      message = JSON.parse(data)\n      puts \"\ud83c\udfe2 Tenant #{@tenant_id} processing: #{msg_class}\"\n      process_tenant_message(message)\n    end\n\n    # Admin broadcasts to all tenants\n    @transport.subscribe_pattern(\"#.admin.*.broadcast\") do |msg_class, data|\n      message = JSON.parse(data)\n      puts \"\ud83d\udce2 Admin broadcast to tenant #{@tenant_id}: #{message['subject']}\"\n      process_admin_broadcast(message)\n    end\n  end\nend\n\n# Start tenant services\ntenant_1_service = TenantService.new('tenant_123')\ntenant_2_service = TenantService.new('tenant_456')\n\n# Publish tenant-specific messages\nTenantMessage.new(\n  tenant_id: 'tenant_123',\n  data: { user_count: 50 },\n  _sm_header: { from: 'tenant_123_analytics', to: 'tenant_123_dashboard' }\n).publish\n\n# Admin broadcast\nAdminBroadcast.new(\n  subject: 'Scheduled maintenance tonight',\n  message: 'System will be down from 2-4 AM',\n  _sm_header: { from: 'admin', to: 'broadcast' }\n).publish\n</code></pre>"},{"location":"guides/redis-queue-patterns/#advanced-routing-scenarios","title":"Advanced Routing Scenarios","text":""},{"location":"guides/redis-queue-patterns/#4-priority-based-routing","title":"4. Priority-Based Routing","text":"<pre><code># Priority-based message routing\nclass PriorityMessage &lt; SmartMessage::Base\n  transport :redis_queue\n  property :priority, required: true  # critical, high, normal, low\n  property :data, required: true\nend\n\nclass PriorityRouter\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Route based on priority in the FROM field\n    transport.subscribe_pattern(\"priority.#.*.*\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      target_service = case message['priority']\n                      when 'critical'\n                        'critical_processor'\n                      when 'high'\n                        'high_priority_processor'\n                      else\n                        'normal_processor'\n                      end\n\n      # Re-route to priority-specific service\n      PriorityMessage.new(\n        priority: message['priority'],\n        data: message['data'],\n        _sm_header: {\n          from: 'priority_router',\n          to: target_service\n        }\n      ).publish\n    end\n  end\nend\n\n# Priority-specific processors\nclass CriticalProcessor\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    transport.subscribe_pattern(\"#.*.critical_processor\") do |msg_class, data|\n      message = JSON.parse(data)\n      puts \"\ud83d\udea8 CRITICAL: Processing #{message['data']} immediately\"\n      # Process with highest priority\n    end\n  end\nend\n\n# Publish priority messages\nPriorityMessage.new(\n  priority: 'critical',\n  data: { alert: 'System overload detected' },\n  _sm_header: { from: 'monitoring', to: 'priority_router' }\n).publish\n</code></pre>"},{"location":"guides/redis-queue-patterns/#5-geographic-routing","title":"5. Geographic Routing","text":"<pre><code># Geographic region-based routing\nclass GeographicMessage &lt; SmartMessage::Base\n  transport :redis_queue\n  property :region, required: true  # us-east, us-west, eu, asia\n  property :data, required: true\nend\n\n# Regional processors\nclass RegionalProcessor\n  def initialize(region)\n    @region = region\n    @transport = SmartMessage::Transport::RedisQueueTransport.new\n    setup_subscriptions\n  end\n\n  private\n\n  def setup_subscriptions\n    # Process messages for this region\n    pattern = \"#.*.#{@region}_processor\"\n\n    @transport.subscribe_pattern(pattern) do |msg_class, data|\n      message = JSON.parse(data)\n      puts \"\ud83c\udf0d #{@region.upcase} processing: #{message['data']}\"\n      process_regional_data(message['data'])\n    end\n\n    # Global broadcasts\n    @transport.subscribe_pattern(\"#.*.global\") do |msg_class, data|\n      message = JSON.parse(data)\n      puts \"\ud83c\udf0e Global message in #{@region}: #{message['data']}\"\n      process_global_message(message['data'])\n    end\n  end\nend\n\n# Geographic router\nclass GeographicRouter\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    transport.subscribe_pattern(\"geo.#.*.*\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      # Route to regional processor\n      target = \"#{message['region']}_processor\"\n\n      GeographicMessage.new(\n        region: message['region'],\n        data: message['data'],\n        _sm_header: {\n          from: 'geo_router',\n          to: target\n        }\n      ).publish\n    end\n  end\nend\n\n# Start regional processors\nus_east = RegionalProcessor.new('us_east')\nus_west = RegionalProcessor.new('us_west')\neu = RegionalProcessor.new('eu')\n</code></pre>"},{"location":"guides/redis-queue-patterns/#6-content-based-routing","title":"6. Content-Based Routing","text":"<pre><code># Route messages based on content analysis\nclass ContentRouter\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Analyze incoming messages and route appropriately\n    transport.subscribe_pattern(\"content.#.*.*\") do |msg_class, data|\n      message = JSON.parse(data)\n      content = message['content']\n\n      # Determine routing based on content\n      routes = analyze_content(content)\n\n      routes.each do |service|\n        RoutedMessage.new(\n          content: content,\n          analysis_result: routes,\n          _sm_header: {\n            from: 'content_router',\n            to: service\n          }\n        ).publish\n      end\n    end\n  end\n\n  private\n\n  def self.analyze_content(content)\n    routes = []\n\n    # Text analysis routing\n    if content.match?(/urgent|emergency|critical/i)\n      routes &lt;&lt; 'alert_service'\n    end\n\n    if content.match?(/order|purchase|buy/i)\n      routes &lt;&lt; 'sales_service'\n    end\n\n    if content.match?(/bug|error|issue/i)\n      routes &lt;&lt; 'support_service'\n    end\n\n    if content.match?/@\\w+/) # Contains mentions\n      routes &lt;&lt; 'notification_service'\n    end\n\n    routes &lt;&lt; 'archive_service'  # Always archive\n    routes.uniq\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-patterns/#7-workflow-routing","title":"7. Workflow Routing","text":"<pre><code># Multi-step workflow routing\nclass WorkflowStep &lt; SmartMessage::Base\n  transport :redis_queue\n  property :workflow_id, required: true\n  property :step_number, required: true\n  property :data, required: true\n  property :next_step\nend\n\nclass WorkflowEngine\n  WORKFLOWS = {\n    'order_processing' =&gt; [\n      'validate_order',\n      'check_inventory', \n      'process_payment',\n      'ship_order',\n      'send_confirmation'\n    ],\n    'user_onboarding' =&gt; [\n      'verify_email',\n      'setup_profile',\n      'send_welcome',\n      'assign_trial'\n    ]\n  }.freeze\n\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Listen for workflow completions\n    transport.subscribe_pattern(\"workflow.#.*.*\") do |msg_class, data|\n      step = JSON.parse(data)\n      advance_workflow(step)\n    end\n  end\n\n  private\n\n  def self.advance_workflow(completed_step)\n    workflow_type = determine_workflow_type(completed_step['workflow_id'])\n    steps = WORKFLOWS[workflow_type]\n    current_index = steps.index(completed_step['step_type'])\n\n    if current_index &amp;&amp; current_index &lt; steps.length - 1\n      next_step = steps[current_index + 1]\n\n      WorkflowStep.new(\n        workflow_id: completed_step['workflow_id'],\n        step_number: current_index + 2,\n        data: completed_step['data'],\n        next_step: next_step,\n        _sm_header: {\n          from: 'workflow_engine',\n          to: \"#{next_step}_service\"\n        }\n      ).publish\n    else\n      # Workflow complete\n      WorkflowComplete.new(\n        workflow_id: completed_step['workflow_id'],\n        _sm_header: {\n          from: 'workflow_engine',\n          to: 'workflow_monitor'\n        }\n      ).publish\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-patterns/#complex-pattern-combinations","title":"Complex Pattern Combinations","text":""},{"location":"guides/redis-queue-patterns/#8-multi-criteria-routing","title":"8. Multi-Criteria Routing","text":"<pre><code># Complex routing with multiple criteria\nclass ComplexRouter\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    # Route based on multiple message attributes\n    setup_routing_rules(transport)\n  end\n\n  private\n\n  def self.setup_routing_rules(transport)\n    # Rule 1: Critical messages from admin go to operations\n    transport.subscribe_pattern(\"#.admin.*.#\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      if message['severity'] == 'critical'\n        route_to_operations(message)\n      end\n    end\n\n    # Rule 2: Payment messages go to compliance if amount &gt; $10,000\n    transport.subscribe_pattern(\"payment.#.*.*\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      if message['amount'] &amp;&amp; message['amount'] &gt; 10000\n        route_to_compliance(message)\n      end\n    end\n\n    # Rule 3: Messages from EU customers go to GDPR processor\n    transport.subscribe_pattern(\"#.*.#\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      if eu_customer?(message['customer_data'])\n        route_to_gdpr_processor(message)\n      end\n    end\n\n    # Rule 4: Time-sensitive messages during business hours\n    transport.subscribe_pattern(\"#.*.#\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      if message['time_sensitive'] &amp;&amp; business_hours?\n        route_to_priority_processor(message)\n      elsif message['time_sensitive']\n        route_to_delayed_processor(message)\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-patterns/#9-fan-out-and-aggregation","title":"9. Fan-out and Aggregation","text":"<pre><code># Fan-out pattern: One message to many processors\nclass FanOutMessage &lt; SmartMessage::Base\n  transport :redis_queue\n  property :data, required: true\n  property :processors, required: true  # Array of target processors\nend\n\nclass FanOutRouter\n  def self.start\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    transport.subscribe_pattern(\"fanout.#.*.*\") do |msg_class, data|\n      message = JSON.parse(data)\n\n      # Send to each specified processor\n      message['processors'].each do |processor|\n        ProcessingTask.new(\n          data: message['data'],\n          original_message_id: message['message_id'],\n          _sm_header: {\n            from: 'fanout_router',\n            to: processor\n          }\n        ).publish\n      end\n    end\n  end\nend\n\n# Aggregation pattern: Many results back to one\nclass AggregationCollector\n  def initialize\n    @results = {}\n    @transport = SmartMessage::Transport::RedisQueueTransport.new\n    setup_subscriptions\n  end\n\n  private\n\n  def setup_subscriptions\n    @transport.subscribe_pattern(\"#.*.aggregation_collector\") do |msg_class, data|\n      result = JSON.parse(data)\n      collect_result(result)\n    end\n  end\n\n  def collect_result(result)\n    message_id = result['original_message_id']\n    @results[message_id] ||= []\n    @results[message_id] &lt;&lt; result\n\n    # Check if we have all expected results\n    if all_results_collected?(message_id)\n      publish_aggregated_result(message_id, @results[message_id])\n      @results.delete(message_id)\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-patterns/#10-circuit-breaker-pattern-with-routing","title":"10. Circuit Breaker Pattern with Routing","text":"<pre><code># Route around failing services\nclass CircuitBreakerRouter\n  def initialize\n    @circuit_states = {}  # service_name =&gt; :closed | :open | :half_open\n    @failure_counts = {}\n    @last_failure_time = {}\n    @transport = SmartMessage::Transport::RedisQueueTransport.new\n    setup_routing\n  end\n\n  private\n\n  def setup_routing\n    # Monitor service health\n    @transport.subscribe_pattern(\"health.#.*.*\") do |msg_class, data|\n      health_report = JSON.parse(data)\n      update_circuit_state(health_report['service'], health_report['status'])\n    end\n\n    # Route requests based on circuit state\n    @transport.subscribe_pattern(\"request.#.*.*\") do |msg_class, data|\n      request = JSON.parse(data)\n      service = request['target_service']\n\n      case @circuit_states[service]\n      when :open\n        # Route to fallback or reject\n        route_to_fallback(request, service)\n      when :half_open\n        # Allow limited requests\n        if should_allow_request?(service)\n          route_to_service(request, service)\n        else\n          route_to_fallback(request, service)\n        end\n      else  # :closed (healthy)\n        route_to_service(request, service)\n      end\n    end\n  end\n\n  def route_to_fallback(request, failed_service)\n    fallback_service = determine_fallback(failed_service)\n\n    if fallback_service\n      FallbackRequest.new(\n        original_service: failed_service,\n        request_data: request,\n        _sm_header: {\n          from: 'circuit_breaker_router',\n          to: fallback_service\n        }\n      ).publish\n    else\n      # No fallback available\n      ErrorResponse.new(\n        error: \"Service #{failed_service} unavailable\",\n        _sm_header: {\n          from: 'circuit_breaker_router',\n          to: request['callback_service']\n        }\n      ).publish\n    end\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-patterns/#pattern-testing-and-debugging","title":"Pattern Testing and Debugging","text":""},{"location":"guides/redis-queue-patterns/#pattern-validation","title":"Pattern Validation","text":"<pre><code># Test pattern matching\nclass PatternTester\n  def self.test_pattern(pattern, test_keys)\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    puts \"Testing pattern: #{pattern}\"\n    puts \"-\" * 40\n\n    test_keys.each do |key|\n      matches = transport.send(:routing_key_matches_pattern?, key, pattern)\n      status = matches ? \"\u2705 MATCH\" : \"\u274c NO MATCH\"\n      puts \"#{status}: #{key}\"\n    end\n\n    transport.disconnect\n  end\nend\n\n# Test cases\ntest_keys = [\n  'order.ordermessage.api_gateway.payment_service',\n  'user.usercreated.signup_service.notification_service',\n  'alert.systemalert.monitoring.broadcast',\n  'payment.paymentprocessed.payment_service.order_service'\n]\n\nPatternTester.test_pattern(\"#.*.payment_service\", test_keys)\nPatternTester.test_pattern(\"order.#.*.*\", test_keys)\nPatternTester.test_pattern(\"#.#.#.broadcast\", test_keys)\n</code></pre>"},{"location":"guides/redis-queue-patterns/#pattern-performance-analysis","title":"Pattern Performance Analysis","text":"<pre><code># Analyze pattern matching performance\nclass PatternPerformance\n  def self.benchmark_patterns(patterns, test_keys, iterations = 1000)\n    transport = SmartMessage::Transport::RedisQueueTransport.new\n\n    patterns.each do |pattern|\n      start_time = Time.now\n\n      iterations.times do\n        test_keys.each do |key|\n          transport.send(:routing_key_matches_pattern?, key, pattern)\n        end\n      end\n\n      duration = Time.now - start_time\n      total_tests = iterations * test_keys.size\n      rate = total_tests / duration\n\n      puts \"Pattern: #{pattern}\"\n      puts \"  Tests: #{total_tests}\"\n      puts \"  Time: #{duration.round(4)}s\"\n      puts \"  Rate: #{rate.round(0)} matches/sec\"\n      puts \"\"\n    end\n\n    transport.disconnect\n  end\nend\n\npatterns = [\n  \"#.*.payment_service\",\n  \"order.#.*.*\",\n  \"#.api_gateway.*\",\n  \"#.#.#.broadcast\"\n]\n\nPatternPerformance.benchmark_patterns(patterns, test_keys)\n</code></pre>"},{"location":"guides/redis-queue-patterns/#routing-table-analysis","title":"Routing Table Analysis","text":"<pre><code># Analyze routing efficiency\nclass RoutingAnalyzer\n  def self.analyze(transport)\n    routing_table = transport.routing_table\n\n    puts \"\ud83d\udcca Routing Table Analysis\"\n    puts \"=\" * 30\n\n    # Pattern complexity analysis\n    simple_patterns = 0\n    wildcard_patterns = 0\n    complex_patterns = 0\n\n    routing_table.each do |pattern, queues|\n      if pattern.include?('#') || pattern.include?('*')\n        if pattern.count('#') + pattern.count('*') &gt; 2\n          complex_patterns += 1\n        else\n          wildcard_patterns += 1\n        end\n      else\n        simple_patterns += 1\n      end\n    end\n\n    puts \"Pattern Types:\"\n    puts \"  Simple: #{simple_patterns}\"\n    puts \"  Wildcard: #{wildcard_patterns}\"\n    puts \"  Complex: #{complex_patterns}\"\n    puts \"\"\n\n    # Queue distribution\n    queue_counts = routing_table.values.map(&amp;:size)\n    avg_queues = queue_counts.sum.to_f / queue_counts.size\n\n    puts \"Queue Distribution:\"\n    puts \"  Total patterns: #{routing_table.size}\"\n    puts \"  Total queues: #{queue_counts.sum}\"\n    puts \"  Avg queues/pattern: #{avg_queues.round(2)}\"\n    puts \"  Max queues/pattern: #{queue_counts.max}\"\n    puts \"\"\n\n    # Potential overlaps\n    overlapping_patterns = find_overlapping_patterns(routing_table.keys)\n    if overlapping_patterns.any?\n      puts \"\u26a0\ufe0f Potentially overlapping patterns:\"\n      overlapping_patterns.each do |pair|\n        puts \"  #{pair[0]} \u2194 #{pair[1]}\"\n      end\n    else\n      puts \"\u2705 No overlapping patterns detected\"\n    end\n  end\n\n  private\n\n  def self.find_overlapping_patterns(patterns)\n    overlaps = []\n\n    patterns.combination(2) do |p1, p2|\n      if patterns_might_overlap?(p1, p2)\n        overlaps &lt;&lt; [p1, p2]\n      end\n    end\n\n    overlaps\n  end\n\n  def self.patterns_might_overlap?(p1, p2)\n    # Simple heuristic - both have wildcards in same positions\n    p1_parts = p1.split('.')\n    p2_parts = p2.split('.')\n\n    return false if p1_parts.size != p2_parts.size\n\n    p1_parts.zip(p2_parts).any? do |part1, part2|\n      (part1 == '#' || part1 == '*') &amp;&amp; (part2 == '#' || part2 == '*')\n    end\n  end\nend\n\n# Analyze current routing\ntransport = SmartMessage::Transport::RedisQueueTransport.new\nRoutingAnalyzer.analyze(transport)\n</code></pre>"},{"location":"guides/redis-queue-patterns/#best-practices-for-pattern-design","title":"Best Practices for Pattern Design","text":""},{"location":"guides/redis-queue-patterns/#1-pattern-hierarchy","title":"1. Pattern Hierarchy","text":"<pre><code># Organize patterns from specific to general\npatterns = [\n  \"emergency.alert.security.critical\",    # Most specific\n  \"emergency.alert.security.*\",           # Department-specific\n  \"emergency.alert.*.*\",                  # Alert type-specific\n  \"emergency.#.*.*\",                      # Emergency namespace\n  \"#.#.#.critical\",                       # Priority-specific\n  \"#.#.#.broadcast\"                       # Broadcast messages\n]\n</code></pre>"},{"location":"guides/redis-queue-patterns/#2-naming-conventions","title":"2. Naming Conventions","text":"<pre><code># Use consistent naming patterns\nPATTERN_CONVENTIONS = {\n  # Service routing\n  service_inbound: \"#.*.{service_name}\",\n  service_outbound: \"#{service_name}.#.*.*\",\n\n  # Event routing\n  domain_events: \"#{domain}.#.*.*\",\n  global_events: \"#.#.#.broadcast\",\n\n  # Priority routing\n  critical_messages: \"#.#.#.critical\",\n  urgent_messages: \"#.#.#.urgent\",\n\n  # Geographic routing\n  regional_messages: \"#.*.{region}_*\",\n  global_messages: \"#.*.global\"\n}.freeze\n</code></pre>"},{"location":"guides/redis-queue-patterns/#3-pattern-documentation","title":"3. Pattern Documentation","text":"<pre><code># Document your routing patterns\nclass RoutingDocumentation\n  PATTERNS = {\n    \"#.*.payment_service\" =&gt; {\n      description: \"All messages directed to payment service\",\n      use_case: \"Payment processing requests from any source\",\n      examples: [\n        \"order.paymentrequest.api_gateway.payment_service\",\n        \"refund.refundrequest.customer_service.payment_service\"\n      ],\n      performance: \"High volume - ensure adequate consumers\"\n    },\n\n    \"emergency.#.*.*\" =&gt; {\n      description: \"All emergency messages regardless of routing\",\n      use_case: \"Emergency monitoring and logging\",\n      examples: [\n        \"emergency.fire.building_sensor.fire_department\",\n        \"emergency.medical.mobile_app.ambulance_service\"\n      ],\n      performance: \"Critical - requires immediate processing\"\n    }\n  }.freeze\n\n  def self.document_pattern(pattern)\n    info = PATTERNS[pattern]\n    return unless info\n\n    puts \"Pattern: #{pattern}\"\n    puts \"Description: #{info[:description]}\"\n    puts \"Use Case: #{info[:use_case]}\"\n    puts \"Examples:\"\n    info[:examples].each { |ex| puts \"  - #{ex}\" }\n    puts \"Performance Notes: #{info[:performance]}\"\n    puts \"\"\n  end\nend\n</code></pre> <p>Advanced routing patterns enable sophisticated message architectures that can adapt to complex business requirements while maintaining high performance and reliability. Use these patterns as building blocks to create messaging systems that scale with your application's needs.</p>"},{"location":"guides/redis-queue-production/","title":"Redis Queue Transport - Production Guide","text":"<p>This guide covers deploying Redis Queue Transport in production environments, including configuration, monitoring, scaling, and operational best practices.</p>"},{"location":"guides/redis-queue-production/#production-architecture","title":"Production Architecture","text":""},{"location":"guides/redis-queue-production/#recommended-infrastructure","title":"Recommended Infrastructure","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Application   \u2502    \u2502     Redis        \u2502    \u2502    Monitoring   \u2502\n\u2502    Servers      \u2502\u25c4\u2500\u2500\u25ba\u2502    Cluster       \u2502\u25c4\u2500\u2500\u25ba\u2502     Stack       \u2502\n\u2502                 \u2502    \u2502                  \u2502    \u2502                 \u2502\n\u2502 \u2022 Rails Apps    \u2502    \u2502 \u2022 Master/Replica \u2502    \u2502 \u2022 Prometheus    \u2502\n\u2502 \u2022 Workers       \u2502    \u2502 \u2022 Sentinel       \u2502    \u2502 \u2022 Grafana       \u2502\n\u2502 \u2022 Background    \u2502    \u2502 \u2022 Persistence    \u2502    \u2502 \u2022 AlertManager  \u2502\n\u2502   Jobs          \u2502    \u2502 \u2022 Memory Opt     \u2502    \u2502 \u2022 Logs          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"guides/redis-queue-production/#infrastructure-components","title":"Infrastructure Components","text":"<ol> <li>Application Layer: Rails applications, worker processes</li> <li>Redis Layer: Clustered Redis with persistence and monitoring</li> <li>Load Balancers: HAProxy/nginx for application load balancing</li> <li>Monitoring: Comprehensive observability stack</li> <li>Alerting: Proactive issue detection and notification</li> </ol>"},{"location":"guides/redis-queue-production/#redis-configuration","title":"Redis Configuration","text":""},{"location":"guides/redis-queue-production/#production-redis-settings","title":"Production Redis Settings","text":"<pre><code># config/redis.conf\n# Memory and performance optimization\nmaxmemory 4gb\nmaxmemory-policy allkeys-lru\ntcp-keepalive 60\ntimeout 0\n\n# Persistence for queue durability\nsave 900 1    # Save if at least 1 change in 15 minutes\nsave 300 10   # Save if at least 10 changes in 5 minutes\nsave 60 10000 # Save if at least 10k changes in 1 minute\n\n# AOF for maximum durability\nappendonly yes\nappendfsync everysec\nauto-aof-rewrite-percentage 100\nauto-aof-rewrite-min-size 64mb\n\n# Network and connection settings\ntcp-backlog 511\nbind 0.0.0.0\nport 6379\nprotected-mode yes\nrequirepass your_secure_password\n\n# Logging\nloglevel notice\nlogfile /var/log/redis/redis-server.log\nsyslog-enabled yes\n\n# Performance tuning\nhash-max-ziplist-entries 512\nhash-max-ziplist-value 64\nlist-max-ziplist-size -2\nlist-compress-depth 0\n</code></pre>"},{"location":"guides/redis-queue-production/#redis-cluster-setup","title":"Redis Cluster Setup","text":"<pre><code># docker-compose.yml for Redis cluster\nversion: '3.8'\nservices:\n  redis-master:\n    image: redis:7-alpine\n    command: redis-server /etc/redis/redis.conf\n    volumes:\n      - ./redis-master.conf:/etc/redis/redis.conf\n      - redis-master-data:/data\n    ports:\n      - \"6379:6379\"\n    networks:\n      - redis-network\n\n  redis-replica-1:\n    image: redis:7-alpine\n    command: redis-server /etc/redis/redis.conf\n    volumes:\n      - ./redis-replica.conf:/etc/redis/redis.conf\n      - redis-replica-1-data:/data\n    depends_on:\n      - redis-master\n    networks:\n      - redis-network\n\n  redis-replica-2:\n    image: redis:7-alpine\n    command: redis-server /etc/redis/redis.conf\n    volumes:\n      - ./redis-replica.conf:/etc/redis/redis.conf\n      - redis-replica-2-data:/data\n    depends_on:\n      - redis-master\n    networks:\n      - redis-network\n\n  redis-sentinel-1:\n    image: redis:7-alpine\n    command: redis-sentinel /etc/redis/sentinel.conf\n    volumes:\n      - ./sentinel.conf:/etc/redis/sentinel.conf\n    depends_on:\n      - redis-master\n    networks:\n      - redis-network\n\nvolumes:\n  redis-master-data:\n  redis-replica-1-data:\n  redis-replica-2-data:\n\nnetworks:\n  redis-network:\n    driver: bridge\n</code></pre>"},{"location":"guides/redis-queue-production/#smartmessage-configuration","title":"SmartMessage Configuration","text":""},{"location":"guides/redis-queue-production/#production-transport-configuration","title":"Production Transport Configuration","text":"<pre><code># config/environments/production.rb\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    # Connection settings\n    url: ENV.fetch('REDIS_URL', 'redis://redis.internal:6379'),\n    db: ENV.fetch('REDIS_DB', '0').to_i,\n    password: ENV['REDIS_PASSWORD'],\n\n    # Queue configuration\n    queue_prefix: \"#{Rails.application.class.module_parent_name.downcase}.#{Rails.env}\",\n    consumer_group: \"#{Rails.application.class.module_parent_name.downcase}_workers\",\n    consumer_id: \"#{Socket.gethostname}_#{Process.pid}\",\n\n    # Performance tuning\n    block_time: 5000,         # 5 second blocking timeout\n    max_queue_length: 100000, # Large queue capacity\n    batch_size: 10,           # Process in batches\n\n    # Reliability settings\n    max_retries: 5,\n    retry_delay: 30,          # 30 seconds between retries\n    exponential_backoff: true,\n    dead_letter_queue: true,\n    dead_letter_prefix: 'dlq',\n\n    # Connection pooling\n    pool_size: ENV.fetch('REDIS_POOL_SIZE', '10').to_i,\n    pool_timeout: ENV.fetch('REDIS_POOL_TIMEOUT', '5').to_i,\n\n    # Circuit breaker\n    circuit_breaker: true,\n    failure_threshold: 10,\n    recovery_timeout: 120,\n\n    # Monitoring\n    enable_metrics: true,\n    metrics_interval: 60,\n\n    # Security\n    ssl_params: Rails.env.production? ? { verify_mode: OpenSSL::SSL::VERIFY_PEER } : nil\n  }\nend\n</code></pre>"},{"location":"guides/redis-queue-production/#environment-specific-settings","title":"Environment-Specific Settings","text":"<pre><code># config/smartmessage.rb\nclass SmartMessageConfig\n  ENVIRONMENT_CONFIGS = {\n    development: {\n      block_time: 1000,        # Fast for development\n      max_queue_length: 1000,  # Small queues\n      debug: true,\n      pool_size: 2\n    },\n\n    test: {\n      block_time: 100,         # Very fast for tests\n      max_queue_length: 100,   # Tiny queues\n      db: 15,                  # Test database\n      pool_size: 1\n    },\n\n    staging: {\n      block_time: 3000,        # Medium performance\n      max_queue_length: 10000, # Medium queues\n      max_retries: 3,\n      pool_size: 5\n    },\n\n    production: {\n      block_time: 5000,        # Optimized for throughput\n      max_queue_length: 100000,# Large queues\n      max_retries: 5,\n      pool_size: 20,\n      circuit_breaker: true,\n      dead_letter_queue: true\n    }\n  }.freeze\n\n  def self.configure_for_environment(env = Rails.env)\n    base_config = SmartMessage.configuration.transport_options || {}\n    env_config = ENVIRONMENT_CONFIGS[env.to_sym] || {}\n\n    SmartMessage.configure do |config|\n      config.transport_options = base_config.merge(env_config)\n    end\n  end\nend\n\n# Apply environment-specific configuration\nSmartMessageConfig.configure_for_environment\n</code></pre>"},{"location":"guides/redis-queue-production/#scaling-and-performance","title":"Scaling and Performance","text":""},{"location":"guides/redis-queue-production/#horizontal-scaling","title":"Horizontal Scaling","text":"<pre><code># config/initializers/smart_message_workers.rb\nclass SmartMessageWorkers\n  def self.start_for_environment\n    worker_config = case Rails.env\n                   when 'production'\n                     production_workers\n                   when 'staging'\n                     staging_workers\n                   else\n                     development_workers\n                   end\n\n    start_workers(worker_config)\n  end\n\n  private\n\n  def self.production_workers\n    {\n      # High-volume message processing\n      general_workers: {\n        count: ENV.fetch('GENERAL_WORKERS', '8').to_i,\n        consumer_group: 'general_workers',\n        patterns: ['#.*.general_service', '#.*.default']\n      },\n\n      # Critical business processes\n      order_workers: {\n        count: ENV.fetch('ORDER_WORKERS', '4').to_i,\n        consumer_group: 'order_workers',\n        patterns: ['order.#.*.*', '#.*.order_service']\n      },\n\n      # Payment processing\n      payment_workers: {\n        count: ENV.fetch('PAYMENT_WORKERS', '3').to_i,\n        consumer_group: 'payment_workers',\n        patterns: ['payment.#.*.*', '#.*.payment_service']\n      },\n\n      # Email and notifications\n      notification_workers: {\n        count: ENV.fetch('NOTIFICATION_WORKERS', '2').to_i,\n        consumer_group: 'notification_workers',\n        patterns: ['notification.#.*.*', '#.*.notification_service']\n      },\n\n      # Analytics and reporting\n      analytics_workers: {\n        count: ENV.fetch('ANALYTICS_WORKERS', '2').to_i,\n        consumer_group: 'analytics_workers',\n        patterns: ['analytics.#.*.*', '#.*.analytics_service']\n      }\n    }\n  end\n\n  def self.start_workers(worker_config)\n    worker_config.each do |worker_type, config|\n      Rails.logger.info \"Starting #{config[:count]} #{worker_type} workers\"\n\n      config[:count].times do |i|\n        Thread.new do\n          start_worker(worker_type, i + 1, config)\n        end\n      end\n    end\n  end\n\n  def self.start_worker(worker_type, worker_id, config)\n    transport = SmartMessage::Transport::RedisQueueTransport.new(\n      consumer_group: config[:consumer_group],\n      consumer_id: \"#{worker_type}_#{worker_id}_#{Socket.gethostname}\"\n    )\n\n    config[:patterns].each do |pattern|\n      transport.subscribe_pattern(pattern) do |message_class, message_data|\n        Rails.logger.info \"[#{worker_type}_#{worker_id}] Processing: #{message_class}\"\n\n        begin\n          # Process message with timeout\n          Timeout::timeout(30) do\n            process_message(message_class, message_data)\n          end\n        rescue Timeout::Error\n          Rails.logger.error \"[#{worker_type}_#{worker_id}] Timeout processing: #{message_class}\"\n          raise SmartMessage::Errors::RetryableError, 'Processing timeout'\n        rescue =&gt; e\n          Rails.logger.error \"[#{worker_type}_#{worker_id}] Error: #{e.message}\"\n          raise\n        end\n      end\n    end\n\n    Rails.logger.info \"[#{worker_type}_#{worker_id}] Worker started\"\n\n    # Keep worker alive\n    loop { sleep 1 }\n  rescue =&gt; e\n    Rails.logger.error \"[#{worker_type}_#{worker_id}] Worker crashed: #{e.message}\"\n    # Restart worker after delay\n    sleep 5\n    retry\n  end\nend\n\n# Auto-start workers in production\nif Rails.env.production?\n  Thread.new { SmartMessageWorkers.start_for_environment }\nend\n</code></pre>"},{"location":"guides/redis-queue-production/#vertical-scaling","title":"Vertical Scaling","text":"<pre><code># config/initializers/performance_optimization.rb\nmodule SmartMessageOptimization\n  def self.optimize_for_production\n    # Optimize Redis connection pool\n    configure_connection_pool\n\n    # Set up message batching\n    configure_batching\n\n    # Enable compression for large messages\n    configure_compression\n\n    # Set up performance monitoring\n    configure_monitoring\n  end\n\n  private\n\n  def self.configure_connection_pool\n    SmartMessage.configure do |config|\n      config.transport_options.merge!({\n        pool_size: [ENV.fetch('MAX_THREADS', '20').to_i, 50].min,\n        pool_timeout: 10,\n        reconnect_attempts: 3,\n        reconnect_delay: 1\n      })\n    end\n  end\n\n  def self.configure_batching\n    # Process messages in batches for better throughput\n    SmartMessage::Transport::RedisQueueTransport.class_eval do\n      def process_message_batch(messages)\n        messages.each do |message_class, message_data|\n          begin\n            receive(message_class, message_data)\n          rescue =&gt; e\n            Rails.logger.error \"Batch processing error: #{e.message}\"\n          end\n        end\n      end\n    end\n  end\n\n  def self.configure_compression\n    # Enable compression for messages over 1KB\n    SmartMessage.configure do |config|\n      config.serializer_options = {\n        compress_threshold: 1024,\n        compression_method: :gzip\n      }\n    end\n  end\n\n  def self.configure_monitoring\n    # Set up performance metrics collection\n    ActiveSupport::Notifications.subscribe('smartmessage.message_processed') do |*args|\n      event = ActiveSupport::Notifications::Event.new(*args)\n\n      # Log processing time\n      Rails.logger.info \"Message processed in #{event.duration}ms: #{event.payload[:message_class]}\"\n\n      # Send to metrics collector\n      if defined?(Prometheus)\n        SmartMessageMetrics.record_processing_time(event.duration, event.payload[:message_class])\n      end\n    end\n  end\nend\n\nSmartMessageOptimization.optimize_for_production if Rails.env.production?\n</code></pre>"},{"location":"guides/redis-queue-production/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"guides/redis-queue-production/#application-monitoring","title":"Application Monitoring","text":"<pre><code># app/services/smart_message_monitor.rb\nclass SmartMessageMonitor\n  include Singleton\n\n  def initialize\n    @transport = SmartMessage::Transport::RedisQueueTransport.new\n    @metrics = {}\n    start_monitoring\n  end\n\n  def start_monitoring\n    Thread.new { monitor_queues }\n    Thread.new { monitor_workers }\n    Thread.new { monitor_performance }\n  end\n\n  private\n\n  def monitor_queues\n    loop do\n      stats = @transport.queue_stats\n\n      stats.each do |queue_name, info|\n        queue_length = info[:length]\n        consumer_count = info[:consumers] || 0\n\n        # Record metrics\n        @metrics[\"queue.#{queue_name}.length\"] = queue_length\n        @metrics[\"queue.#{queue_name}.consumers\"] = consumer_count\n\n        # Check for alerts\n        if queue_length &gt; 1000\n          alert_high_queue_length(queue_name, queue_length)\n        end\n\n        if queue_length &gt; 0 &amp;&amp; consumer_count == 0\n          alert_no_consumers(queue_name, queue_length)\n        end\n\n        if consumer_count &gt; 20\n          alert_high_consumer_count(queue_name, consumer_count)\n        end\n      end\n\n      # Update external metrics\n      update_external_metrics(@metrics)\n\n      sleep 30  # Check every 30 seconds\n    end\n  end\n\n  def monitor_workers\n    loop do\n      worker_stats = collect_worker_stats\n\n      worker_stats.each do |worker_type, stats|\n        @metrics[\"workers.#{worker_type}.active\"] = stats[:active]\n        @metrics[\"workers.#{worker_type}.processing\"] = stats[:processing]\n        @metrics[\"workers.#{worker_type}.errors\"] = stats[:errors]\n      end\n\n      sleep 60  # Check every minute\n    end\n  end\n\n  def monitor_performance\n    start_time = Time.now\n    processed_messages = 0\n\n    loop do\n      current_processed = get_total_processed_messages\n      duration = Time.now - start_time\n\n      if duration &gt;= 60  # Calculate rate every minute\n        rate = (current_processed - processed_messages) / duration\n        @metrics['performance.messages_per_second'] = rate\n\n        processed_messages = current_processed\n        start_time = Time.now\n      end\n\n      sleep 10\n    end\n  end\n\n  def alert_high_queue_length(queue_name, length)\n    Rails.logger.warn \"HIGH QUEUE LENGTH: #{queue_name} has #{length} messages\"\n\n    # Send to alerting system\n    if defined?(AlertManager)\n      AlertManager.alert(\n        severity: :warning,\n        message: \"Queue #{queue_name} has #{length} messages\",\n        tags: { queue: queue_name, type: :high_queue_length }\n      )\n    end\n  end\n\n  def alert_no_consumers(queue_name, length)\n    Rails.logger.error \"NO CONSUMERS: #{queue_name} has #{length} messages but no consumers\"\n\n    if defined?(AlertManager)\n      AlertManager.alert(\n        severity: :critical,\n        message: \"Queue #{queue_name} has no consumers but #{length} pending messages\",\n        tags: { queue: queue_name, type: :no_consumers }\n      )\n    end\n  end\n\n  def update_external_metrics(metrics)\n    # Send to Prometheus\n    if defined?(Prometheus::Client)\n      metrics.each do |metric_name, value|\n        Prometheus::Client.registry.get(metric_name.to_sym)&amp;.set(value)\n      end\n    end\n\n    # Send to StatsD\n    if defined?(Statsd)\n      metrics.each do |metric_name, value|\n        $statsd&amp;.gauge(\"smartmessage.#{metric_name}\", value)\n      end\n    end\n\n    # Send to CloudWatch\n    if defined?(Aws::CloudWatch)\n      # Implementation for CloudWatch metrics\n    end\n  end\nend\n\n# Start monitoring in production\nSmartMessageMonitor.instance if Rails.env.production?\n</code></pre>"},{"location":"guides/redis-queue-production/#prometheus-metrics","title":"Prometheus Metrics","text":"<pre><code># lib/smart_message_metrics.rb\nrequire 'prometheus/client'\n\nmodule SmartMessageMetrics\n  def self.setup_metrics\n    registry = Prometheus::Client.registry\n\n    @message_processing_duration = registry.histogram(\n      :smartmessage_processing_duration_seconds,\n      docstring: 'Time spent processing messages',\n      labels: [:message_class, :worker_type]\n    )\n\n    @queue_length = registry.gauge(\n      :smartmessage_queue_length,\n      docstring: 'Current queue length',\n      labels: [:queue_name, :pattern]\n    )\n\n    @consumer_count = registry.gauge(\n      :smartmessage_consumer_count,\n      docstring: 'Number of active consumers',\n      labels: [:queue_name, :consumer_group]\n    )\n\n    @messages_processed_total = registry.counter(\n      :smartmessage_messages_processed_total,\n      docstring: 'Total number of messages processed',\n      labels: [:message_class, :status]\n    )\n\n    @connection_errors_total = registry.counter(\n      :smartmessage_connection_errors_total,\n      docstring: 'Total number of Redis connection errors',\n      labels: [:error_type]\n    )\n  end\n\n  def self.record_processing_time(duration_seconds, message_class, worker_type = 'unknown')\n    @message_processing_duration&amp;.observe(duration_seconds, labels: {\n      message_class: message_class,\n      worker_type: worker_type\n    })\n  end\n\n  def self.update_queue_length(queue_name, length, pattern = '')\n    @queue_length&amp;.set(length, labels: {\n      queue_name: queue_name,\n      pattern: pattern\n    })\n  end\n\n  def self.update_consumer_count(queue_name, count, consumer_group = '')\n    @consumer_count&amp;.set(count, labels: {\n      queue_name: queue_name,\n      consumer_group: consumer_group\n    })\n  end\n\n  def self.increment_messages_processed(message_class, status = 'success')\n    @messages_processed_total&amp;.increment(labels: {\n      message_class: message_class,\n      status: status\n    })\n  end\n\n  def self.increment_connection_errors(error_type)\n    @connection_errors_total&amp;.increment(labels: {\n      error_type: error_type\n    })\n  end\nend\n\n# Initialize metrics\nSmartMessageMetrics.setup_metrics if defined?(Prometheus::Client)\n</code></pre>"},{"location":"guides/redis-queue-production/#grafana-dashboard","title":"Grafana Dashboard","text":"<pre><code>{\n  \"dashboard\": {\n    \"id\": null,\n    \"title\": \"SmartMessage Redis Queue Transport\",\n    \"tags\": [\"smartmessage\", \"redis\", \"queues\"],\n    \"timezone\": \"browser\",\n    \"panels\": [\n      {\n        \"title\": \"Queue Lengths\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"smartmessage_queue_length\",\n            \"legendFormat\": \"{{ queue_name }}\"\n          }\n        ],\n        \"yAxes\": [\n          {\n            \"label\": \"Messages\",\n            \"min\": 0\n          }\n        ]\n      },\n      {\n        \"title\": \"Messages Processed per Second\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(smartmessage_messages_processed_total[1m])\",\n            \"legendFormat\": \"{{ message_class }} ({{ status }})\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Processing Duration\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.95, smartmessage_processing_duration_seconds_bucket)\",\n            \"legendFormat\": \"95th percentile\"\n          },\n          {\n            \"expr\": \"histogram_quantile(0.50, smartmessage_processing_duration_seconds_bucket)\",\n            \"legendFormat\": \"50th percentile\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Active Consumers\",\n        \"type\": \"stat\",\n        \"targets\": [\n          {\n            \"expr\": \"sum(smartmessage_consumer_count)\",\n            \"legendFormat\": \"Total Consumers\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Connection Errors\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(smartmessage_connection_errors_total[5m])\",\n            \"legendFormat\": \"{{ error_type }}\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"guides/redis-queue-production/#security","title":"Security","text":""},{"location":"guides/redis-queue-production/#authentication-and-authorization","title":"Authentication and Authorization","text":"<pre><code># config/initializers/redis_security.rb\nclass RedisSecurityConfig\n  def self.configure_for_production\n    SmartMessage.configure do |config|\n      config.transport_options.merge!({\n        # Redis authentication\n        password: ENV.fetch('REDIS_PASSWORD'),\n\n        # SSL/TLS encryption\n        ssl: true,\n        ssl_params: {\n          verify_mode: OpenSSL::SSL::VERIFY_PEER,\n          ca_file: ENV['REDIS_CA_CERT_PATH'],\n          cert: OpenSSL::X509::Certificate.new(File.read(ENV['REDIS_CLIENT_CERT_PATH'])),\n          key: OpenSSL::PKey::RSA.new(File.read(ENV['REDIS_CLIENT_KEY_PATH']))\n        },\n\n        # Network security\n        bind: ENV.fetch('REDIS_BIND_ADDRESS', '127.0.0.1'),\n\n        # Message encryption\n        encrypt_messages: true,\n        encryption_key: ENV.fetch('MESSAGE_ENCRYPTION_KEY')\n      })\n    end\n  end\nend\n\nRedisSecurityConfig.configure_for_production if Rails.env.production?\n</code></pre>"},{"location":"guides/redis-queue-production/#message-encryption","title":"Message Encryption","text":"<pre><code># lib/smart_message_encryption.rb\nmodule SmartMessageEncryption\n  def self.encrypt_message(message_data)\n    key = ENV.fetch('MESSAGE_ENCRYPTION_KEY')\n    cipher = OpenSSL::Cipher.new('AES-256-GCM')\n    cipher.encrypt\n    cipher.key = Base64.decode64(key)\n\n    iv = cipher.random_iv\n    encrypted_data = cipher.update(message_data) + cipher.final\n    auth_tag = cipher.auth_tag\n\n    Base64.encode64({\n      iv: Base64.encode64(iv),\n      data: Base64.encode64(encrypted_data),\n      tag: Base64.encode64(auth_tag)\n    }.to_json)\n  end\n\n  def self.decrypt_message(encrypted_message)\n    key = ENV.fetch('MESSAGE_ENCRYPTION_KEY')\n    parsed = JSON.parse(Base64.decode64(encrypted_message))\n\n    cipher = OpenSSL::Cipher.new('AES-256-GCM')\n    cipher.decrypt\n    cipher.key = Base64.decode64(key)\n    cipher.iv = Base64.decode64(parsed['iv'])\n    cipher.auth_tag = Base64.decode64(parsed['tag'])\n\n    cipher.update(Base64.decode64(parsed['data'])) + cipher.final\n  end\nend\n</code></pre>"},{"location":"guides/redis-queue-production/#deployment","title":"Deployment","text":""},{"location":"guides/redis-queue-production/#docker-configuration","title":"Docker Configuration","text":"<pre><code># Dockerfile\nFROM ruby:3.2-slim\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    libpq-dev \\\n    nodejs \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\nWORKDIR /app\n\n# Install Ruby dependencies\nCOPY Gemfile Gemfile.lock ./\nRUN bundle config --global frozen 1 &amp;&amp; \\\n    bundle install --without development test\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN adduser --disabled-password --gecos '' appuser &amp;&amp; \\\n    chown -R appuser:appuser /app\nUSER appuser\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \\\n    CMD curl -f http://localhost:3000/health || exit 1\n\nEXPOSE 3000\n\nCMD [\"bundle\", \"exec\", \"rails\", \"server\", \"-b\", \"0.0.0.0\"]\n</code></pre>"},{"location":"guides/redis-queue-production/#kubernetes-deployment","title":"Kubernetes Deployment","text":"<pre><code># k8s/smartmessage-app.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: smartmessage-app\n  labels:\n    app: smartmessage-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: smartmessage-app\n  template:\n    metadata:\n      labels:\n        app: smartmessage-app\n    spec:\n      containers:\n      - name: app\n        image: smartmessage-app:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: REDIS_URL\n          value: \"redis://redis-service:6379\"\n        - name: REDIS_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: redis-secret\n              key: password\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: smartmessage-workers\n  labels:\n    app: smartmessage-workers\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: smartmessage-workers\n  template:\n    metadata:\n      labels:\n        app: smartmessage-workers\n    spec:\n      containers:\n      - name: worker\n        image: smartmessage-app:latest\n        command: [\"bundle\", \"exec\", \"ruby\", \"lib/workers/start_workers.rb\"]\n        env:\n        - name: REDIS_URL\n          value: \"redis://redis-service:6379\"\n        - name: WORKER_TYPE\n          value: \"all\"\n        - name: GENERAL_WORKERS\n          value: \"2\"\n        - name: ORDER_WORKERS\n          value: \"1\"\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"200m\"\n</code></pre>"},{"location":"guides/redis-queue-production/#helm-chart","title":"Helm Chart","text":"<pre><code># helm/smartmessage/values.yaml\nreplicaCount: 3\n\nimage:\n  repository: smartmessage\n  tag: latest\n  pullPolicy: IfNotPresent\n\nredis:\n  host: redis-service\n  port: 6379\n  database: 0\n  auth:\n    enabled: true\n    password: \"secure_password\"\n\nworkers:\n  enabled: true\n  replicas: 5\n  types:\n    general: 2\n    order: 1\n    payment: 1\n    notification: 1\n\nresources:\n  app:\n    requests:\n      memory: 512Mi\n      cpu: 250m\n    limits:\n      memory: 1Gi\n      cpu: 500m\n  workers:\n    requests:\n      memory: 256Mi\n      cpu: 100m\n    limits:\n      memory: 512Mi\n      cpu: 200m\n\nautoscaling:\n  enabled: true\n  minReplicas: 3\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 70\n  targetMemoryUtilizationPercentage: 80\n\nmonitoring:\n  enabled: true\n  prometheus:\n    enabled: true\n  grafana:\n    enabled: true\n  alerting:\n    enabled: true\n\ningress:\n  enabled: true\n  className: nginx\n  annotations:\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n  hosts:\n    - host: smartmessage.example.com\n      paths:\n        - path: /\n          pathType: Prefix\n  tls:\n    - secretName: smartmessage-tls\n      hosts:\n        - smartmessage.example.com\n</code></pre>"},{"location":"guides/redis-queue-production/#high-availability","title":"High Availability","text":""},{"location":"guides/redis-queue-production/#redis-sentinel-configuration","title":"Redis Sentinel Configuration","text":"<pre><code># config/redis_sentinel.rb\nclass RedisSentinelConfig\n  def self.configure_high_availability\n    SmartMessage.configure do |config|\n      config.transport_options = {\n        # Sentinel configuration\n        sentinels: [\n          { host: 'sentinel-1.internal', port: 26379 },\n          { host: 'sentinel-2.internal', port: 26379 },\n          { host: 'sentinel-3.internal', port: 26379 }\n        ],\n        name: 'smartmessage-redis',\n        password: ENV['REDIS_PASSWORD'],\n\n        # Failover settings\n        sentinel_timeout: 5,\n        connect_timeout: 5,\n        read_timeout: 5,\n        write_timeout: 5,\n\n        # Retry configuration\n        reconnect_attempts: 5,\n        reconnect_delay: 2,\n\n        # Connection pool for HA\n        pool_size: 20,\n        pool_timeout: 10\n      }\n    end\n  end\nend\n\nRedisSentinelConfig.configure_high_availability if Rails.env.production?\n</code></pre>"},{"location":"guides/redis-queue-production/#disaster-recovery","title":"Disaster Recovery","text":"<pre><code># lib/disaster_recovery.rb\nmodule DisasterRecovery\n  class BackupManager\n    def self.setup_automated_backups\n      # Daily Redis backup\n      whenever_schedule = &lt;&lt;~SCHEDULE\n        # Redis backup every day at 2 AM\n        0 2 * * * cd #{Rails.root} &amp;&amp; bundle exec ruby lib/disaster_recovery/backup_redis.rb\n\n        # Weekly full backup\n        0 1 * * 0 cd #{Rails.root} &amp;&amp; bundle exec ruby lib/disaster_recovery/full_backup.rb\n      SCHEDULE\n\n      File.write('config/schedule.rb', whenever_schedule)\n    end\n\n    def self.backup_redis_data\n      timestamp = Time.current.strftime('%Y%m%d_%H%M%S')\n      backup_file = \"backups/redis_backup_#{timestamp}.rdb\"\n\n      system(\"redis-cli --rdb #{backup_file}\")\n\n      # Upload to S3 or other backup storage\n      if ENV['AWS_S3_BACKUP_BUCKET']\n        upload_to_s3(backup_file)\n      end\n\n      Rails.logger.info \"Redis backup completed: #{backup_file}\"\n    end\n\n    def self.restore_from_backup(backup_file)\n      Rails.logger.info \"Starting Redis restore from: #{backup_file}\"\n\n      # Stop Redis\n      system('sudo systemctl stop redis')\n\n      # Replace RDB file\n      system(\"sudo cp #{backup_file} /var/lib/redis/dump.rdb\")\n      system('sudo chown redis:redis /var/lib/redis/dump.rdb')\n\n      # Start Redis\n      system('sudo systemctl start redis')\n\n      Rails.logger.info \"Redis restore completed\"\n    end\n  end\nend\n</code></pre> <p>This production guide provides the foundation for deploying Redis Queue Transport in enterprise environments. Adapt the configurations based on your specific infrastructure and requirements, always testing thoroughly in staging environments before production deployment.</p>"},{"location":"reference/dead-letter-queue/","title":"Dead Letter Queue","text":"<p>SmartMessage includes a comprehensive file-based Dead Letter Queue (DLQ) system for capturing, storing, and replaying failed messages. The DLQ provides production-grade reliability with automatic integration into the circuit breaker system.</p>"},{"location":"reference/dead-letter-queue/#overview","title":"Overview","text":"<p>The Dead Letter Queue serves as a safety net for your messaging system:</p> <ul> <li>Automatic Capture: Failed messages are automatically stored when circuit breakers trip</li> <li>Manual Capture: Explicitly store messages that fail business logic validation</li> <li>Replay Capabilities: Retry failed messages individually, in batches, or all at once</li> <li>Transport Override: Replay messages through a different transport than originally configured</li> <li>Administrative Tools: Filter, analyze, and export messages for debugging</li> <li>Thread-Safe: All operations are protected with mutex for concurrent access</li> </ul>"},{"location":"reference/dead-letter-queue/#file-format","title":"File Format","text":"<p>The DLQ uses JSON Lines (.jsonl) format - one JSON object per line:</p> <pre><code>{\"timestamp\":\"2025-08-19T10:30:45Z\",\"header\":{...},\"payload\":\"...\",\"error\":\"Connection timeout\",\"retry_count\":0,\"transport\":\"Redis\",\"stack_trace\":\"...\"}\n{\"timestamp\":\"2025-08-19T10:31:12Z\",\"header\":{...},\"payload\":\"...\",\"error\":\"Circuit breaker open\",\"retry_count\":1,\"transport\":\"Redis\",\"stack_trace\":\"...\"}\n</code></pre> <p>Benefits of JSON Lines: - Append-only for efficient writes - Line-by-line processing for memory efficiency - Human-readable for debugging - Easy to process with standard Unix tools</p>"},{"location":"reference/dead-letter-queue/#configuration","title":"Configuration","text":""},{"location":"reference/dead-letter-queue/#global-default-configuration","title":"Global Default Configuration","text":"<p>Configure a default DLQ that all components will use:</p> <pre><code># Set default path for all DLQ operations\nSmartMessage::DeadLetterQueue.configure_default('/var/log/app/dlq.jsonl')\n\n# Access the default instance anywhere\ndlq = SmartMessage::DeadLetterQueue.default\n</code></pre>"},{"location":"reference/dead-letter-queue/#environment-based-configuration","title":"Environment-Based Configuration","text":"<p>Use environment variables for different deployments:</p> <pre><code># In your application initialization\nSmartMessage::DeadLetterQueue.configure_default(\n  ENV.fetch('SMART_MESSAGE_DLQ_PATH', 'dead_letters.jsonl')\n)\n</code></pre>"},{"location":"reference/dead-letter-queue/#per-environment-configuration","title":"Per-Environment Configuration","text":"<p>Configure different paths for each environment:</p> <pre><code># config/initializers/smart_message.rb (Rails example)\ncase Rails.env\nwhen 'production'\n  SmartMessage::DeadLetterQueue.configure_default('/var/log/smart_message/production_dlq.jsonl')\nwhen 'staging'\n  SmartMessage::DeadLetterQueue.configure_default('/var/log/smart_message/staging_dlq.jsonl')\nelse\n  SmartMessage::DeadLetterQueue.configure_default('tmp/development_dlq.jsonl')\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#custom-instances","title":"Custom Instances","text":"<p>Create separate DLQ instances for different purposes:</p> <pre><code># Critical failures need special handling\ncritical_dlq = SmartMessage::DeadLetterQueue.new('/var/log/critical_failures.jsonl')\n\n# Separate DLQ for payment messages\npayment_dlq = SmartMessage::DeadLetterQueue.new('/var/log/payment_failures.jsonl')\n\n# Temporary DLQ for testing\ntest_dlq = SmartMessage::DeadLetterQueue.new('/tmp/test_failures.jsonl')\n</code></pre>"},{"location":"reference/dead-letter-queue/#core-operations","title":"Core Operations","text":""},{"location":"reference/dead-letter-queue/#fifo-queue-operations","title":"FIFO Queue Operations","text":"<p>The DLQ operates as a First-In-First-Out queue:</p> <pre><code>dlq = SmartMessage::DeadLetterQueue.default\n\n# Add a failed message (accepts decoded message instance)\nentry = dlq.enqueue(\n  decoded_message,     # SmartMessage::Base instance\n  error: \"Connection timeout\",\n  retry_count: 0,\n  transport: \"Redis\",\n  stack_trace: exception.backtrace.join(\"\\n\")\n)\n\n# Check queue size\nputs \"Messages in queue: #{dlq.size}\"\n\n# Peek at the oldest message without removing it\nnext_message = dlq.peek\nputs \"Next for replay: #{next_message[:header][:message_class]}\"\n\n# Remove and get the oldest message\nmessage = dlq.dequeue\nprocess_message(message) if message\n\n# Clear all messages\ndlq.clear\n</code></pre>"},{"location":"reference/dead-letter-queue/#message-structure","title":"Message Structure","text":"<p>Each DLQ entry contains:</p> <pre><code>{\n  timestamp: \"2025-08-19T10:30:45Z\",        # When the failure occurred\n  header: {                                 # Complete message header\n    uuid: \"abc-123\",\n    message_class: \"OrderMessage\",\n    published_at: \"2025-08-19T10:30:40Z\",\n    publisher_pid: 12345,\n    version: 1,\n    from: \"order-service\",\n    to: \"payment-service\",\n    reply_to: \"order-service\"\n  },\n  payload: '{\"order_id\":\"123\",\"amount\":99.99}',  # Original message payload\n  payload_format: \"json\",                   # Serialization format\n  error: \"Connection refused\",              # Error message\n  retry_count: 2,                           # Number of retry attempts\n  transport: \"Redis\",                       # Transport that failed\n  stack_trace: \"...\"                        # Full stack trace (optional)\n}\n</code></pre>"},{"location":"reference/dead-letter-queue/#replay-capabilities","title":"Replay Capabilities","text":""},{"location":"reference/dead-letter-queue/#individual-message-replay","title":"Individual Message Replay","text":"<p>Replay the oldest message:</p> <pre><code>result = dlq.replay_one\nif result[:success]\n  puts \"Message replayed successfully\"\nelse\n  puts \"Replay failed: #{result[:error]}\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#batch-replay","title":"Batch Replay","text":"<p>Replay multiple messages:</p> <pre><code># Replay next 10 messages\nresults = dlq.replay_batch(10)\nputs \"Successful: #{results[:success]}\"\nputs \"Failed: #{results[:failed]}\"\nresults[:errors].each do |error|\n  puts \"Error: #{error}\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#full-queue-replay","title":"Full Queue Replay","text":"<p>Replay all messages:</p> <pre><code>results = dlq.replay_all\nputs \"Replayed #{results[:success]} messages\"\nputs \"Failed to replay #{results[:failed]} messages\"\n</code></pre>"},{"location":"reference/dead-letter-queue/#transport-override","title":"Transport Override","text":"<p>Replay through a different transport:</p> <pre><code># Original message used Redis, replay through RabbitMQ\nrabbit_transport = SmartMessage::Transport.create(:rabbitmq)\n\n# Replay one with override\ndlq.replay_one(rabbit_transport)\n\n# Replay batch with override\ndlq.replay_batch(10, rabbit_transport)\n\n# Replay all with override\ndlq.replay_all(rabbit_transport)\n</code></pre>"},{"location":"reference/dead-letter-queue/#administrative-functions","title":"Administrative Functions","text":""},{"location":"reference/dead-letter-queue/#message-filtering","title":"Message Filtering","text":"<p>Filter messages for analysis:</p> <pre><code># Find all failed OrderMessage instances\norder_failures = dlq.filter_by_class('OrderMessage')\nputs \"Found #{order_failures.size} failed orders\"\n\n# Find all timeout errors\ntimeout_errors = dlq.filter_by_error_pattern(/timeout/i)\ntimeout_errors.each do |entry|\n  puts \"Timeout at #{entry[:timestamp]}: #{entry[:error]}\"\nend\n\n# Find connection errors\nconnection_errors = dlq.filter_by_error_pattern('Connection refused')\n</code></pre>"},{"location":"reference/dead-letter-queue/#statistics","title":"Statistics","text":"<p>Get queue statistics:</p> <pre><code>stats = dlq.statistics\nputs \"Total messages: #{stats[:total]}\"\n\n# Breakdown by message class\nstats[:by_class].each do |klass, count|\n  puts \"#{klass}: #{count} failures\"\nend\n\n# Breakdown by error type\nstats[:by_error].sort_by { |_, count| -count }.first(5).each do |error, count|\n  puts \"#{error}: #{count} occurrences\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#time-based-export","title":"Time-Based Export","text":"<p>Export messages within a time range:</p> <pre><code># Get failures from the last hour\none_hour_ago = Time.now - 3600\nrecent_failures = dlq.export_range(one_hour_ago, Time.now)\n\n# Get failures from yesterday\nyesterday_start = Time.now - 86400\nyesterday_end = Time.now - 1\nyesterday_failures = dlq.export_range(yesterday_start, yesterday_end)\n\n# Export for analysis\nFile.write('failures_export.json', recent_failures.to_json)\n</code></pre>"},{"location":"reference/dead-letter-queue/#message-inspection","title":"Message Inspection","text":"<p>Inspect messages without removing them:</p> <pre><code># Look at next 10 messages\nmessages = dlq.inspect_messages(limit: 10)\nmessages.each do |msg|\n  puts \"#{msg[:timestamp]} - #{msg[:header][:message_class]}: #{msg[:error]}\"\nend\n\n# Default limit is 10\ndlq.inspect_messages.each do |msg|\n  analyze_failure(msg)\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#integration-with-circuit-breakers","title":"Integration with Circuit Breakers","text":"<p>The DLQ is automatically integrated with SmartMessage's circuit breaker system:</p>"},{"location":"reference/dead-letter-queue/#automatic-capture","title":"Automatic Capture","text":"<p>When circuit breakers trip, messages are automatically sent to the DLQ:</p> <pre><code>class PaymentMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis)\n    # Circuit breaker configured automatically\n  end\nend\n\n# If Redis is down, circuit breaker trips and message goes to DLQ\nmessage = PaymentMessage.new(amount: 100.00)\nbegin\n  message.publish\nrescue =&gt; e\n  # Message is already in DLQ via circuit breaker\n  puts \"Message saved to DLQ\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#manual-circuit-breaker-integration","title":"Manual Circuit Breaker Integration","text":"<p>Configure custom circuit breakers with DLQ fallback:</p> <pre><code>class CriticalService\n  include BreakerMachines::DSL\n\n  circuit :external_api do\n    threshold failures: 3, within: 60.seconds\n    reset_after 30.seconds\n\n    # Use custom DLQ for critical failures\n    custom_dlq = SmartMessage::DeadLetterQueue.new('/var/log/critical.jsonl')\n    fallback SmartMessage::CircuitBreaker::Fallbacks.dead_letter_queue(custom_dlq)\n  end\n\n  def call_api(message)\n    circuit(:external_api).wrap do\n      # API call that might fail\n      external_api.send(message)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#monitoring-and-alerting","title":"Monitoring and Alerting","text":""},{"location":"reference/dead-letter-queue/#queue-size-monitoring","title":"Queue Size Monitoring","text":"<p>Monitor DLQ growth:</p> <pre><code># Simple monitoring script\nloop do\n  dlq = SmartMessage::DeadLetterQueue.default\n  size = dlq.size\n\n  if size &gt; 100\n    send_alert(\"DLQ size critical: #{size} messages\")\n  elsif size &gt; 50\n    send_warning(\"DLQ size warning: #{size} messages\")\n  end\n\n  sleep 60  # Check every minute\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#error-pattern-detection","title":"Error Pattern Detection","text":"<p>Detect systematic failures:</p> <pre><code>dlq = SmartMessage::DeadLetterQueue.default\nstats = dlq.statistics\n\n# Check for dominant error patterns\ntop_error = stats[:by_error].max_by { |_, count| count }\nif top_error &amp;&amp; top_error[1] &gt; 10\n  alert(\"Systematic failure detected: #{top_error[0]} (#{top_error[1]} occurrences)\")\nend\n\n# Check for specific service failures\nstats[:by_class].each do |klass, count|\n  if count &gt; 5\n    alert(\"Service degradation: #{klass} has #{count} failures\")\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#best-practices","title":"Best Practices","text":""},{"location":"reference/dead-letter-queue/#1-regular-monitoring","title":"1. Regular Monitoring","text":"<p>Set up monitoring for DLQ size and growth rate:</p> <pre><code># Prometheus metrics example\ndlq_size = Prometheus::Client::Gauge.new(:dlq_size, 'Dead letter queue size')\ndlq_size.set(SmartMessage::DeadLetterQueue.default.size)\n</code></pre>"},{"location":"reference/dead-letter-queue/#2-automated-replay","title":"2. Automated Replay","text":"<p>Schedule periodic replay attempts:</p> <pre><code># Sidekiq job example\nclass ReplayDLQJob\n  include Sidekiq::Worker\n\n  def perform\n    dlq = SmartMessage::DeadLetterQueue.default\n\n    # Only replay if queue is manageable\n    if dlq.size &lt; 100\n      results = dlq.replay_all\n      log_results(results)\n    else\n      # Replay in smaller batches\n      results = dlq.replay_batch(10)\n      log_results(results)\n    end\n  end\n\n  private\n\n  def log_results(results)\n    Rails.logger.info(\"DLQ Replay: #{results[:success]} success, #{results[:failed]} failed\")\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#3-archival-strategy","title":"3. Archival Strategy","text":"<p>Archive old messages:</p> <pre><code># Archive messages older than 7 days\ndef archive_old_messages\n  dlq = SmartMessage::DeadLetterQueue.default\n  archive_path = \"/var/archive/dlq_#{Date.today}.jsonl\"\n\n  seven_days_ago = Time.now - (7 * 86400)\n  old_messages = dlq.export_range(Time.at(0), seven_days_ago)\n\n  if old_messages.any?\n    File.write(archive_path, old_messages.map(&amp;:to_json).join(\"\\n\"))\n    # Remove archived messages from active DLQ\n    # (Note: This would require implementing a remove_range method)\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#4-error-classification","title":"4. Error Classification","text":"<p>Classify errors for better handling:</p> <pre><code>class DLQAnalyzer\n  TRANSIENT_ERRORS = [\n    /connection refused/i,\n    /timeout/i,\n    /temporarily unavailable/i\n  ]\n\n  PERMANENT_ERRORS = [\n    /invalid message format/i,\n    /unauthorized/i,\n    /not found/i\n  ]\n\n  def self.classify_errors(dlq)\n    transient = []\n    permanent = []\n\n    dlq.inspect_messages(limit: 100).each do |msg|\n      if TRANSIENT_ERRORS.any? { |pattern| msg[:error].match?(pattern) }\n        transient &lt;&lt; msg\n      elsif PERMANENT_ERRORS.any? { |pattern| msg[:error].match?(pattern) }\n        permanent &lt;&lt; msg\n      end\n    end\n\n    { transient: transient, permanent: permanent }\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/dead-letter-queue/#common-issues","title":"Common Issues","text":""},{"location":"reference/dead-letter-queue/#1-dlq-file-growing-too-large","title":"1. DLQ File Growing Too Large","text":"<pre><code># Rotate DLQ files\ndef rotate_dlq\n  dlq = SmartMessage::DeadLetterQueue.default\n  timestamp = Time.now.strftime('%Y%m%d_%H%M%S')\n\n  # Move current file\n  FileUtils.mv(dlq.file_path, \"#{dlq.file_path}.#{timestamp}\")\n\n  # DLQ will create new file automatically\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#2-replay-failures","title":"2. Replay Failures","text":"<pre><code># Debug replay failures\nresult = dlq.replay_one\nunless result[:success]\n  puts \"Replay failed: #{result[:error]}\"\n\n  # Check if message class still exists\n  message = dlq.peek\n  begin\n    message[:header][:message_class].constantize\n  rescue NameError =&gt; e\n    puts \"Message class no longer exists: #{e.message}\"\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#3-corrupted-dlq-file","title":"3. Corrupted DLQ File","text":"<pre><code># Recover from corrupted file\ndef recover_dlq(corrupted_path)\n  recovered = []\n\n  File.foreach(corrupted_path) do |line|\n    begin\n      entry = JSON.parse(line.strip, symbolize_names: true)\n      recovered &lt;&lt; entry\n    rescue JSON::ParserError\n      # Skip corrupted line\n      puts \"Skipping corrupted line: #{line[0..50]}...\"\n    end\n  end\n\n  # Write recovered entries to new file\n  new_dlq = SmartMessage::DeadLetterQueue.new(\"#{corrupted_path}.recovered\")\n  recovered.each do |entry|\n    new_dlq.enqueue(\n      SmartMessage::Header.new(entry[:header]),\n      entry[:payload],\n      error: entry[:error],\n      retry_count: entry[:retry_count]\n    )\n  end\n\n  puts \"Recovered #{recovered.size} messages\"\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/dead-letter-queue/#file-io-optimization","title":"File I/O Optimization","text":"<p>The DLQ uses several optimizations:</p> <ol> <li>Append-only writes: New messages are appended, not inserted</li> <li>Immediate sync: <code>file.fsync</code> ensures durability</li> <li>Mutex protection: Thread-safe but may create contention</li> <li>Line-based processing: Memory efficient for large files</li> </ol>"},{"location":"reference/dead-letter-queue/#scaling-strategies","title":"Scaling Strategies","text":"<p>For high-volume systems:</p> <pre><code># Use multiple DLQ instances by message type\nclass DLQRouter\n  def self.get_dlq_for(message_class)\n    case message_class\n    when /Payment/\n      @payment_dlq ||= SmartMessage::DeadLetterQueue.new('/var/log/payment_dlq.jsonl')\n    when /Order/\n      @order_dlq ||= SmartMessage::DeadLetterQueue.new('/var/log/order_dlq.jsonl')\n    else\n      SmartMessage::DeadLetterQueue.default\n    end\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#memory-usage","title":"Memory Usage","text":"<p>For large DLQ files:</p> <pre><code># Process in chunks to avoid memory issues\ndef process_large_dlq(dlq, chunk_size: 100)\n  processed = 0\n\n  while dlq.size &gt; 0 &amp;&amp; processed &lt; 1000\n    # Process only chunk_size at a time\n    chunk_size.times do\n      break if dlq.size == 0\n\n      message = dlq.dequeue\n      process_message(message)\n      processed += 1\n    end\n\n    # Let other operations run\n    sleep(0.1)\n  end\n\n  processed\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#security-considerations","title":"Security Considerations","text":""},{"location":"reference/dead-letter-queue/#file-permissions","title":"File Permissions","text":"<p>Ensure proper file permissions:</p> <pre><code># Set restrictive permissions on DLQ files\ndef secure_dlq_file(path)\n  File.chmod(0600, path) if File.exist?(path)  # Read/write for owner only\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#sensitive-data","title":"Sensitive Data","text":"<p>Be careful with sensitive data in DLQ:</p> <pre><code># Sanitize sensitive data before storing\ndef sanitize_for_dlq(payload)\n  data = JSON.parse(payload)\n  data['credit_card'] = 'REDACTED' if data['credit_card']\n  data['password'] = 'REDACTED' if data['password']\n  data.to_json\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#encryption","title":"Encryption","text":"<p>For sensitive environments:</p> <pre><code># Example: Encrypt DLQ entries\nrequire 'openssl'\n\nclass EncryptedDLQ &lt; SmartMessage::DeadLetterQueue\n  def enqueue(header, payload, **options)\n    encrypted_payload = encrypt(payload)\n    super(header, encrypted_payload, **options)\n  end\n\n  def dequeue\n    entry = super\n    return nil unless entry\n\n    entry[:payload] = decrypt(entry[:payload])\n    entry\n  end\n\n  private\n\n  def encrypt(data)\n    # Implement encryption\n  end\n\n  def decrypt(data)\n    # Implement decryption\n  end\nend\n</code></pre>"},{"location":"reference/dead-letter-queue/#summary","title":"Summary","text":"<p>The SmartMessage Dead Letter Queue provides:</p> <ul> <li>Reliability: Automatic capture of failed messages</li> <li>Flexibility: Multiple configuration options</li> <li>Recoverability: Comprehensive replay capabilities</li> <li>Observability: Statistics and filtering for analysis</li> <li>Integration: Seamless circuit breaker integration</li> <li>Production-Ready: Thread-safe, performant, and scalable</li> </ul> <p>The DLQ ensures that no message is lost, even during system failures, and provides the tools needed to analyze, replay, and manage failed messages effectively.</p>"},{"location":"reference/logging/","title":"Logging in SmartMessage","text":"<p>SmartMessage provides comprehensive logging capabilities with support for multiple output formats, colorization, structured logging, and file rolling. Built on the Lumberjack logging framework, it offers production-ready features with flexible configuration options.</p>"},{"location":"reference/logging/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Quick Start</li> <li>Configuration Options</li> <li>Output Formats</li> <li>Colorized Console Output</li> <li>File Rolling</li> <li>Structured Logging</li> <li>Application Integration</li> <li>SmartMessage Integration</li> <li>Examples</li> <li>Best Practices</li> </ul>"},{"location":"reference/logging/#quick-start","title":"Quick Start","text":"<p>Configure SmartMessage logging through the global configuration block:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT              # Output destination\n  config.log_level = :info           # Log level\n  config.log_format = :text          # Format\n  config.log_colorize = true         # Enable colors\nend\n\n# Access the logger in your application\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"Application started\", component: \"main\")\n</code></pre>"},{"location":"reference/logging/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/logging/#global-configuration","title":"Global Configuration","text":"<p>All logging configuration is done through the <code>SmartMessage.configure</code> block:</p> <pre><code>SmartMessage.configure do |config|\n  # Required: Output destination\n  config.logger = STDOUT                    # or file path, STDERR\n\n  # Optional: Logging behavior\n  config.log_level = :info                 # :debug, :info, :warn, :error, :fatal\n  config.log_format = :text                # :text, :json\n  config.log_colorize = true               # Enable colorized console output\n  config.log_include_source = false        # Include file/line information\n  config.log_structured_data = false       # Enable structured metadata\n\n  # Optional: File rolling options\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 10 * 1024 * 1024,       # 10 MB\n    keep_files: 5,                          # Keep 5 old files\n    roll_by_date: false,                    # Alternative: date-based rolling\n    date_pattern: '%Y-%m-%d'                # Daily pattern\n  }\nend\n</code></pre>"},{"location":"reference/logging/#configuration-details","title":"Configuration Details","text":"Option Type Default Description <code>logger</code> String/IO Required Output destination (file path, STDOUT, STDERR) <code>log_level</code> Symbol <code>:info</code> Log level (<code>:debug</code>, <code>:info</code>, <code>:warn</code>, <code>:error</code>, <code>:fatal</code>) <code>log_format</code> Symbol <code>:text</code> Output format (<code>:text</code>, <code>:json</code>) <code>log_colorize</code> Boolean <code>false</code> Enable colorized console output <code>log_include_source</code> Boolean <code>false</code> Include source file and line information <code>log_structured_data</code> Boolean <code>false</code> Enable structured data logging <code>log_options</code> Hash <code>{}</code> Additional Lumberjack options"},{"location":"reference/logging/#output-formats","title":"Output Formats","text":""},{"location":"reference/logging/#text-format-default","title":"Text Format (Default)","text":"<p>Human-readable text output with optional colorization:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_format = :text\n  config.log_colorize = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"User login successful\", user_id: 12345)\n# Output: 2025-01-15 10:30:45 [INFO] User login successful user_id=12345\n</code></pre>"},{"location":"reference/logging/#json-format","title":"JSON Format","text":"<p>Machine-readable structured JSON output:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_format = :json\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"User action\", user_id: 12345, action: \"login\")\n# Output: {\"timestamp\":\"2025-01-15T10:30:45.123Z\",\"level\":\"INFO\",\"message\":\"User action\",\"user_id\":12345,\"action\":\"login\",\"source\":\"app.rb:42:in `authenticate`\"}\n</code></pre>"},{"location":"reference/logging/#colorized-console-output","title":"Colorized Console Output","text":"<p>SmartMessage provides colorized console output for improved readability during development:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_format = :text\n  config.log_colorize = true\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.debug(\"Debug message\")    # Green background, black text, bold\nlogger.info(\"Info message\")      # Bright white text\nlogger.warn(\"Warning message\")   # Yellow background, white bold text\nlogger.error(\"Error message\")    # Light red background, white bold text\nlogger.fatal(\"Fatal message\")    # Light red background, yellow bold text\n</code></pre>"},{"location":"reference/logging/#color-scheme","title":"Color Scheme","text":"Level Foreground Background Style DEBUG Black Green Bold INFO Bright White None None WARN White Yellow Bold ERROR White Light Red Bold FATAL Yellow Light Red Bold <p>Note: Colorization is automatically disabled for file output to keep log files clean.</p>"},{"location":"reference/logging/#file-rolling","title":"File Rolling","text":"<p>SmartMessage supports both size-based and date-based log file rolling:</p>"},{"location":"reference/logging/#size-based-rolling","title":"Size-Based Rolling","text":"<pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 10 * 1024 * 1024,  # 10 MB\n    keep_files: 5                      # Keep 5 old files\n  }\nend\n</code></pre> <p>Files are named: <code>application.log</code>, <code>application.log.1</code>, <code>application.log.2</code>, etc.</p>"},{"location":"reference/logging/#date-based-rolling","title":"Date-Based Rolling","text":"<pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_options = {\n    roll_by_date: true,\n    date_pattern: '%Y-%m-%d'  # Daily rolling\n  }\nend\n</code></pre> <p>Files are named: <code>application.log.2025-01-15</code>, <code>application.log.2025-01-14</code>, etc.</p>"},{"location":"reference/logging/#rolling-options","title":"Rolling Options","text":"Option Type Description <code>roll_by_size</code> Boolean Enable size-based rolling <code>max_file_size</code> Integer Maximum file size in bytes <code>keep_files</code> Integer Number of old files to keep <code>roll_by_date</code> Boolean Enable date-based rolling <code>date_pattern</code> String Date format pattern"},{"location":"reference/logging/#structured-logging","title":"Structured Logging","text":"<p>Enable structured data logging to include metadata with your log entries:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_format = :json\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n\nlogger = SmartMessage.configuration.default_logger\n\n# Log with structured data\nlogger.info(\"User registration\", \n            user_id: \"user123\",\n            email: \"user@example.com\",\n            registration_source: \"web\",\n            timestamp: Time.now.iso8601)\n\n# Log with block for conditional data\nlogger.warn(\"Database slow query\") do\n  {\n    query: \"SELECT * FROM users WHERE status = ?\",\n    duration_ms: 1500,\n    table: \"users\",\n    slow_query: true\n  }\nend\n</code></pre>"},{"location":"reference/logging/#application-integration","title":"Application Integration","text":""},{"location":"reference/logging/#accessing-the-logger","title":"Accessing the Logger","text":"<p>The configured logger is available globally:</p> <pre><code># Get the globally configured logger\nlogger = SmartMessage.configuration.default_logger\n\n# Use in your application\nlogger.info(\"Application starting\", version: \"1.0.0\")\nlogger.warn(\"Configuration missing\", config_key: \"database_url\")\nlogger.error(\"Service unavailable\", service: \"payment_gateway\")\n</code></pre>"},{"location":"reference/logging/#class-level-integration","title":"Class-Level Integration","text":"<pre><code>class OrderService\n  def initialize\n    @logger = SmartMessage.configuration.default_logger\n  end\n\n  def process_order(order)\n    @logger.info(\"Processing order\", \n                 order_id: order.id,\n                 customer_id: order.customer_id,\n                 amount: order.amount)\n\n    begin\n      # Process order logic\n      result = perform_processing(order)\n\n      @logger.info(\"Order completed\", \n                   order_id: order.id,\n                   status: \"success\",\n                   processing_time_ms: result[:duration])\n\n    rescue StandardError =&gt; e\n      @logger.error(\"Order processing failed\",\n                    order_id: order.id,\n                    error: e.message,\n                    error_class: e.class.name)\n      raise\n    end\n  end\nend\n</code></pre>"},{"location":"reference/logging/#smartmessage-integration","title":"SmartMessage Integration","text":"<p>SmartMessage classes automatically use the configured logger:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_id, required: true\n  property :amount, required: true\n\n  config do\n    transport SmartMessage::Transport::StdoutTransport.new\n    serializer SmartMessage::Serializer::Json.new\n    from 'order-service'\n  end\n\n  def process\n    # Logger is automatically available\n    logger.info(\"Processing order message\",\n                message_id: _sm_header.uuid,\n                order_id: order_id,\n                customer_id: customer_id,\n                amount: amount)\n\n    # Log the complete message structure\n    logger.debug(\"Message details\",\n                 header: _sm_header.to_h,\n                 payload: _sm_payload,\n                 full_message: to_h)\n\n    # Process the order\n    case amount\n    when 0..100\n      logger.info(\"Small order processed\", order_id: order_id)\n    when 101..1000\n      logger.warn(\"Medium order requires review\", order_id: order_id)\n    else\n      logger.error(\"Large order requires manual approval\", \n                   order_id: order_id, \n                   amount: amount)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/logging/#examples","title":"Examples","text":""},{"location":"reference/logging/#development-configuration","title":"Development Configuration","text":"<p>Perfect for local development with colorized console output:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_level = :debug\n  config.log_format = :text\n  config.log_colorize = true\n  config.log_include_source = true\nend\n</code></pre>"},{"location":"reference/logging/#production-configuration","title":"Production Configuration","text":"<p>Production setup with JSON logging and file rolling:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = \"/var/log/app/smartmessage.log\"\n  config.log_level = :info\n  config.log_format = :json\n  config.log_colorize = false\n  config.log_structured_data = true\n  config.log_include_source = false\n  config.log_options = {\n    roll_by_size: true,\n    max_file_size: 50 * 1024 * 1024,  # 50 MB\n    keep_files: 10\n  }\nend\n</code></pre>"},{"location":"reference/logging/#dockercontainer-configuration","title":"Docker/Container Configuration","text":"<p>Container-friendly setup with structured STDOUT logging:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDOUT\n  config.log_level = ENV['LOG_LEVEL']&amp;.downcase&amp;.to_sym || :info\n  config.log_format = :json\n  config.log_colorize = false\n  config.log_structured_data = true\n  config.log_include_source = true\nend\n</code></pre>"},{"location":"reference/logging/#testing-configuration","title":"Testing Configuration","text":"<p>Minimal logging for test environments:</p> <pre><code>SmartMessage.configure do |config|\n  config.logger = STDERR\n  config.log_level = :error\n  config.log_format = :text\n  config.log_colorize = false\nend\n</code></pre>"},{"location":"reference/logging/#multiple-logger-configurations","title":"Multiple Logger Configurations","text":"<p>You can create multiple logger instances for different purposes:</p> <pre><code># Configure global logger\nSmartMessage.configure do |config|\n  config.logger = \"log/application.log\"\n  config.log_level = :info\n  config.log_format = :json\nend\n\n# Create additional loggers for specific needs\nconsole_logger = SmartMessage::Logger::Lumberjack.new(\n  log_file: STDERR,\n  level: :warn,\n  format: :text,\n  colorize: true\n)\n\ndebug_logger = SmartMessage::Logger::Lumberjack.new(\n  log_file: \"log/debug.log\",\n  level: :debug,\n  format: :text,\n  include_source: true\n)\n\n# Use in application\nconsole_logger.warn(\"Service degraded\")\ndebug_logger.debug(\"Detailed debugging info\", state: app_state)\n</code></pre>"},{"location":"reference/logging/#best-practices","title":"Best Practices","text":""},{"location":"reference/logging/#1-environment-based-configuration","title":"1. Environment-Based Configuration","text":"<p>Configure logging based on your environment:</p> <pre><code>case ENV['RAILS_ENV'] || ENV['ENVIRONMENT']\nwhen 'production'\n  SmartMessage.configure do |config|\n    config.logger = \"/var/log/app/smartmessage.log\"\n    config.log_level = :info\n    config.log_format = :json\n    config.log_structured_data = true\n    config.log_options = { roll_by_size: true, max_file_size: 50.megabytes, keep_files: 10 }\n  end\nwhen 'development'\n  SmartMessage.configure do |config|\n    config.logger = STDOUT\n    config.log_level = :debug\n    config.log_format = :text\n    config.log_colorize = true\n    config.log_include_source = true\n  end\nwhen 'test'\n  SmartMessage.configure do |config|\n    config.logger = STDERR\n    config.log_level = :error\n    config.log_format = :text\n  end\nend\n</code></pre>"},{"location":"reference/logging/#2-structured-data","title":"2. Structured Data","text":"<p>Use structured data for better log analysis:</p> <pre><code># Good: Structured data\nlogger.info(\"User action\", \n            user_id: user.id, \n            action: \"login\", \n            ip_address: request.ip,\n            user_agent: request.user_agent)\n\n# Avoid: String interpolation\nlogger.info(\"User #{user.id} logged in from #{request.ip}\")\n</code></pre>"},{"location":"reference/logging/#3-appropriate-log-levels","title":"3. Appropriate Log Levels","text":"<p>Use log levels appropriately:</p> <ul> <li>DEBUG: Detailed information for diagnosing problems</li> <li>INFO: General information about program execution</li> <li>WARN: Something unexpected happened, but the application is still working</li> <li>ERROR: A serious problem occurred, but the application can continue</li> <li>FATAL: A very serious error occurred, application may not be able to continue</li> </ul>"},{"location":"reference/logging/#4-performance-considerations","title":"4. Performance Considerations","text":"<ul> <li>Use appropriate log levels in production (avoid DEBUG)</li> <li>Consider async logging for high-volume applications</li> <li>Use structured data instead of string concatenation</li> <li>Be mindful of log volume and storage costs</li> </ul>"},{"location":"reference/logging/#5-security","title":"5. Security","text":"<ul> <li>Never log sensitive data (passwords, tokens, credit card numbers)</li> <li>Sanitize user input before logging</li> <li>Use structured data to avoid log injection attacks</li> </ul> <pre><code># Good: Structured data prevents injection\nlogger.info(\"User input received\", user_input: params[:query])\n\n# Avoid: Direct string interpolation\nlogger.info(\"User searched for: #{params[:query]}\")\n</code></pre>"},{"location":"reference/logging/#6-testing","title":"6. Testing","text":"<p>Test your logging configuration:</p> <pre><code># Test that logs are being generated\nrequire 'stringio'\n\nlog_output = StringIO.new\nSmartMessage.configure do |config|\n  config.logger = log_output\n  config.log_level = :debug\nend\n\nlogger = SmartMessage.configuration.default_logger\nlogger.info(\"Test message\")\n\nassert_includes log_output.string, \"Test message\"\n</code></pre> <p>For more information, see the comprehensive logging examples at <code>examples/memory/15_logger_demo.rb</code> and <code>examples/memory/08_custom_logger_demo.rb</code>.</p>"},{"location":"reference/message-deduplication/","title":"Message Deduplication","text":"<p>SmartMessage provides a comprehensive message deduplication system using Deduplication Queues (DDQ) to prevent duplicate processing of messages with the same UUID. The system is designed with handler-scoped isolation, ensuring that different message handlers maintain independent deduplication state.</p>"},{"location":"reference/message-deduplication/#overview","title":"Overview","text":"<p>Message deduplication in SmartMessage works by:</p> <ol> <li>Handler-Scoped Tracking: Each message handler (subscription) gets its own DDQ instance</li> <li>UUID-Based Detection: Message UUIDs are tracked in circular buffers for O(1) lookup performance</li> <li>Configurable Storage: Support for both memory-based and Redis-based storage backends</li> <li>Automatic Integration: Seamlessly integrates with the existing dispatcher and subscription system</li> </ol>"},{"location":"reference/message-deduplication/#architecture","title":"Architecture","text":""},{"location":"reference/message-deduplication/#handler-only-scoping","title":"Handler-Only Scoping","text":"<p>The key innovation in SmartMessage's deduplication system is handler-only scoping. DDQ keys are automatically derived from the combination of message class and handler method:</p> <pre><code>DDQ Key Format: \"MessageClass:HandlerMethod\"\n</code></pre> <p>Examples: - <code>\"OrderMessage:PaymentService.process\"</code> - <code>\"OrderMessage:FulfillmentService.handle\"</code> - <code>\"InvoiceMessage:PaymentService.process\"</code></p> <p>This design provides: - Natural Isolation: Each handler has its own deduplication context - Cross-Process Support: Same handler across different processes gets isolated DDQs - No Parameter Pollution: No need for explicit subscriber identification in the API</p>"},{"location":"reference/message-deduplication/#ddq-data-structure","title":"DDQ Data Structure","text":"<p>Each DDQ uses a hybrid data structure for optimal performance:</p> <pre><code># Hybrid Array + Set Design\n@circular_array = Array.new(size)  # Maintains insertion order for eviction\n@lookup_set = Set.new              # Provides O(1) UUID lookup\n@index = 0                         # Current insertion position\n</code></pre> <p>Benefits: - O(1) Lookup: Set provides constant-time duplicate detection - O(1) Insertion: Array provides constant-time insertion and eviction - Memory Bounded: Circular buffer automatically evicts oldest entries - Thread Safe: Mutex protection for concurrent access</p>"},{"location":"reference/message-deduplication/#configuration","title":"Configuration","text":""},{"location":"reference/message-deduplication/#basic-setup","title":"Basic Setup","text":"<p>Enable deduplication for a message class:</p> <pre><code>class OrderMessage &lt; SmartMessage::Base\n  version 1\n  property :order_id, required: true\n  property :amount, required: true\n\n  # Configure deduplication\n  ddq_size 100              # Track last 100 UUIDs (default: 100)\n  ddq_storage :memory       # Storage backend (default: :memory)\n  enable_deduplication!     # Enable DDQ for this message class\n\n  def self.process(message)\n    puts \"Processing order: #{message.order_id}\"\n  end\nend\n</code></pre>"},{"location":"reference/message-deduplication/#storage-backends","title":"Storage Backends","text":""},{"location":"reference/message-deduplication/#memory-storage","title":"Memory Storage","text":"<p>Best for single-process applications:</p> <pre><code>class LocalMessage &lt; SmartMessage::Base\n  ddq_size 50\n  ddq_storage :memory\n  enable_deduplication!\nend\n</code></pre> <p>Memory Usage (approximate): - 10 UUIDs: ~480 bytes - 100 UUIDs: ~4.8 KB - 1000 UUIDs: ~48 KB</p>"},{"location":"reference/message-deduplication/#redis-storage","title":"Redis Storage","text":"<p>Best for distributed/multi-process applications:</p> <pre><code>class DistributedMessage &lt; SmartMessage::Base\n  ddq_size 1000\n  ddq_storage :redis, \n    redis_url: 'redis://localhost:6379',\n    redis_db: 1,\n    key_prefix: 'ddq'\n  enable_deduplication!\nend\n</code></pre> <p>Redis DDQ features: - Distributed State: Shared across multiple processes - Persistence: Survives process restarts - TTL Support: Automatic expiration of old entries - Atomic Operations: Transaction safety for concurrent access</p>"},{"location":"reference/message-deduplication/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>ddq_size</code> Integer 100 Maximum UUIDs to track in circular buffer <code>ddq_storage</code> Symbol <code>:memory</code> Storage backend (<code>:memory</code> or <code>:redis</code>) <code>redis_url</code> String <code>'redis://localhost:6379'</code> Redis connection URL <code>redis_db</code> Integer 0 Redis database number <code>key_prefix</code> String <code>'ddq'</code> Prefix for Redis keys <code>ttl</code> Integer 3600 TTL for Redis entries (seconds)"},{"location":"reference/message-deduplication/#usage-examples","title":"Usage Examples","text":""},{"location":"reference/message-deduplication/#multiple-handlers-per-message-class","title":"Multiple Handlers per Message Class","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  ddq_size 200\n  ddq_storage :memory\n  enable_deduplication!\nend\n\n# Each gets separate DDQ tracking\nOrderMessage.subscribe('PaymentService.process')      # DDQ: \"OrderMessage:PaymentService.process\"\nOrderMessage.subscribe('FulfillmentService.handle')   # DDQ: \"OrderMessage:FulfillmentService.handle\"\nOrderMessage.subscribe('AuditService.log_order')      # DDQ: \"OrderMessage:AuditService.log_order\"\n\n# Same UUID can be processed by each handler independently\norder = OrderMessage.new(order_id: \"12345\", amount: 99.99)\norder.publish  # All three handlers will process this message\n</code></pre>"},{"location":"reference/message-deduplication/#cross-message-class-handlers","title":"Cross-Message-Class Handlers","text":"<pre><code>class PaymentService\n  def self.process(message)\n    puts \"PaymentService processing: #{message.class.name}\"\n  end\nend\n\n# Same handler, different message classes = separate DDQs\nOrderMessage.subscribe('PaymentService.process')     # DDQ: \"OrderMessage:PaymentService.process\"\nInvoiceMessage.subscribe('PaymentService.process')   # DDQ: \"InvoiceMessage:PaymentService.process\"\nRefundMessage.subscribe('PaymentService.process')    # DDQ: \"RefundMessage:PaymentService.process\"\n</code></pre>"},{"location":"reference/message-deduplication/#distributed-processing","title":"Distributed Processing","text":"<pre><code># Process A (payment-service-1)\nclass OrderMessage &lt; SmartMessage::Base\n  ddq_storage :redis, redis_url: 'redis://shared-redis:6379'\n  enable_deduplication!\nend\n\nOrderMessage.subscribe('PaymentService.process')\n\n# Process B (payment-service-2)  \n# Same configuration, same handler = shared DDQ in Redis\nOrderMessage.subscribe('PaymentService.process')\n\n# Only one process will handle each unique UUID\n</code></pre>"},{"location":"reference/message-deduplication/#api-reference","title":"API Reference","text":""},{"location":"reference/message-deduplication/#class-methods","title":"Class Methods","text":""},{"location":"reference/message-deduplication/#ddq_sizesize","title":"<code>ddq_size(size)</code>","text":"<p>Configure the maximum number of UUIDs to track: <pre><code>OrderMessage.ddq_size(500)  # Track last 500 UUIDs\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_storagestorage-options","title":"<code>ddq_storage(storage, **options)</code>","text":"<p>Configure the storage backend: <pre><code>OrderMessage.ddq_storage(:memory)\nOrderMessage.ddq_storage(:redis, redis_url: 'redis://localhost:6379', redis_db: 2)\n</code></pre></p>"},{"location":"reference/message-deduplication/#enable_deduplication","title":"<code>enable_deduplication!</code>","text":"<p>Enable deduplication for the message class: <pre><code>OrderMessage.enable_deduplication!\n</code></pre></p>"},{"location":"reference/message-deduplication/#disable_deduplication","title":"<code>disable_deduplication!</code>","text":"<p>Disable deduplication for the message class: <pre><code>OrderMessage.disable_deduplication!\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_enabled","title":"<code>ddq_enabled?</code>","text":"<p>Check if deduplication is enabled: <pre><code>puts OrderMessage.ddq_enabled?  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_config","title":"<code>ddq_config</code>","text":"<p>Get current DDQ configuration: <pre><code>config = OrderMessage.ddq_config\n# =&gt; {enabled: true, size: 100, storage: :memory, options: {}}\n</code></pre></p>"},{"location":"reference/message-deduplication/#ddq_stats","title":"<code>ddq_stats</code>","text":"<p>Get DDQ statistics for all handlers: <pre><code>stats = OrderMessage.ddq_stats\n# =&gt; {enabled: true, current_count: 45, utilization: 45.0, ...}\n</code></pre></p>"},{"location":"reference/message-deduplication/#clear_ddq","title":"<code>clear_ddq!</code>","text":"<p>Clear all DDQ instances for the message class: <pre><code>OrderMessage.clear_ddq!\n</code></pre></p>"},{"location":"reference/message-deduplication/#duplicate_uuiduuid","title":"<code>duplicate_uuid?(uuid)</code>","text":"<p>Check if a UUID is tracked as duplicate: <pre><code>is_dup = OrderMessage.duplicate_uuid?(\"some-uuid-123\")  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#instance-methods","title":"Instance Methods","text":""},{"location":"reference/message-deduplication/#duplicate","title":"<code>duplicate?</code>","text":"<p>Check if this message instance is a duplicate: <pre><code>message = OrderMessage.new(order_id: \"123\", amount: 99.99)\nputs message.duplicate?  # =&gt; true/false\n</code></pre></p>"},{"location":"reference/message-deduplication/#mark_as_processed","title":"<code>mark_as_processed!</code>","text":"<p>Manually mark this message as processed: <pre><code>message.mark_as_processed!  # Adds UUID to DDQ\n</code></pre></p>"},{"location":"reference/message-deduplication/#integration-with-dispatcher","title":"Integration with Dispatcher","text":"<p>The deduplication system integrates seamlessly with SmartMessage's dispatcher:</p>"},{"location":"reference/message-deduplication/#message-flow-with-ddq","title":"Message Flow with DDQ","text":"<ol> <li>Message Receipt: Dispatcher receives decoded message</li> <li>Handler Iteration: For each subscribed handler:</li> <li>DDQ Check: Check handler's DDQ for message UUID</li> <li>Skip Duplicates: If UUID found, log and skip to next handler</li> <li>Process New: If UUID not found, route to handler</li> <li>Mark Processed: After successful processing, add UUID to handler's DDQ</li> </ol>"},{"location":"reference/message-deduplication/#logging","title":"Logging","text":"<p>The dispatcher provides detailed logging for deduplication events:</p> <pre><code>[INFO] [SmartMessage::Dispatcher] Skipping duplicate for PaymentService.process: uuid-123\n[DEBUG] [SmartMessage::Dispatcher] Marked UUID as processed for FulfillmentService.handle: uuid-456\n</code></pre>"},{"location":"reference/message-deduplication/#statistics-integration","title":"Statistics Integration","text":"<p>DDQ statistics are integrated with SmartMessage's built-in statistics system:</p> <pre><code># Access via dispatcher\ndispatcher = SmartMessage::Dispatcher.new\nddq_stats = dispatcher.ddq_stats\n\n# Example output:\n# {\n#   \"OrderMessage:PaymentService.process\" =&gt; {\n#     size: 100, current_count: 23, utilization: 23.0, \n#     storage_type: :memory, implementation: \"SmartMessage::DDQ::Memory\"\n#   },\n#   \"OrderMessage:FulfillmentService.handle\" =&gt; { ... }\n# }\n</code></pre>"},{"location":"reference/message-deduplication/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"reference/message-deduplication/#memory-ddq-performance","title":"Memory DDQ Performance","text":"<ul> <li>Lookup Time: O(1) - Set provides constant-time contains check</li> <li>Insertion Time: O(1) - Array provides constant-time insertion</li> <li>Memory Usage: ~48 bytes per UUID (including Set and Array overhead)</li> <li>Thread Safety: Mutex-protected for concurrent access</li> </ul>"},{"location":"reference/message-deduplication/#redis-ddq-performance","title":"Redis DDQ Performance","text":"<ul> <li>Lookup Time: O(1) - Redis SET provides constant-time membership test</li> <li>Insertion Time: O(1) - Redis LPUSH + LTRIM for circular behavior</li> <li>Network Overhead: 1-2 Redis commands per duplicate check</li> <li>Persistence: Automatic persistence and cross-process sharing</li> </ul>"},{"location":"reference/message-deduplication/#benchmarks","title":"Benchmarks","text":"<p>Memory DDQ (1000 entries): - Memory Usage: ~57 KB - Lookup Performance: 0.001ms average - Insertion Performance: 0.002ms average</p> <p>Redis DDQ (1000 entries): - Memory Usage: Stored in Redis - Lookup Performance: 0.5-2ms average (network dependent) - Insertion Performance: 1-3ms average (network dependent)</p>"},{"location":"reference/message-deduplication/#best-practices","title":"Best Practices","text":""},{"location":"reference/message-deduplication/#1-choose-appropriate-ddq-size","title":"1. Choose Appropriate DDQ Size","text":"<p>Size DDQ based on your message volume and acceptable duplicate window:</p> <pre><code># High-volume service: larger DDQ\nclass HighVolumeMessage &lt; SmartMessage::Base\n  ddq_size 10000  # Track last 10k messages\n  ddq_storage :redis\n  enable_deduplication!\nend\n\n# Low-volume service: smaller DDQ\nclass LowVolumeMessage &lt; SmartMessage::Base\n  ddq_size 50     # Track last 50 messages  \n  ddq_storage :memory\n  enable_deduplication!\nend\n</code></pre>"},{"location":"reference/message-deduplication/#2-use-redis-for-distributed-systems","title":"2. Use Redis for Distributed Systems","text":"<p>For multi-process deployments, always use Redis storage:</p> <pre><code>class DistributedMessage &lt; SmartMessage::Base\n  ddq_storage :redis, \n    redis_url: ENV.fetch('REDIS_URL', 'redis://localhost:6379'),\n    redis_db: ENV.fetch('DDQ_REDIS_DB', 1).to_i\n  enable_deduplication!\nend\n</code></pre>"},{"location":"reference/message-deduplication/#3-monitor-ddq-statistics","title":"3. Monitor DDQ Statistics","text":"<p>Regularly monitor DDQ utilization:</p> <pre><code># In monitoring/health check code\nstats = OrderMessage.ddq_stats\nif stats[:utilization] &gt; 90\n  logger.warn \"DDQ utilization high: #{stats[:utilization]}%\"\nend\n</code></pre>"},{"location":"reference/message-deduplication/#4-handle-ddq-errors-gracefully","title":"4. Handle DDQ Errors Gracefully","text":"<p>The system is designed to fail-open (process messages when DDQ fails):</p> <pre><code># DDQ failures are logged but don't prevent message processing\n# Monitor logs for DDQ-related errors:\n# [ERROR] [SmartMessage::DDQ] Failed to check duplicate: Redis connection error\n</code></pre>"},{"location":"reference/message-deduplication/#troubleshooting","title":"Troubleshooting","text":""},{"location":"reference/message-deduplication/#common-issues","title":"Common Issues","text":""},{"location":"reference/message-deduplication/#1-messages-not-being-deduplicated","title":"1. Messages Not Being Deduplicated","text":"<p>Symptoms: Same UUID processed multiple times by same handler Causes: - Deduplication not enabled: <code>enable_deduplication!</code> missing - Different handlers: Each handler has separate DDQ - DDQ size too small: Old UUIDs evicted too quickly</p> <p>Solutions: <pre><code># Verify deduplication is enabled\nputs OrderMessage.ddq_enabled?  # Should be true\n\n# Check DDQ configuration\nputs OrderMessage.ddq_config\n\n# Increase DDQ size if needed\nOrderMessage.ddq_size(1000)\n</code></pre></p>"},{"location":"reference/message-deduplication/#2-redis-connection-errors","title":"2. Redis Connection Errors","text":"<p>Symptoms: DDQ errors in logs, messages still processing Causes: Redis connectivity issues</p> <p>Solutions: <pre><code># Verify Redis connection\nredis_config = OrderMessage.ddq_config[:options]\nputs \"Redis URL: #{redis_config[:redis_url]}\"\n\n# Test Redis connectivity\nrequire 'redis'\nredis = Redis.new(url: redis_config[:redis_url])\nputs redis.ping  # Should return \"PONG\"\n</code></pre></p>"},{"location":"reference/message-deduplication/#3-high-memory-usage","title":"3. High Memory Usage","text":"<p>Symptoms: Increasing memory usage in memory DDQ Causes: DDQ size too large for available memory</p> <p>Solutions: <pre><code># Check memory usage\nstats = OrderMessage.ddq_stats\nputs \"Memory usage: #{stats[:current_count] * 48} bytes\"\n\n# Reduce DDQ size\nOrderMessage.ddq_size(100)  # Smaller size\n\n# Or switch to Redis\nOrderMessage.ddq_storage(:redis)\n</code></pre></p>"},{"location":"reference/message-deduplication/#debugging-ddq-issues","title":"Debugging DDQ Issues","text":"<pre><code># Enable debug logging\nSmartMessage.configure do |config|\n  config.log_level = :debug\nend\n\n# Check specific UUID\nuuid = \"test-uuid-123\" \nputs \"Is duplicate: #{OrderMessage.duplicate_uuid?(uuid)}\"\n\n# Clear DDQ for testing\nOrderMessage.clear_ddq!\n\n# Monitor DDQ stats\nstats = OrderMessage.ddq_stats\nputs \"Current count: #{stats[:current_count]}\"\nputs \"Utilization: #{stats[:utilization]}%\"\n</code></pre>"},{"location":"reference/message-deduplication/#migration-guide","title":"Migration Guide","text":""},{"location":"reference/message-deduplication/#from-class-level-to-handler-level-ddq","title":"From Class-Level to Handler-Level DDQ","text":"<p>If upgrading from a previous version with class-level deduplication:</p> <p>Before (hypothetical): <pre><code># All handlers shared one DDQ per message class\nOrderMessage.subscribe('PaymentService.process')\nOrderMessage.subscribe('FulfillmentService.handle')\n# Both shared the same DDQ\n</code></pre></p> <p>After (current): <pre><code># Each handler gets its own DDQ automatically\nOrderMessage.subscribe('PaymentService.process')     # DDQ: \"OrderMessage:PaymentService.process\"\nOrderMessage.subscribe('FulfillmentService.handle')  # DDQ: \"OrderMessage:FulfillmentService.handle\"\n# Separate DDQs with isolated tracking\n</code></pre></p> <p>Benefits of Migration: - Better Isolation: Handler failures don't affect other handlers' deduplication - Flexible Filtering: Different handlers can have different subscription filters - Cross-Process Safety: Handlers with same name across processes get separate DDQs</p> <p>The migration is automatic - no code changes required. The new system provides better isolation and reliability.</p>"},{"location":"reference/proc-handlers/","title":"SmartMessage Proc and Block Handlers - Implementation Summary","text":""},{"location":"reference/proc-handlers/#overview","title":"Overview","text":"<p>This document summarizes the enhanced subscription functionality added to SmartMessage, which extends the framework to support multiple message handler patterns including blocks, procs, and lambdas alongside the existing default and method handlers.</p>"},{"location":"reference/proc-handlers/#new-features-added","title":"New Features Added","text":""},{"location":"reference/proc-handlers/#1-enhanced-subscribe-method","title":"1. Enhanced <code>subscribe</code> Method","text":"<p>The <code>subscribe</code> method in <code>SmartMessage::Base</code> now supports multiple parameter types:</p> <pre><code># Original functionality (still works)\nMyMessage.subscribe                           # Default: \"MyMessage.process\"\nMyMessage.subscribe(\"Service.handle_message\") # Method handler\n\n# NEW functionality\nMyMessage.subscribe do |header, payload|     # Block handler\n  # Inline processing logic\nend\n\nMyMessage.subscribe(proc { |h,p| ... })      # Proc handler\nMyMessage.subscribe(lambda { |h,p| ... })    # Lambda handler\n</code></pre>"},{"location":"reference/proc-handlers/#2-proc-registry-system","title":"2. Proc Registry System","text":"<ul> <li>Storage: <code>@@proc_handlers</code> class variable stores all proc-based handlers</li> <li>Unique IDs: Each proc handler gets a unique identifier like <code>\"MessageClass.proc_abc123\"</code></li> <li>Cleanup: Automatic cleanup when unsubscribing proc handlers</li> <li>Registry Management: Helper methods for registration, lookup, and cleanup</li> </ul>"},{"location":"reference/proc-handlers/#3-enhanced-dispatcher-routing","title":"3. Enhanced Dispatcher Routing","text":"<p>The dispatcher (<code>lib/smart_message/dispatcher.rb</code>) now handles multiple handler types:</p> <pre><code>def route(message_header, message_payload)\n  @subscribers[message_klass].each do |message_processor|\n    @router_pool.post do\n      if proc_handler?(message_processor)\n        # Route to proc handler\n        SmartMessage::Base.call_proc_handler(message_processor, message_header, message_payload)\n      else\n        # Route to method handler (original logic)\n        target_klass.constantize.method(class_method).call(message_header, message_payload)\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"reference/proc-handlers/#implementation-details","title":"Implementation Details","text":""},{"location":"reference/proc-handlers/#core-files-modified","title":"Core Files Modified","text":"<ol> <li><code>lib/smart_message/base.rb</code>:</li> <li>Enhanced <code>subscribe</code> method with block and proc support</li> <li>Added proc registry management (<code>@@proc_handlers</code>)</li> <li>Added helper methods: <code>register_proc_handler</code>, <code>call_proc_handler</code>, <code>unregister_proc_handler</code>, <code>proc_handler?</code></li> <li> <p>Updated <code>unsubscribe</code> method to clean up proc handlers</p> </li> <li> <p><code>lib/smart_message/dispatcher.rb</code>:</p> </li> <li>Updated <code>route</code> method to handle both method and proc handlers</li> <li>Added <code>proc_handler?</code> check for routing decisions</li> <li>Maintained thread safety and error handling</li> </ol>"},{"location":"reference/proc-handlers/#handler-type-identification","title":"Handler Type Identification","text":"<ul> <li>Method handlers: String format <code>\"ClassName.method_name\"</code></li> <li>Proc handlers: String format <code>\"ClassName.proc_[hex_id]\"</code> stored in <code>@@proc_handlers</code> registry</li> <li>Default handlers: String format <code>\"ClassName.process\"</code></li> </ul>"},{"location":"reference/proc-handlers/#return-values","title":"Return Values","text":"<p>All subscription methods return identifiers for unsubscription:</p> <pre><code>default_id = MyMessage.subscribe                    # \"MyMessage.process\"\nmethod_id = MyMessage.subscribe(\"Service.handle\")   # \"Service.handle\"\nblock_id = MyMessage.subscribe { |h,p| }            # \"MyMessage.proc_abc123\"\nproc_id = MyMessage.subscribe(my_proc)              # \"MyMessage.proc_def456\"\n\n# All can be unsubscribed using the returned ID\nMyMessage.unsubscribe(block_id)\n</code></pre>"},{"location":"reference/proc-handlers/#testing-coverage","title":"Testing Coverage","text":""},{"location":"reference/proc-handlers/#unit-tests-testproc_handler_testrb","title":"Unit Tests (<code>test/proc_handler_test.rb</code>)","text":"<ul> <li>Default handler compatibility</li> <li>Block handler functionality</li> <li>Proc parameter handler functionality</li> <li>Lambda handler functionality</li> <li>Multiple handlers for same message type</li> <li>Mixed handler types (method + proc)</li> <li>Handler unsubscription and cleanup</li> <li>Error handling in proc handlers</li> <li>Complex logic processing</li> <li>Return value handling</li> </ul>"},{"location":"reference/proc-handlers/#integration-tests-testproc_handler_integration_testrb","title":"Integration Tests (<code>test/proc_handler_integration_test.rb</code>)","text":"<ul> <li>End-to-end testing with real transports (Memory, Stdout)</li> <li>Multiple proc handlers with concurrent execution</li> <li>Error handling and graceful degradation</li> <li>Handler lifecycle management</li> <li>Mixed handler type integration</li> <li>Lambda vs proc behavior</li> <li>Concurrent execution verification</li> </ul>"},{"location":"reference/proc-handlers/#test-results","title":"Test Results","text":"<ul> <li>55 total tests (10 new proc handler tests + existing tests)</li> <li>276 assertions</li> <li>All tests passing</li> <li>Full backward compatibility maintained</li> </ul>"},{"location":"reference/proc-handlers/#documentation-updates","title":"Documentation Updates","text":""},{"location":"reference/proc-handlers/#1-main-readmemd","title":"1. Main README.md","text":"<ul> <li>Updated Quick Start section with new subscription examples</li> <li>Enhanced Features section</li> <li>Updated Message Lifecycle section</li> </ul>"},{"location":"reference/proc-handlers/#2-getting-started-guide-docsgetting-startedmd","title":"2. Getting Started Guide (<code>docs/getting-started.md</code>)","text":"<ul> <li>Added comprehensive handler types section</li> <li>Updated subscription examples</li> <li>Added guidance on when to use each handler type</li> </ul>"},{"location":"reference/proc-handlers/#3-architecture-documentation-docsarchitecturemd","title":"3. Architecture Documentation (<code>docs/architecture.md</code>)","text":"<ul> <li>Updated system architecture diagram</li> <li>Enhanced message processing section</li> <li>Added handler routing process details</li> </ul>"},{"location":"reference/proc-handlers/#4-dispatcher-documentation-docsdispatchermd","title":"4. Dispatcher Documentation (<code>docs/dispatcher.md</code>)","text":"<ul> <li>Updated subscription management section</li> <li>Enhanced message routing process</li> <li>Added handler type processing details</li> </ul>"},{"location":"reference/proc-handlers/#5-examples-documentation-examplesreadmemd","title":"5. Examples Documentation (<code>examples/README.md</code>)","text":"<ul> <li>Added new proc handler example description</li> <li>Updated examples overview</li> <li>Added handler pattern demonstrations</li> </ul>"},{"location":"reference/proc-handlers/#6-new-comprehensive-guide-docsmessage_processingmd","title":"6. New Comprehensive Guide (<code>docs/message_processing.md</code>)","text":"<ul> <li>Complete guide to all handler types</li> <li>Best practices and use cases</li> <li>Performance considerations</li> <li>Error handling patterns</li> </ul>"},{"location":"reference/proc-handlers/#examples","title":"Examples","text":""},{"location":"reference/proc-handlers/#1-new-working-example-examplesmemory07_proc_handlers_demorb","title":"1. New Working Example (<code>examples/memory/07_proc_handlers_demo.rb</code>)","text":"<p>Complete demonstration of all handler types: - Default handler (self.process) - Block handlers (inline logic) - Proc handlers (reusable logic) - Lambda handlers (functional style) - Method handlers (service classes) - Handler management and unsubscription</p>"},{"location":"reference/proc-handlers/#2-enhanced-iot-example-examplesredis01_smart_home_iot_demorb","title":"2. Enhanced IoT Example (<code>examples/redis/01_smart_home_iot_demo.rb</code>)","text":"<p>Production-ready Redis transport example showing real-world usage patterns.</p>"},{"location":"reference/proc-handlers/#benefits-delivered","title":"Benefits Delivered","text":""},{"location":"reference/proc-handlers/#1-flexibility","title":"1. Flexibility","text":"<ul> <li>Choose the right handler pattern for each use case</li> <li>Mix multiple handler types for the same message</li> <li>Easy migration path from simple to complex handlers</li> </ul>"},{"location":"reference/proc-handlers/#2-developer-experience","title":"2. Developer Experience","text":"<ul> <li>Intuitive block syntax for simple cases</li> <li>Reusable proc handlers for cross-cutting concerns</li> <li>Organized method handlers for complex business logic</li> <li>Clear return values for handler management</li> </ul>"},{"location":"reference/proc-handlers/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient proc registry with minimal overhead</li> <li>Thread-safe concurrent processing</li> <li>No impact on existing method handler performance</li> </ul>"},{"location":"reference/proc-handlers/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Clean separation between handler types</li> <li>Proper cleanup and memory management</li> <li>Comprehensive error handling</li> <li>Full backward compatibility</li> </ul>"},{"location":"reference/proc-handlers/#production-considerations","title":"Production Considerations","text":""},{"location":"reference/proc-handlers/#1-handler-selection-guidelines","title":"1. Handler Selection Guidelines","text":"<ul> <li>Default handlers: Simple built-in processing</li> <li>Block handlers: Quick inline logic, prototyping</li> <li>Proc handlers: Reusable cross-message functionality (auditing, logging)</li> <li>Method handlers: Complex business logic, organized service classes</li> </ul>"},{"location":"reference/proc-handlers/#2-memory-management","title":"2. Memory Management","text":"<ul> <li>Proc handlers are stored in class variables and persist until explicitly unsubscribed</li> <li>Use returned handler IDs for proper cleanup</li> <li>Consider memory usage with many long-lived proc handlers</li> </ul>"},{"location":"reference/proc-handlers/#3-performance_1","title":"3. Performance","text":"<ul> <li>Proc handlers have minimal overhead vs method handlers</li> <li>All handlers execute in parallel threads</li> <li>No impact on existing code performance</li> </ul>"},{"location":"reference/proc-handlers/#4-error-handling","title":"4. Error Handling","text":"<ul> <li>Proc handler errors are isolated and don't crash the dispatcher</li> <li>Same error handling patterns as method handlers</li> <li>Debug output available for troubleshooting</li> </ul>"},{"location":"reference/proc-handlers/#migration-path","title":"Migration Path","text":""},{"location":"reference/proc-handlers/#for-existing-code","title":"For Existing Code","text":"<ul> <li>No changes required - all existing code continues to work</li> <li>Gradual adoption - can introduce proc handlers incrementally</li> <li>Mixed usage - can use multiple handler types simultaneously</li> </ul>"},{"location":"reference/proc-handlers/#for-new-development","title":"For New Development","text":"<ul> <li>Start with defaults for simple cases</li> <li>Use blocks for quick inline processing</li> <li>Use procs for reusable functionality</li> <li>Use methods for complex business logic</li> </ul>"},{"location":"reference/proc-handlers/#future-enhancements","title":"Future Enhancements","text":"<p>Potential areas for future development:</p> <ul> <li>Handler priority/ordering</li> <li>Conditional handler execution</li> <li>Handler metrics and monitoring</li> <li>Dynamic handler registration/deregistration</li> <li>Handler middleware/interceptors</li> </ul>"},{"location":"reference/proc-handlers/#conclusion","title":"Conclusion","text":"<p>The enhanced subscription functionality provides SmartMessage users with powerful, flexible options for message processing while maintaining the simplicity and elegance of the original design. The implementation is production-ready, thoroughly tested, and fully documented.</p> <p>This enhancement positions SmartMessage as a more versatile and developer-friendly messaging framework suitable for both simple prototypes and complex enterprise applications.</p>"},{"location":"reference/serializers/","title":"Serializers","text":"<p>Serializers handle the encoding and decoding of message content, transforming Ruby objects into wire formats suitable for transmission and storage.</p>"},{"location":"reference/serializers/#overview","title":"Overview","text":"<p>Serializers are responsible for: - Encoding: Converting SmartMessage instances to transmittable formats - Decoding: Converting received data back to Ruby objects - Format Support: Handling different data formats (JSON, XML, MessagePack, etc.) - Type Safety: Ensuring data integrity during conversion</p>"},{"location":"reference/serializers/#built-in-serializers","title":"Built-in Serializers","text":""},{"location":"reference/serializers/#json-serializer","title":"JSON Serializer","text":"<p>The default serializer that converts messages to/from JSON format.</p> <p>Features: - Human-readable output - Wide compatibility  - Built on Ruby's standard JSON library - Automatic property serialization</p> <p>Usage:</p> <pre><code># Basic usage\nserializer = SmartMessage::Serializer::Json.new\n\n# Configure in message class\nclass UserMessage &lt; SmartMessage::Base\n  property :user_id\n  property :email\n  property :preferences\n\n  config do\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# Manual encoding/decoding\nmessage = UserMessage.new(user_id: 123, email: \"user@example.com\")\nencoded = serializer.encode(message)\n# =&gt; '{\"user_id\":123,\"email\":\"user@example.com\",\"preferences\":null}'\n</code></pre> <p>Encoding Behavior: - All defined properties are included - Nil values are preserved - Internal <code>_sm_</code> properties are included in serialization - Uses Ruby's <code>#to_json</code> method under the hood</p>"},{"location":"reference/serializers/#serializer-interface","title":"Serializer Interface","text":"<p>All serializers must implement the <code>SmartMessage::Serializer::Base</code> interface:</p>"},{"location":"reference/serializers/#required-methods","title":"Required Methods","text":"<pre><code>class CustomSerializer &lt; SmartMessage::Serializer::Base\n  def initialize(options = {})\n    @options = options\n    # Custom initialization\n  end\n\n  # Convert SmartMessage instance to wire format\n  def encode(message_instance)\n    # Transform message_instance to your format\n    # Return string or binary data\n  end\n\n  # Convert wire format back to hash\n  def decode(payload)\n    # Transform payload string back to hash\n    # Return hash suitable for SmartMessage.new(hash)\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#example-messagepack-serializer","title":"Example: MessagePack Serializer","text":"<pre><code>require 'msgpack'\n\nclass MessagePackSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    message_instance.to_h.to_msgpack\n  end\n\n  def decode(payload)\n    MessagePack.unpack(payload)\n  end\nend\n\n# Usage\nclass BinaryMessage &lt; SmartMessage::Base\n  property :data\n  property :timestamp\n\n  config do\n    serializer MessagePackSerializer.new\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#example-xml-serializer","title":"Example: XML Serializer","text":"<pre><code>require 'nokogiri'\n\nclass XMLSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    data = message_instance.to_h\n    builder = Nokogiri::XML::Builder.new do |xml|\n      xml.message do\n        data.each do |key, value|\n          xml.send(key, value)\n        end\n      end\n    end\n    builder.to_xml\n  end\n\n  def decode(payload)\n    doc = Nokogiri::XML(payload)\n    hash = {}\n    doc.xpath('//message/*').each do |node|\n      hash[node.name] = node.text\n    end\n    hash\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#serialization-patterns","title":"Serialization Patterns","text":""},{"location":"reference/serializers/#type-coercion","title":"Type Coercion","text":"<p>Handle type conversions during serialization:</p> <pre><code>class TypedSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    data = message_instance.to_h\n\n    # Convert specific types\n    data.transform_values do |value|\n      case value\n      when Time\n        value.iso8601\n      when Date\n        value.to_s\n      when BigDecimal\n        value.to_f\n      else\n        value\n      end\n    end.to_json\n  end\n\n  def decode(payload)\n    data = JSON.parse(payload)\n\n    # Convert back from strings\n    data.transform_values do |value|\n      case value\n      when /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}/\n        Time.parse(value)\n      else\n        value\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#nested-object-serialization","title":"Nested Object Serialization","text":"<p>Handle complex nested structures:</p> <pre><code>class NestedSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    data = deep_serialize(message_instance.to_h)\n    JSON.generate(data)\n  end\n\n  def decode(payload)\n    data = JSON.parse(payload)\n    deep_deserialize(data)\n  end\n\n  private\n\n  def deep_serialize(obj)\n    case obj\n    when Hash\n      obj.transform_values { |v| deep_serialize(v) }\n    when Array\n      obj.map { |v| deep_serialize(v) }\n    when SmartMessage::Base\n      # Serialize nested messages\n      obj.to_h\n    else\n      obj\n    end\n  end\n\n  def deep_deserialize(obj)\n    case obj\n    when Hash\n      obj.transform_values { |v| deep_deserialize(v) }\n    when Array\n      obj.map { |v| deep_deserialize(v) }\n    else\n      obj\n    end\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#serialization-options","title":"Serialization Options","text":""},{"location":"reference/serializers/#configurable-serializers","title":"Configurable Serializers","text":"<pre><code>class ConfigurableJSONSerializer &lt; SmartMessage::Serializer::Base\n  def initialize(options = {})\n    @pretty = options[:pretty] || false\n    @exclude_nil = options[:exclude_nil] || false\n    @date_format = options[:date_format] || :iso8601\n  end\n\n  def encode(message_instance)\n    data = message_instance.to_h\n\n    # Remove nil values if requested\n    data = data.compact if @exclude_nil\n\n    # Format dates\n    data = format_dates(data)\n\n    # Generate JSON\n    if @pretty\n      JSON.pretty_generate(data)\n    else\n      JSON.generate(data)\n    end\n  end\n\n  private\n\n  def format_dates(data)\n    data.transform_values do |value|\n      case value\n      when Time, Date\n        case @date_format\n        when :iso8601\n          value.iso8601\n        when :unix\n          value.to_i\n        when :rfc2822\n          value.rfc2822\n        else\n          value.to_s\n        end\n      else\n        value\n      end\n    end\n  end\nend\n\n# Usage with options\nclass TimestampMessage &lt; SmartMessage::Base\n  property :event\n  property :timestamp\n\n  config do\n    serializer ConfigurableJSONSerializer.new(\n      pretty: true,\n      exclude_nil: true,\n      date_format: :unix\n    )\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#error-handling","title":"Error Handling","text":""},{"location":"reference/serializers/#serialization-errors","title":"Serialization Errors","text":"<p>Handle encoding/decoding failures gracefully:</p> <pre><code>class SafeSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    JSON.generate(message_instance.to_h)\n  rescue JSON::GeneratorError =&gt; e\n    # Log the error\n    puts \"Serialization failed: #{e.message}\"\n\n    # Fallback to simple string representation\n    message_instance.to_h.to_s\n  end\n\n  def decode(payload)\n    JSON.parse(payload)\n  rescue JSON::ParserError =&gt; e\n    # Log the error\n    puts \"Deserialization failed: #{e.message}\"\n\n    # Return error indicator or empty hash\n    { \"_error\" =&gt; \"Failed to deserialize: #{e.message}\" }\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#validation-during-serialization","title":"Validation During Serialization","text":"<pre><code>class ValidatingSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    validate_before_encoding(message_instance)\n    JSON.generate(message_instance.to_h)\n  end\n\n  def decode(payload)\n    data = JSON.parse(payload)\n    validate_after_decoding(data)\n    data\n  end\n\n  private\n\n  def validate_before_encoding(message)\n    required_fields = message.class.properties.select do |prop|\n      message.class.required?(prop)\n    end\n\n    missing = required_fields.select { |field| message[field].nil? }\n\n    if missing.any?\n      raise \"Missing required fields: #{missing.join(', ')}\"\n    end\n  end\n\n  def validate_after_decoding(data)\n    unless data.is_a?(Hash)\n      raise \"Expected hash, got #{data.class}\"\n    end\n\n    # Additional validation logic\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/serializers/#binary-serialization","title":"Binary Serialization","text":"<p>For high-performance scenarios, consider binary formats:</p> <pre><code>class ProtobufSerializer &lt; SmartMessage::Serializer::Base\n  def initialize(proto_class)\n    @proto_class = proto_class\n  end\n\n  def encode(message_instance)\n    proto_obj = @proto_class.new(message_instance.to_h)\n    proto_obj.serialize_to_string\n  end\n\n  def decode(payload)\n    proto_obj = @proto_class.parse(payload)\n    proto_obj.to_h\n  end\nend\n\n# Usage\nUserProto = Google::Protobuf::DescriptorPool.generated_pool.lookup(\"User\").msgclass\n\nclass UserMessage &lt; SmartMessage::Base\n  property :user_id\n  property :name\n\n  config do\n    serializer ProtobufSerializer.new(UserProto)\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#streaming-serialization","title":"Streaming Serialization","text":"<p>For large messages, consider streaming:</p> <pre><code>class StreamingSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    StringIO.new.tap do |io|\n      JSON.dump(message_instance.to_h, io)\n    end.string\n  end\n\n  def decode(payload)\n    StringIO.new(payload).tap do |io|\n      JSON.load(io)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#compression-support","title":"Compression Support","text":""},{"location":"reference/serializers/#compressed-serialization","title":"Compressed Serialization","text":"<pre><code>class CompressedJSONSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    json_data = JSON.generate(message_instance.to_h)\n    Zlib::Deflate.deflate(json_data)\n  end\n\n  def decode(payload)\n    json_data = Zlib::Inflate.inflate(payload)\n    JSON.parse(json_data)\n  end\nend\n\n# Usage for large messages\nclass LargeDataMessage &lt; SmartMessage::Base\n  property :dataset\n  property :metadata\n\n  config do\n    serializer CompressedJSONSerializer.new\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#testing-serializers","title":"Testing Serializers","text":""},{"location":"reference/serializers/#serializer-testing-patterns","title":"Serializer Testing Patterns","text":"<pre><code>RSpec.describe CustomSerializer do\n  let(:serializer) { CustomSerializer.new }\n  let(:message) do\n    TestMessage.new(\n      user_id: 123,\n      email: \"test@example.com\",\n      created_at: Time.parse(\"2025-08-17T10:30:00Z\")\n    )\n  end\n\n  describe \"#encode\" do\n    it \"produces valid output\" do\n      result = serializer.encode(message)\n      expect(result).to be_a(String)\n      expect(result).not_to be_empty\n    end\n\n    it \"includes all properties\" do\n      result = serializer.encode(message)\n      # Format-specific assertions\n    end\n  end\n\n  describe \"#decode\" do\n    it \"roundtrips correctly\" do\n      encoded = serializer.encode(message)\n      decoded = serializer.decode(encoded)\n\n      expect(decoded[\"user_id\"]).to eq(123)\n      expect(decoded[\"email\"]).to eq(\"test@example.com\")\n    end\n  end\n\n  describe \"error handling\" do\n    it \"handles invalid input gracefully\" do\n      expect { serializer.decode(\"invalid\") }.not_to raise_error\n    end\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#mock-serializer-for-testing","title":"Mock Serializer for Testing","text":"<pre><code>class MockSerializer &lt; SmartMessage::Serializer::Base\n  attr_reader :encoded_messages, :decoded_payloads\n\n  def initialize\n    @encoded_messages = []\n    @decoded_payloads = []\n  end\n\n  def encode(message_instance)\n    @encoded_messages &lt;&lt; message_instance\n    \"mock_encoded_#{message_instance.object_id}\"\n  end\n\n  def decode(payload)\n    @decoded_payloads &lt;&lt; payload\n    { \"mock\" =&gt; \"decoded\", \"payload\" =&gt; payload }\n  end\n\n  def clear\n    @encoded_messages.clear\n    @decoded_payloads.clear\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#common-serialization-issues","title":"Common Serialization Issues","text":""},{"location":"reference/serializers/#handling-special-values","title":"Handling Special Values","text":"<pre><code>class RobustJSONSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    data = sanitize_for_json(message_instance.to_h)\n    JSON.generate(data)\n  end\n\n  private\n\n  def sanitize_for_json(obj)\n    case obj\n    when Hash\n      obj.transform_values { |v| sanitize_for_json(v) }\n    when Array\n      obj.map { |v| sanitize_for_json(v) }\n    when Float\n      return nil if obj.nan? || obj.infinite?\n      obj\n    when BigDecimal\n      obj.to_f\n    when Symbol\n      obj.to_s\n    when Complex, Rational\n      obj.to_f\n    else\n      obj\n    end\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#character-encoding","title":"Character Encoding","text":"<pre><code>class EncodingAwareSerializer &lt; SmartMessage::Serializer::Base\n  def encode(message_instance)\n    data = message_instance.to_h\n    json = JSON.generate(data)\n    json.force_encoding('UTF-8')\n  end\n\n  def decode(payload)\n    # Ensure proper encoding\n    payload = payload.force_encoding('UTF-8')\n    JSON.parse(payload)\n  end\nend\n</code></pre>"},{"location":"reference/serializers/#next-steps","title":"Next Steps","text":"<ul> <li>Transports - How serializers work with transports</li> <li>Examples - Real-world serialization patterns</li> </ul>"},{"location":"reference/transports/","title":"Transport Layer","text":"<p>The transport layer is responsible for moving messages between systems. SmartMessage provides a pluggable transport architecture that supports various backend systems.</p>"},{"location":"reference/transports/#overview","title":"Overview","text":"<p>Transports handle: - Publishing: Sending messages to a destination - Subscribing: Registering interest in message types - Routing: Directing incoming messages to the dispatcher - Connection Management: Handling connections to external systems</p>"},{"location":"reference/transports/#built-in-transports","title":"Built-in Transports","text":""},{"location":"reference/transports/#stdout-transport","title":"STDOUT Transport","text":"<p>Perfect for development, debugging, and logging scenarios.</p> <p>Features: - Outputs messages to console or file - Optional loopback for testing subscriptions - Human-readable message formatting - No external dependencies</p> <p>Usage:</p> <pre><code># Basic STDOUT output\ntransport = SmartMessage::Transport.create(:stdout)\n\n# With loopback enabled (messages get processed locally)\ntransport = SmartMessage::Transport.create(:stdout, loopback: true)\n\n# Output to file instead of console\ntransport = SmartMessage::Transport.create(:stdout, output: \"messages.log\")\n\n# Configure in message class\nclass LogMessage &lt; SmartMessage::Base\n  property :level\n  property :message\n\n  config do\n    transport SmartMessage::Transport.create(:stdout, \n      output: \"app.log\",\n      loopback: false\n    )\n  end\nend\n</code></pre> <p>Options: - <code>loopback</code> (Boolean): Whether to process published messages locally (default: false) - <code>output</code> (String|IO): Output destination - filename string or IO object (default: $stdout)</p> <p>Example Output: <pre><code>===================================================\n== SmartMessage Published via STDOUT Transport\n== Header: #&lt;SmartMessage::Header:0x... @uuid=\"abc-123\", @message_class=\"MyMessage\", ...&gt;\n== Payload: {\"user_id\":123,\"action\":\"login\",\"timestamp\":\"2025-08-17T10:30:00Z\"}\n===================================================\n</code></pre></p>"},{"location":"reference/transports/#memory-transport","title":"Memory Transport","text":"<p>Ideal for testing and in-memory message queuing.</p> <p>Features: - Stores messages in memory - Thread-safe operations - Optional auto-processing - Message inspection capabilities - Memory overflow protection</p> <p>Usage:</p> <pre><code># Auto-process messages as they're published\ntransport = SmartMessage::Transport.create(:memory, auto_process: true)\n\n# Store messages without processing (manual control)\ntransport = SmartMessage::Transport.create(:memory, auto_process: false)\n\n# Configure maximum message storage\ntransport = SmartMessage::Transport.create(:memory, \n  auto_process: false,\n  max_messages: 500\n)\n\n# Use in message class\nclass TestMessage &lt; SmartMessage::Base\n  property :data\n\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n  end\nend\n</code></pre> <p>Options: - <code>auto_process</code> (Boolean): Automatically route messages to dispatcher (default: true) - <code>max_messages</code> (Integer): Maximum messages to store in memory (default: 1000)</p> <p>Message Management:</p> <pre><code>transport = SmartMessage::Transport.create(:memory)\n\n# Check stored messages\nputs transport.message_count\nputs transport.all_messages\n\n# Process all pending messages manually\ntransport.process_all\n\n# Clear all stored messages\ntransport.clear_messages\n\n# Access individual messages\nmessages = transport.all_messages\nmessages.each do |msg|\n  puts \"Published at: #{msg[:published_at]}\"\n  puts \"Header: #{msg[:header]}\"\n  puts \"Payload: #{msg[:payload]}\"\nend\n</code></pre>"},{"location":"reference/transports/#redis-transport","title":"Redis Transport","text":"<p>Production-ready Redis pub/sub transport for distributed messaging.</p> <p>Features: - Redis pub/sub messaging - Automatic channel management using message class names - Thread-safe subscriber management - Connection resilience with automatic reconnection - Configurable connection parameters - Background message subscription threads</p> <p>\ud83d\udca1 Redis Transport Options: SmartMessage provides three Redis-based transports: - Redis (Basic) - Simple pub/sub for basic scenarios - Redis Enhanced - Pattern-based routing with backwards compatibility - Redis Queue - Persistent queues with load balancing</p> <p>See the Redis Transport Comparison for detailed differences and usage guidance.</p> <p>Usage:</p> <pre><code># Basic Redis configuration\ntransport = SmartMessage::Transport.create(:redis, \n  url: 'redis://localhost:6379',\n  db: 0\n)\n\n# Production configuration with custom options\ntransport = SmartMessage::Transport.create(:redis,\n  url: 'redis://prod-redis:6379',\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n\n# Configure in message class\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :customer_id\n  property :amount\n\n  config do\n    transport SmartMessage::Transport.create(:redis, \n      url: 'redis://localhost:6379',\n      db: 1\n    )\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  def self.process(decoded_message)\n    # decoded_message is already a message instance\n    order = decoded_message\n    puts \"Processing order #{order.order_id} for $#{order.amount}\"\n    # Your business logic here\n  end\nend\n\n# Subscribe to messages (creates Redis subscription to \"OrderMessage\" channel)\nOrderMessage.subscribe\n\n# Publish messages (publishes to \"OrderMessage\" Redis channel)\norder = OrderMessage.new(\n  order_id: \"ORD-123\",\n  customer_id: \"CUST-456\", \n  amount: 99.99\n)\norder.publish\n</code></pre> <p>Options: - <code>url</code> (String): Redis connection URL (default: 'redis://localhost:6379') - <code>db</code> (Integer): Redis database number (default: 0) - <code>auto_subscribe</code> (Boolean): Automatically start subscriber thread (default: true) - <code>reconnect_attempts</code> (Integer): Number of reconnection attempts (default: 5) - <code>reconnect_delay</code> (Integer): Delay between reconnection attempts in seconds (default: 1) - <code>debug</code> (Boolean): Enable debug output (default: false)</p> <p>Channel Naming:</p> <p>The Redis transport uses the message class name as the Redis channel name. This provides automatic routing:</p> <pre><code>class UserMessage &lt; SmartMessage::Base\n  # Messages published to/from Redis channel \"UserMessage\"\nend\n\nclass AdminMessage &lt; SmartMessage::Base  \n  # Messages published to/from Redis channel \"AdminMessage\"\nend\n\nclass OrderProcessing::PaymentMessage &lt; SmartMessage::Base\n  # Messages published to/from Redis channel \"OrderProcessing::PaymentMessage\"\nend\n</code></pre> <p>Connection Management:</p> <pre><code>transport = SmartMessage::Transport.create(:redis, url: 'redis://localhost:6379')\n\n# Check connection status\nputs transport.connected?  # =&gt; true/false\n\n# Manual connection management\ntransport.connect\ntransport.disconnect\n\n# The transport automatically reconnects on connection failures\n</code></pre> <p>Multi-Message Type Support:</p> <pre><code># Different message types can share the same Redis transport\nredis_transport = SmartMessage::Transport.create(:redis, \n  url: 'redis://localhost:6379',\n  auto_subscribe: true\n)\n\n# Configure multiple message classes to use the same transport\n[OrderMessage, PaymentMessage, ShippingMessage].each do |msg_class|\n  msg_class.config do\n    transport redis_transport\n    serializer SmartMessage::Serializer::Json.new\n  end\n\n  # Subscribe to each message type (creates separate Redis subscriptions)\n  msg_class.subscribe\nend\n\n# Publishing to any message type routes to its specific Redis channel\nOrderMessage.new(order_id: \"123\").publish      # -&gt; \"OrderMessage\" channel\nPaymentMessage.new(amount: 50.0).publish       # -&gt; \"PaymentMessage\" channel\nShippingMessage.new(tracking: \"ABC\").publish   # -&gt; \"ShippingMessage\" channel\n</code></pre> <p>Error Handling and Resilience:</p> <p>The Redis transport includes built-in error handling:</p> <pre><code># Automatic reconnection on connection failures\ntransport = SmartMessage::Transport.create(:redis,\n  url: 'redis://localhost:6379',\n  reconnect_attempts: 5,    # Try 5 times to reconnect\n  reconnect_delay: 2        # Wait 2 seconds between attempts\n)\n\n# Connection failures during publishing will trigger automatic retry\n# If all reconnection attempts fail, the original error is raised\n</code></pre> <p>Production Deployment:</p> <pre><code># Production Redis configuration\nclass ProductionMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: ENV['REDIS_URL'] || 'redis://localhost:6379',\n      db: ENV['REDIS_DB']&amp;.to_i || 0,\n      auto_subscribe: true,\n      reconnect_attempts: 10,\n      reconnect_delay: 5\n    )\n    serializer SmartMessage::Serializer::Json.new\n    logger Logger.new(STDOUT)\n  end\nend\n</code></pre> <p>Testing with Redis:</p> <pre><code># Test configuration (using separate Redis database)\nclass TestMessage &lt; SmartMessage::Base\n  config do\n    transport SmartMessage::Transport.create(:redis,\n      url: 'redis://localhost:6379',\n      db: 15,  # Use separate database for tests\n      auto_subscribe: true\n    )\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n\n# In your test setup\ndef setup\n  # Clear test database\n  Redis.new(url: 'redis://localhost:6379', db: 15).flushdb\nend\n</code></pre>"},{"location":"reference/transports/#redis-enhanced-transport","title":"Redis Enhanced Transport","text":"<p>Advanced Redis transport with intelligent pattern-based routing and RabbitMQ-style capabilities.</p> <p>Features: - Pattern-based subscriptions with wildcard support (<code>*</code> matching) - Dual channel publishing for backwards compatibility - Fluent API for building complex subscription patterns - Enhanced routing with 3-part channel names: <code>message_type.from.to</code> - Convenience methods for common routing patterns - Service-oriented messaging patterns</p> <p></p> <p>Usage:</p> <pre><code># Create enhanced transport\ntransport = SmartMessage::Transport::RedisEnhancedTransport.new(\n  url: 'redis://localhost:6379',\n  db: 0,\n  auto_subscribe: true\n)\n\n# Configure message with enhanced transport\nclass OrderMessage &lt; SmartMessage::Base\n  from 'e-commerce-api'\n  to 'order-processor'\n\n  transport transport\n  serializer SmartMessage::Serializer::Json.new\n\n  property :order_id, required: true\n  property :amount, required: true\nend\n\n# Pattern-based subscriptions\ntransport.subscribe_pattern(\"ordermessage.*.*\")         # All order messages\ntransport.subscribe_pattern(\"*.payment_gateway.*\")      # All from payment gateway\ntransport.subscribe_to_recipient('order-processor')     # Convenience method\ntransport.subscribe_to_alerts                           # Emergency patterns\n\n# Fluent API subscriptions\ntransport.where.from('web-app').to('user-service').subscribe\ntransport.where.type('OrderMessage').from('api').subscribe\ntransport.where.from('monitoring').subscribe\n\n# Publishing (goes to BOTH channels for compatibility)\norder = OrderMessage.new(order_id: 'ORD-123', amount: 99.99)\norder.publish\n# Publishes to:\n# - \"OrderMessage\" (original format)\n# - \"ordermessage.e_commerce_api.order_processor\" (enhanced format)\n</code></pre> <p>Pattern Wildcards: - <code>*</code> - Matches exactly one segment - <code>ordermessage.*.*</code> - All order messages regardless of from/to - <code>*.payment_service.*</code> - All messages from payment service - <code>*.*.order_processor</code> - All messages to order processor</p> <p>Convenience Methods: <pre><code>transport.subscribe_to_recipient('service-name')  # *.*.service-name\ntransport.subscribe_from_sender('api-gateway')    # *.api-gateway.*\ntransport.subscribe_to_type('OrderMessage')       # ordermessage.*.*\ntransport.subscribe_to_alerts                     # Multiple alert patterns\ntransport.subscribe_to_broadcasts                 # *.*.broadcast\n</code></pre></p> <p>Fluent API: <pre><code># Single conditions\ntransport.where.from('api').subscribe              # *.api.*\ntransport.where.to('database').subscribe           # *.*.database\ntransport.where.type('LogMessage').subscribe       # logmessage.*.*\n\n# Combined conditions  \ntransport.where.from('web').to('api').subscribe    # *.web.api\ntransport.where.type('Order').from('shop').subscribe # order.shop.*\n</code></pre></p> <p>Options: - <code>url</code> (String): Redis connection URL (default: 'redis://localhost:6379') - <code>db</code> (Integer): Redis database number (default: 0) - <code>auto_subscribe</code> (Boolean): Automatically start subscriber threads (default: true) - <code>reconnect_attempts</code> (Integer): Connection retry attempts (default: 5) - <code>reconnect_delay</code> (Integer): Delay between retries in seconds (default: 1)</p> <p>Backwards Compatibility:</p> <p>The Enhanced Transport maintains full backwards compatibility with the basic Redis transport by publishing to both channel formats:</p> <pre><code># Enhanced transport publishes to BOTH:\n# 1. \"OrderMessage\" (basic format - for backwards compatibility)\n# 2. \"ordermessage.from_service.to_service\" (enhanced format - for pattern matching)\n\n# Basic Redis transport can still subscribe to \"OrderMessage\" \n# Enhanced transport can use patterns on the enhanced format\n</code></pre> <p>Use Cases: - Microservices architectures requiring sophisticated routing - Migration from basic Redis transport (maintains compatibility) - Development environments needing flexible message routing - Applications requiring RabbitMQ-style patterns without RabbitMQ setup - Service-to-service communication with intelligent filtering</p> <p>Performance: - Minimal overhead over basic Redis transport - Client-side pattern matching (slightly higher CPU usage) - Dual publishing increases Redis network traffic by ~2x - Excellent performance for most production scenarios</p>"},{"location":"reference/transports/#transport-interface","title":"Transport Interface","text":"<p>All transports must implement the <code>SmartMessage::Transport::Base</code> interface:</p>"},{"location":"reference/transports/#required-methods","title":"Required Methods","text":"<pre><code>class CustomTransport &lt; SmartMessage::Transport::Base\n  # Publish a message\n  def publish(message_header, message_payload)\n    # Send the message via your transport mechanism\n  end\n\n  # Optional: Override default options\n  def default_options\n    {\n      connection_timeout: 30,\n      retry_attempts: 3\n    }\n  end\n\n  # Optional: Custom configuration setup\n  def configure\n    @connection = establish_connection(@options)\n  end\n\n  # Optional: Connection status checking\n  def connected?\n    @connection&amp;.connected?\n  end\n\n  # Optional: Cleanup resources\n  def disconnect\n    @connection&amp;.close\n  end\nend\n</code></pre>"},{"location":"reference/transports/#inherited-methods","title":"Inherited Methods","text":"<p>Transports automatically inherit these methods from <code>SmartMessage::Transport::Base</code>:</p> <pre><code># Subscription management (uses dispatcher)\ntransport.subscribe(message_class, process_method)\ntransport.unsubscribe(message_class, process_method) \ntransport.unsubscribe!(message_class)\ntransport.subscribers\n\n# Connection management\ntransport.connect\ntransport.disconnect\ntransport.connected?\n\n# Message receiving (call this from your transport)\ntransport.receive(message_header, message_payload)  # protected method\n</code></pre>"},{"location":"reference/transports/#transport-registration","title":"Transport Registration","text":"<p>Register custom transports for easy creation:</p> <pre><code># Register custom transport classes\nSmartMessage::Transport.register(:kafka, KafkaTransport)\nSmartMessage::Transport.register(:webhook, WebhookTransport)\n\n# List all registered transports (includes built-ins)\nputs SmartMessage::Transport.available\n# =&gt; [:stdout, :memory, :redis, :kafka, :webhook]\n\n# Create instances of built-in transports\nredis_transport = SmartMessage::Transport.create(:redis, \n  url: \"redis://localhost:6379\"\n)\n\nmemory_transport = SmartMessage::Transport.create(:memory,\n  auto_process: true\n)\n\n# Create instances of custom transports\nkafka_transport = SmartMessage::Transport.create(:kafka,\n  servers: [\"localhost:9092\"]\n)\n</code></pre>"},{"location":"reference/transports/#configuration-patterns","title":"Configuration Patterns","text":""},{"location":"reference/transports/#class-level-configuration","title":"Class-Level Configuration","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  property :order_id\n  property :amount\n\n  # All instances use this transport by default\n  config do\n    transport SmartMessage::Transport.create(:memory, auto_process: true)\n    serializer SmartMessage::Serializer::Json.new\n  end\nend\n</code></pre>"},{"location":"reference/transports/#instance-level-override","title":"Instance-Level Override","text":"<pre><code># Override transport for specific instances\norder = OrderMessage.new(order_id: \"123\", amount: 99.99)\n\norder.config do\n  # This instance will use STDOUT instead of memory\n  transport SmartMessage::Transport.create(:stdout, loopback: true)\nend\n\norder.publish  # Uses STDOUT transport\n</code></pre>"},{"location":"reference/transports/#runtime-transport-switching","title":"Runtime Transport Switching","text":"<pre><code>class NotificationMessage &lt; SmartMessage::Base\n  property :recipient\n  property :message\n\n  def self.send_via_email\n    config do\n      transport EmailTransport.new\n    end\n  end\n\n  def self.send_via_sms  \n    config do\n      transport SMSTransport.new\n    end\n  end\nend\n\n# Switch transport at runtime\nNotificationMessage.send_via_email\nnotification = NotificationMessage.new(\n  recipient: \"user@example.com\",\n  message: \"Hello!\"\n)\nnotification.publish  # Sent via email\n</code></pre>"},{"location":"reference/transports/#transport-options","title":"Transport Options","text":""},{"location":"reference/transports/#common-options-pattern","title":"Common Options Pattern","text":"<p>Most transports support these common option patterns:</p> <pre><code>transport = SmartMessage::Transport.create(:custom,\n  # Connection options\n  host: \"localhost\",\n  port: 5672,\n  username: \"guest\",\n  password: \"guest\",\n\n  # Retry options\n  retry_attempts: 3,\n  retry_delay: 1.0,\n\n  # Timeout options\n  connection_timeout: 30,\n  read_timeout: 10,\n\n  # Behavior options\n  auto_reconnect: true,\n  persistent: true\n)\n</code></pre>"},{"location":"reference/transports/#transport-specific-options","title":"Transport-Specific Options","text":"<p>Each transport may have specific options:</p> <pre><code># STDOUT specific\nSmartMessage::Transport.create(:stdout,\n  loopback: true,\n  output: \"/var/log/messages.log\"\n)\n\n# Memory specific  \nSmartMessage::Transport.create(:memory,\n  auto_process: false,\n  max_messages: 1000\n)\n\n# Redis specific\nSmartMessage::Transport.create(:redis,\n  url: \"redis://localhost:6379\",\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n</code></pre>"},{"location":"reference/transports/#error-handling","title":"Error Handling","text":""},{"location":"reference/transports/#transport-errors","title":"Transport Errors","text":"<p>Transports should handle their own connection and transmission errors:</p> <pre><code>class RobustTransport &lt; SmartMessage::Transport::Base\n  def publish(message_header, message_payload)\n    retry_count = 0\n    begin\n      send_message(message_header, message_payload)\n    rescue ConnectionError =&gt; e\n      retry_count += 1\n      if retry_count &lt;= @options[:retry_attempts]\n        sleep(@options[:retry_delay])\n        retry\n      else\n        # Log error and potentially fallback\n        handle_publish_error(e, message_header, message_payload)\n      end\n    end\n  end\n\n  private\n\n  def handle_publish_error(error, header, payload)\n    # Log the error\n    puts \"Failed to publish message: #{error.message}\"\n\n    # Optional: Store for later retry\n    store_failed_message(header, payload)\n\n    # Optional: Use fallback transport\n    fallback_transport&amp;.publish(header, payload)\n  end\nend\n</code></pre>"},{"location":"reference/transports/#connection-monitoring","title":"Connection Monitoring","text":"<pre><code>class MonitoredTransport &lt; SmartMessage::Transport::Base\n  def connected?\n    @connection&amp;.ping rescue false\n  end\n\n  def publish(message_header, message_payload)\n    unless connected?\n      connect\n    end\n\n    super\n  end\n\n  def connect\n    @connection = establish_connection(@options)\n    puts \"Connected to #{@options[:host]}:#{@options[:port]}\"\n  rescue =&gt; e\n    puts \"Failed to connect: #{e.message}\"\n    raise\n  end\nend\n</code></pre>"},{"location":"reference/transports/#performance-considerations","title":"Performance Considerations","text":""},{"location":"reference/transports/#message-batching","title":"Message Batching","text":"<p>For high-throughput scenarios, consider batching:</p> <pre><code>class BatchingTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @batch = []\n    @batch_mutex = Mutex.new\n    setup_batch_timer\n  end\n\n  def publish(message_header, message_payload)\n    @batch_mutex.synchronize do\n      @batch &lt;&lt; [message_header, message_payload]\n\n      if @batch.size &gt;= @options[:batch_size]\n        flush_batch\n      end\n    end\n  end\n\n  private\n\n  def flush_batch\n    return if @batch.empty?\n\n    batch_to_send = @batch.dup\n    @batch.clear\n\n    send_batch(batch_to_send)\n  end\nend\n</code></pre>"},{"location":"reference/transports/#connection-pooling","title":"Connection Pooling","text":"<p>For database or network transports:</p> <pre><code>class PooledTransport &lt; SmartMessage::Transport::Base\n  def initialize(options = {})\n    super\n    @connection_pool = ConnectionPool.new(\n      size: @options[:pool_size] || 5,\n      timeout: @options[:pool_timeout] || 5\n    ) { create_connection }\n  end\n\n  def publish(message_header, message_payload)\n    @connection_pool.with do |connection|\n      connection.send(message_header, message_payload)\n    end\n  end\nend\n</code></pre>"},{"location":"reference/transports/#testing-transports","title":"Testing Transports","text":""},{"location":"reference/transports/#mock-transport-for-testing","title":"Mock Transport for Testing","text":"<pre><code>class MockTransport &lt; SmartMessage::Transport::Base\n  attr_reader :published_messages\n\n  def initialize(options = {})\n    super\n    @published_messages = []\n  end\n\n  def publish(message_header, message_payload)\n    @published_messages &lt;&lt; {\n      header: message_header,\n      payload: message_payload,\n      published_at: Time.now\n    }\n\n    # Optionally trigger processing\n    receive(message_header, message_payload) if @options[:auto_process]\n  end\n\n  def clear\n    @published_messages.clear\n  end\nend\n\n# Use in tests\nRSpec.describe \"Message Publishing\" do\n  let(:transport) { MockTransport.new(auto_process: true) }\n\n  before do\n    MyMessage.config do\n      transport transport\n    end\n  end\n\n  it \"publishes messages\" do\n    MyMessage.new(data: \"test\").publish\n\n    expect(transport.published_messages).to have(1).message\n    expect(transport.published_messages.first[:payload]).to include(\"test\")\n  end\nend\n</code></pre>"},{"location":"reference/transports/#next-steps","title":"Next Steps","text":"<ul> <li>Redis Transport Comparison - Detailed comparison of Redis, Enhanced, and Queue transports</li> <li>Serializers - Understanding message serialization</li> <li>Dispatcher - Message routing and processing  </li> <li>Examples - Real-world transport usage patterns</li> </ul>"},{"location":"transports/memory-transport/","title":"Memory Transport","text":"<p>The Memory Transport is an in-memory transport implementation designed for testing, development, and rapid prototyping. It stores messages in memory and provides synchronous processing capabilities.</p>"},{"location":"transports/memory-transport/#overview","title":"Overview","text":"<p>The Memory Transport is perfect for: - Unit testing - No external dependencies required - Local development - Fast, lightweight message processing - Rapid prototyping - Quick setup without infrastructure - Debug and inspection - Full visibility into message flow</p>"},{"location":"transports/memory-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83e\udde0 In-Memory Storage - Messages stored in process memory</li> <li>\u26a1 Synchronous Processing - Immediate message processing</li> <li>\ud83d\udd0d Message Inspection - View and count stored messages</li> <li>\ud83d\udd04 Auto-Processing - Optional automatic message processing</li> <li>\ud83d\udee1\ufe0f Memory Protection - Configurable message limits to prevent overflow</li> <li>\ud83e\uddf5 Thread-Safe - Mutex-protected operations</li> </ul>"},{"location":"transports/memory-transport/#configuration","title":"Configuration","text":""},{"location":"transports/memory-transport/#basic-setup","title":"Basic Setup","text":"<pre><code># Minimal configuration\ntransport = SmartMessage::Transport::MemoryTransport.new\n\n# With options\ntransport = SmartMessage::Transport::MemoryTransport.new(\n  auto_process: true,     # Process messages immediately (default: true)\n  max_messages: 1000      # Maximum messages to store (default: 1000)\n)\n</code></pre>"},{"location":"transports/memory-transport/#using-with-smartmessage","title":"Using with SmartMessage","text":"<pre><code># Configure as default transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new\nend\n\n# Use in message class\nclass TestMessage &lt; SmartMessage::Base\n  property :content, required: true\n\n  transport :memory\n\n  def process\n    puts \"Processing: #{content}\"\n  end\nend\n</code></pre>"},{"location":"transports/memory-transport/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>auto_process</code> Boolean <code>true</code> Automatically process messages when published <code>max_messages</code> Integer <code>1000</code> Maximum messages to store (prevents memory overflow)"},{"location":"transports/memory-transport/#usage-examples","title":"Usage Examples","text":""},{"location":"transports/memory-transport/#basic-message-processing","title":"Basic Message Processing","text":"<pre><code># Create transport\ntransport = SmartMessage::Transport::MemoryTransport.new\n\n# Define message\nclass AlertMessage &lt; SmartMessage::Base\n  property :message, required: true\n  property :severity, default: 'info'\n\n  transport transport\n\n  def process\n    puts \"[#{severity.upcase}] #{message}\"\n  end\nend\n\n# Publish message\nAlertMessage.new(\n  message: \"System startup complete\",\n  severity: \"info\"\n).publish\n\n# Output: [INFO] System startup complete\n</code></pre>"},{"location":"transports/memory-transport/#manual-processing-control","title":"Manual Processing Control","text":"<pre><code># Disable auto-processing for batch operations\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\nclass DataMessage &lt; SmartMessage::Base\n  property :data\n  transport transport\n\n  def process\n    puts \"Processing: #{data}\"\n  end\nend\n\n# Publish multiple messages\nDataMessage.new(data: \"batch 1\").publish\nDataMessage.new(data: \"batch 2\").publish\nDataMessage.new(data: \"batch 3\").publish\n\nputs \"Messages stored: #{transport.message_count}\"\n# Output: Messages stored: 3\n\n# Process all at once\ntransport.process_all\n# Output: \n# Processing: batch 1\n# Processing: batch 2\n# Processing: batch 3\n</code></pre>"},{"location":"transports/memory-transport/#message-inspection","title":"Message Inspection","text":"<pre><code>transport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :amount, required: true\n  transport transport\nend\n\n# Publish test messages\nOrderMessage.new(order_id: \"ORD-001\", amount: 99.99).publish\nOrderMessage.new(order_id: \"ORD-002\", amount: 149.50).publish\n\n# Inspect stored messages\nputs \"Total messages: #{transport.message_count}\"\ntransport.all_messages.each_with_index do |msg, index|\n  puts \"Message #{index + 1}: #{msg[:message_class]} at #{msg[:published_at]}\"\nend\n\n# Clear messages when done\ntransport.clear_messages\nputs \"Messages after clear: #{transport.message_count}\"\n</code></pre>"},{"location":"transports/memory-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/memory-transport/#instance-methods","title":"Instance Methods","text":""},{"location":"transports/memory-transport/#message_count","title":"<code>#message_count</code>","text":"<p>Returns the number of messages currently stored.</p> <pre><code>count = transport.message_count\nputs \"Stored messages: #{count}\"\n</code></pre>"},{"location":"transports/memory-transport/#all_messages","title":"<code>#all_messages</code>","text":"<p>Returns a copy of all stored messages with metadata.</p> <pre><code>messages = transport.all_messages\nmessages.each do |msg|\n  puts \"Class: #{msg[:message_class]}\"\n  puts \"Time: #{msg[:published_at]}\"\n  puts \"Data: #{msg[:serialized_message]}\"\nend\n</code></pre>"},{"location":"transports/memory-transport/#clear_messages","title":"<code>#clear_messages</code>","text":"<p>Removes all stored messages from memory.</p> <pre><code>transport.clear_messages\n</code></pre>"},{"location":"transports/memory-transport/#process_all","title":"<code>#process_all</code>","text":"<p>Manually processes all stored messages (useful when <code>auto_process: false</code>).</p> <pre><code># Publish messages without auto-processing\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n# ... publish messages ...\n\n# Process them all at once\ntransport.process_all\n</code></pre>"},{"location":"transports/memory-transport/#connected","title":"<code>#connected?</code>","text":"<p>Always returns <code>true</code> since memory transport is always available.</p> <pre><code>puts transport.connected?  # =&gt; true\n</code></pre>"},{"location":"transports/memory-transport/#use-cases","title":"Use Cases","text":""},{"location":"transports/memory-transport/#unit-testing","title":"Unit Testing","text":"<pre><code>RSpec.describe \"Message Processing\" do\n  let(:transport) { SmartMessage::Transport::MemoryTransport.new }\n\n  before do\n    MyMessage.transport = transport\n    transport.clear_messages\n  end\n\n  it \"processes messages correctly\" do\n    MyMessage.new(data: \"test\").publish\n    expect(transport.message_count).to eq(1)\n  end\n\n  it \"respects message limits\" do\n    transport = SmartMessage::Transport::MemoryTransport.new(max_messages: 2)\n\n    3.times { |i| MyMessage.new(data: i).publish }\n    expect(transport.message_count).to eq(2)  # Oldest message dropped\n  end\nend\n</code></pre>"},{"location":"transports/memory-transport/#development-environment","title":"Development Environment","text":"<pre><code># config/environments/development.rb\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new(\n    auto_process: true,\n    max_messages: 500\n  )\n  config.logger.level = Logger::DEBUG  # See all message activity\nend\n</code></pre>"},{"location":"transports/memory-transport/#batch-processing","title":"Batch Processing","text":"<pre><code># Collect messages for batch processing\ntransport = SmartMessage::Transport::MemoryTransport.new(auto_process: false)\n\n# Publish work items\nwork_items.each do |item|\n  WorkMessage.new(item: item).publish\nend\n\n# Process batch when ready\nputs \"Processing #{transport.message_count} work items...\"\nstart_time = Time.now\ntransport.process_all\nputs \"Completed in #{Time.now - start_time} seconds\"\n</code></pre>"},{"location":"transports/memory-transport/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Latency: ~0.01ms (memory access)</li> <li>Throughput: 100K+ messages/second</li> <li>Memory Usage: ~1KB per stored message</li> <li>Concurrency: Thread-safe with mutex protection</li> <li>Persistence: None (messages lost when process ends)</li> </ul>"},{"location":"transports/memory-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/memory-transport/#testing","title":"Testing","text":"<ul> <li>Use <code>clear_messages</code> in test setup/teardown</li> <li>Set reasonable <code>max_messages</code> limits for long-running tests</li> <li>Disable <code>auto_process</code> for message inspection tests</li> </ul>"},{"location":"transports/memory-transport/#development","title":"Development","text":"<ul> <li>Enable debug logging to see message flow</li> <li>Use message inspection methods for debugging</li> <li>Consider memory limits in long-running development processes</li> </ul>"},{"location":"transports/memory-transport/#production","title":"Production","text":"<p>\u26a0\ufe0f Not recommended for production use - Messages are lost when process restarts - No persistence or durability guarantees - Limited by process memory</p>"},{"location":"transports/memory-transport/#thread-safety","title":"Thread Safety","text":"<p>The Memory Transport is fully thread-safe: - All operations use mutex synchronization - Messages can be published from multiple threads - Inspection methods return safe copies</p> <pre><code># Thread-safe concurrent publishing\nthreads = []\n10.times do |i|\n  threads &lt;&lt; Thread.new do\n    100.times { |j| TestMessage.new(data: \"#{i}-#{j}\").publish }\n  end\nend\nthreads.each(&amp;:join)\n\nputs \"Total messages: #{transport.message_count}\"  # Always accurate\n</code></pre>"},{"location":"transports/memory-transport/#migration-from-memory-transport","title":"Migration from Memory Transport","text":"<p>When moving from Memory Transport to production transports:</p> <pre><code># Development (Memory Transport)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::MemoryTransport.new\nend\n\n# Production (Redis Transport)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: ENV['REDIS_URL']\n  )\nend\n</code></pre> <p>Messages and processing logic remain identical - only the transport configuration changes.</p>"},{"location":"transports/memory-transport/#examples","title":"Examples","text":"<p>The <code>examples/memory/</code> directory contains comprehensive, runnable examples demonstrating Memory Transport capabilities:</p>"},{"location":"transports/memory-transport/#core-messaging-examples","title":"Core Messaging Examples","text":"<ul> <li>03_point_to_point_orders.rb - Point-to-point order processing with payment integration</li> <li>04_publish_subscribe_events.rb - Event broadcasting to multiple services (email, SMS, audit)</li> <li>05_many_to_many_chat.rb - Interactive chat system with rooms, bots, and human agents</li> </ul>"},{"location":"transports/memory-transport/#advanced-features","title":"Advanced Features","text":"<ul> <li>01_message_deduplication_demo.rb - Message deduplication patterns and strategies</li> <li>02_dead_letter_queue_demo.rb - Complete Dead Letter Queue system with circuit breakers</li> <li>07_proc_handlers_demo.rb - Flexible message handlers (blocks, procs, lambdas, methods)</li> </ul>"},{"location":"transports/memory-transport/#configuration-monitoring","title":"Configuration &amp; Monitoring","text":"<ul> <li>08_custom_logger_demo.rb - Advanced logging with SmartMessage::Logger::Default</li> <li>09_error_handling_demo.rb - Comprehensive validation, version mismatch, and error handling</li> <li>13_header_block_configuration.rb - Header and block configuration examples</li> <li>14_global_configuration_demo.rb - Global configuration management</li> <li>15_logger_demo.rb - Advanced logging demonstrations</li> </ul>"},{"location":"transports/memory-transport/#entity-addressing-filtering","title":"Entity Addressing &amp; Filtering","text":"<ul> <li>10_entity_addressing_basic.rb - Basic FROM/TO/REPLY_TO message addressing</li> <li>11_entity_addressing_with_filtering.rb - Advanced entity-aware message filtering</li> <li>12_regex_filtering_microservices.rb - Advanced regex filtering for microservices</li> </ul>"},{"location":"transports/memory-transport/#visual-demonstrations","title":"Visual Demonstrations","text":"<ul> <li>06_pretty_print_demo.rb - Message inspection and pretty-printing capabilities</li> </ul>"},{"location":"transports/memory-transport/#running-examples","title":"Running Examples","text":"<pre><code># Navigate to the SmartMessage directory\ncd smart_message\n\n# Run any Memory Transport example\nruby examples/memory/03_point_to_point_orders.rb\nruby examples/memory/05_many_to_many_chat.rb\nruby examples/memory/02_dead_letter_queue_demo.rb\n\n# Or explore the entire directory\nls examples/memory/\n</code></pre> <p>Each example is self-contained and demonstrates specific Memory Transport features with clear educational comments and real-world scenarios.</p>"},{"location":"transports/memory-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Transport Overview - All available transports</li> <li>Redis Transport - Production-ready Redis transport</li> <li>Testing Guide - Testing strategies with SmartMessage</li> </ul>"},{"location":"transports/redis-enhanced-transport/","title":"Redis Enhanced Transport","text":"<p>The Redis Enhanced Transport extends the basic Redis transport with RabbitMQ-style pattern matching and intelligent routing capabilities. It provides sophisticated message routing while maintaining full backwards compatibility with the basic Redis transport.</p>"},{"location":"transports/redis-enhanced-transport/#overview","title":"Overview","text":"<p>Redis Enhanced Transport is perfect for: - Microservices architecture - Sophisticated routing between services - Pattern-based routing - RabbitMQ-style patterns without RabbitMQ - Legacy compatibility - Gradual migration from basic Redis transport - Development flexibility - Advanced routing for complex applications</p>"},{"location":"transports/redis-enhanced-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfaf Pattern-Based Subscriptions - Wildcard support (<code>*</code> patterns)</li> <li>\ud83d\udd04 Dual Channel Publishing - Backwards compatibility with basic transport</li> <li>\ud83d\udee0\ufe0f Fluent API - Chainable subscription building</li> <li>\ud83d\udce1 Enhanced Routing - 3-part channel names: <code>message_type.from.to</code></li> <li>\ud83d\ude80 High Performance - ~1.2ms latency, 75K+ messages/second</li> <li>\ud83d\udd0c Drop-in Replacement - Seamless upgrade from basic Redis transport</li> </ul>"},{"location":"transports/redis-enhanced-transport/#architecture","title":"Architecture","text":"<p>The Enhanced Transport uses a sophisticated 3-part channel naming scheme and publishes to both original and enhanced channels for backward compatibility.</p>"},{"location":"transports/redis-enhanced-transport/#channel-format","title":"Channel Format","text":"<p>Enhanced channels use a structured naming scheme: <pre><code>message_type.from.to\n</code></pre></p> <p>Examples: - <code>ordermessage.api_gateway.order_service</code> - <code>paymentmessage.payment_service.bank_gateway</code>  - <code>alertmessage.monitoring.admin_panel</code></p>"},{"location":"transports/redis-enhanced-transport/#pattern-matching","title":"Pattern Matching","text":""},{"location":"transports/redis-enhanced-transport/#wildcard-support","title":"Wildcard Support","text":"<ul> <li><code>*</code> - Matches exactly one segment</li> <li>Pattern Examples:</li> <li><code>ordermessage.*.*</code> - All order messages</li> <li><code>*.payment_gateway.*</code> - All messages from payment gateway</li> <li><code>alertmessage.*.*</code> - All alert messages</li> </ul>"},{"location":"transports/redis-enhanced-transport/#fluent-api","title":"Fluent API","text":"<p>Build complex subscription patterns with chainable methods:</p> <pre><code># Basic patterns\ntransport.where.from('api-gateway').subscribe         # *.api-gateway.*\ntransport.where.to('order-service').subscribe         # *.*.order-service\ntransport.where.type('OrderMessage').subscribe        # ordermessage.*.*\n\n# Combined patterns\ntransport.where.from('api').to('service').subscribe   # *.api.service\ntransport.where.type('Alert').from('monitoring').subscribe  # alert.monitoring.*\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#configuration","title":"Configuration","text":""},{"location":"transports/redis-enhanced-transport/#basic-setup","title":"Basic Setup","text":"<pre><code># Minimal configuration\ntransport = SmartMessage::Transport::RedisEnhancedTransport.new\n\n# With options\ntransport = SmartMessage::Transport::RedisEnhancedTransport.new(\n  url: 'redis://localhost:6379',\n  db: 0,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 1\n)\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#using-with-smartmessage","title":"Using with SmartMessage","text":"<pre><code># Configure as default transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisEnhancedTransport.new\nend\n\n# Enhanced message with routing\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_id, required: true\n\n  # Set source and destination for routing\n  from 'api-gateway'\n  to 'order-service'\n\n  transport :redis_enhanced\n\n  def process\n    puts \"Processing order #{order_id} from #{_sm_header.from} to #{_sm_header.to}\"\n  end\nend\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#configuration-options","title":"Configuration Options","text":"<p>Inherits all options from Redis Transport:</p> Option Type Default Description <code>url</code> String <code>redis://localhost:6379</code> Redis connection URL <code>db</code> Integer <code>0</code> Redis database number <code>auto_subscribe</code> Boolean <code>true</code> Automatically start subscriber <code>reconnect_attempts</code> Integer <code>5</code> Connection retry attempts <code>reconnect_delay</code> Integer <code>1</code> Seconds between retries"},{"location":"transports/redis-enhanced-transport/#usage-examples","title":"Usage Examples","text":""},{"location":"transports/redis-enhanced-transport/#basic-pattern-subscriptions","title":"Basic Pattern Subscriptions","text":"<pre><code># Subscribe to all order messages\nOrderMessage.subscribe_pattern('ordermessage.*.*')\n\n# Subscribe to messages from specific service\ntransport.subscribe_from_sender('payment-gateway')\n\n# Subscribe to messages for specific service  \ntransport.subscribe_to_recipient('order-service')\n\n# Subscribe to all messages of a type\ntransport.subscribe_to_type('AlertMessage')\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#fluent-api-examples","title":"Fluent API Examples","text":"<pre><code># Service-specific routing\ntransport.where\n  .from('web-app')\n  .to('user-service')\n  .subscribe\n\n# Message type filtering\ntransport.where\n  .type('AnalyticsEvent')\n  .from('web-app')\n  .subscribe\n\n# Complex routing conditions\ntransport.where\n  .from('monitoring')\n  .to('admin-panel')\n  .type('AdminAlert')\n  .subscribe\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#microservices-communication","title":"Microservices Communication","text":"<pre><code># API Gateway \u2192 Service routing\nclass UserRequest &lt; SmartMessage::Base\n  property :user_id, required: true\n  property :action, required: true\n\n  from 'api-gateway'\n  to 'user-service'\n\n  def process\n    puts \"User #{user_id} action: #{action}\"\n  end\nend\n\n# Service \u2192 Database routing  \nclass UserQuery &lt; SmartMessage::Base\n  property :query, required: true\n\n  from 'user-service'\n  to 'database'\n\n  def process\n    puts \"Executing query: #{query}\"\n  end\nend\n\n# Subscribe to service-specific messages\ntransport.where.to('user-service').subscribe    # All messages to user service\ntransport.where.from('api-gateway').subscribe   # All messages from API gateway\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#convenience-methods","title":"Convenience Methods","text":"<pre><code># Subscribe to broadcasts\ntransport.subscribe_to_broadcasts  # *.*.broadcast\n\n# Subscribe to alerts from any service\ntransport.subscribe_to_alerts      # alertmessage.*.*, *alert*.*.*\n\n# Subscribe to specific recipient\ntransport.subscribe_to_recipient('payment-service')  # *.*.payment-service\n\n# Subscribe to specific sender\ntransport.subscribe_from_sender('monitoring')        # *.monitoring.*\n\n# Subscribe to message type\ntransport.subscribe_to_type('OrderMessage')          # ordermessage.*.*\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#dual-publishing","title":"Dual Publishing","text":"<p>Enhanced Transport maintains backwards compatibility by publishing to both channel formats:</p>"},{"location":"transports/redis-enhanced-transport/#publishing-behavior","title":"Publishing Behavior","text":"<pre><code># When OrderMessage publishes:\nOrderMessage.new(order_id: 'ORD-001').publish\n\n# Results in publications to BOTH:\n# 1. \"OrderMessage\" (basic format - for compatibility)\n# 2. \"ordermessage.api_gateway.order_service\" (enhanced format)\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#subscriber-compatibility","title":"Subscriber Compatibility","text":"<ul> <li>Basic Redis subscribers \u2192 Receive from original channel</li> <li>Enhanced Redis subscribers \u2192 Receive from enhanced channel  </li> <li>Both can coexist \u2192 Gradual migration possible</li> </ul>"},{"location":"transports/redis-enhanced-transport/#advanced-routing-patterns","title":"Advanced Routing Patterns","text":""},{"location":"transports/redis-enhanced-transport/#environment-based-routing","title":"Environment-Based Routing","text":"<pre><code># Development services\ntransport.where.to(/^(dev|staging)-.*/).subscribe\n\n# Production services  \ntransport.where.to(/^prod-.*/).subscribe\n\n# Cross-environment alerts\ntransport.where\n  .type('Alert')\n  .from(/^(prod|staging)-.*/)\n  .to('monitoring')\n  .subscribe\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#service-pattern-routing","title":"Service Pattern Routing","text":"<pre><code># All payment-related services\ntransport.where.from(/^payment-.*/).subscribe\n\n# API layer to service layer\ntransport.where\n  .from(/^(web|mobile|api)-.*/)\n  .to(/^.*-service$/)\n  .subscribe\n\n# Monitoring aggregation\ntransport.where\n  .type('MetricMessage')\n  .to('monitoring')\n  .subscribe\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#message-filtering","title":"Message Filtering","text":"<pre><code>class AlertMessage &lt; SmartMessage::Base\n  property :level, required: true\n  property :message, required: true\n\n  from 'monitoring'\n\n  def process\n    puts \"[#{level.upcase}] #{message}\"\n  end\nend\n\n# Subscribe only to critical alerts\nAlertMessage.subscribe(from: 'monitoring') do |message|\n  message.level == 'critical'\nend\n\n# Subscribe to alerts from specific services\nAlertMessage.subscribe(from: /^(database|api)-.*/)\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Latency: ~1.2ms average (slightly higher due to pattern processing)</li> <li>Throughput: 75,000+ messages/second  </li> <li>Memory per Subscriber: ~2MB (pattern storage overhead)</li> <li>Concurrent Subscribers: ~250 practical limit</li> <li>Pattern Processing: Minimal CPU overhead</li> <li>Backwards Compatibility: No performance penalty</li> </ul>"},{"location":"transports/redis-enhanced-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/redis-enhanced-transport/#pattern-subscription-methods","title":"Pattern Subscription Methods","text":""},{"location":"transports/redis-enhanced-transport/#subscribe_patternpattern","title":"<code>#subscribe_pattern(pattern)</code>","text":"<p>Subscribe to messages matching a specific pattern.</p> <pre><code>transport.subscribe_pattern('ordermessage.*.*')\ntransport.subscribe_pattern('*.payment.*')\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#where","title":"<code>#where</code>","text":"<p>Returns a fluent API builder for complex subscriptions.</p> <pre><code>builder = transport.where\nbuilder.from('api').to('service').type('Order').subscribe\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#convenience-methods_1","title":"Convenience Methods","text":"<pre><code>transport.subscribe_to_recipient('service-name')      # *.*.service-name  \ntransport.subscribe_from_sender('service-name')       # *.service-name.*\ntransport.subscribe_to_type('MessageType')            # messagetype.*.*\ntransport.subscribe_to_alerts                         # Alert patterns\ntransport.subscribe_to_broadcasts                     # *.*.broadcast\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#fluent-api-builder-methods","title":"Fluent API Builder Methods","text":""},{"location":"transports/redis-enhanced-transport/#fromservice_name","title":"<code>#from(service_name)</code>","text":"<p>Filter messages from specific service(s).</p> <pre><code>transport.where.from('api-gateway')           # String match\ntransport.where.from(/^api-.*/)              # Regex match\ntransport.where.from(['api', 'web'])         # Array match\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#toservice_name","title":"<code>#to(service_name)</code>","text":"<p>Filter messages to specific service(s).</p> <pre><code>transport.where.to('order-service')          # String match\ntransport.where.to(/^.*-service$/)          # Regex match  \ntransport.where.to(['user-svc', 'order-svc']) # Array match\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#typemessage_type","title":"<code>#type(message_type)</code>","text":"<p>Filter by message type.</p> <pre><code>transport.where.type('OrderMessage')         # String match\ntransport.where.type(/^.*Alert$/)           # Regex match\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#subscribeblock","title":"<code>#subscribe(&amp;block)</code>","text":"<p>Execute the subscription with optional filtering block.</p> <pre><code>transport.where.from('api').subscribe do |message|\n  message.priority == 'high'  # Additional filtering\nend\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#migration-from-basic-transport","title":"Migration from Basic Transport","text":""},{"location":"transports/redis-enhanced-transport/#step-1-enable-enhanced-transport","title":"Step 1: Enable Enhanced Transport","text":"<pre><code># Before (Basic Redis)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new\nend\n\n# After (Enhanced Redis)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisEnhancedTransport.new\nend\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#step-2-gradual-pattern-adoption","title":"Step 2: Gradual Pattern Adoption","text":"<pre><code># Existing subscriptions continue to work\nOrderMessage.subscribe  # Still works exactly the same\n\n# New subscriptions can use patterns\nOrderMessage.subscribe_pattern('ordermessage.api.*')  # New capability\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#step-3-enhanced-message-design","title":"Step 3: Enhanced Message Design","text":"<pre><code># Enhanced messages with routing info\nclass NewOrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n\n  from 'api-gateway'\n  to 'order-service'\n\n  # Inherits enhanced capabilities automatically\nend\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/redis-enhanced-transport/#pattern-design","title":"Pattern Design","text":"<ul> <li>Use consistent service naming conventions</li> <li>Keep patterns as specific as possible for performance</li> <li>Document routing patterns for team understanding</li> </ul>"},{"location":"transports/redis-enhanced-transport/#service-communication","title":"Service Communication","text":"<ul> <li>Use meaningful service names in routing</li> <li>Implement service discovery patterns</li> <li>Monitor cross-service message flows</li> </ul>"},{"location":"transports/redis-enhanced-transport/#backwards-compatibility","title":"Backwards Compatibility","text":"<ul> <li>Test migration thoroughly in staging</li> <li>Monitor both channel formats during transition</li> <li>Maintain basic transport compatibility during migration</li> </ul>"},{"location":"transports/redis-enhanced-transport/#performance-optimization","title":"Performance Optimization","text":"<ul> <li>Limit wildcard usage for high-throughput scenarios</li> <li>Use specific patterns rather than broad wildcards</li> <li>Monitor Redis memory usage with pattern storage</li> </ul>"},{"location":"transports/redis-enhanced-transport/#use-cases","title":"Use Cases","text":""},{"location":"transports/redis-enhanced-transport/#microservices-architecture","title":"Microservices Architecture","text":"<p>Perfect for complex service topologies requiring intelligent routing.</p>"},{"location":"transports/redis-enhanced-transport/#legacy-system-migration","title":"Legacy System Migration","text":"<p>Gradual migration from basic Redis transport without breaking existing functionality.</p>"},{"location":"transports/redis-enhanced-transport/#development-environments","title":"Development Environments","text":"<p>Flexible routing for rapidly changing service architectures.</p>"},{"location":"transports/redis-enhanced-transport/#pattern-based-routing","title":"Pattern-Based Routing","text":"<p>Applications requiring RabbitMQ-style routing without RabbitMQ complexity.</p>"},{"location":"transports/redis-enhanced-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Enhanced Transport Examples - Complete working examples</li> <li>Redis Transport Comparison - Compare all Redis transports  </li> <li>Redis Queue Transport - Persistent queues with load balancing</li> <li>Transport Overview - All available transports</li> </ul>"},{"location":"transports/redis-enhanced-transport/#examples","title":"Examples","text":"<p>The <code>examples/redis_enhanced/</code> directory contains comprehensive examples demonstrating Redis Enhanced Transport capabilities:</p>"},{"location":"transports/redis-enhanced-transport/#advanced-routing-patterns_1","title":"Advanced Routing Patterns","text":"<ul> <li>enhanced_01_basic_patterns.rb - Foundation patterns for enhanced routing</li> <li>Simple subscriber patterns with wildcards</li> <li>Basic pattern matching and subscription filtering</li> <li> <p>Enhanced routing setup and configuration</p> </li> <li> <p>enhanced_02_fluent_api.rb - Fluent API usage examples</p> </li> <li>Chain-based subscription configuration</li> <li>Dynamic pattern building and modification</li> <li> <p>Fluent interface for complex routing scenarios</p> </li> <li> <p>enhanced_03_dual_publishing.rb - Dual publishing strategies</p> </li> <li>Broadcasting to multiple patterns simultaneously</li> <li>Pattern-specific message customization</li> <li> <p>Load balancing across pattern-matched subscribers</p> </li> <li> <p>enhanced_04_advanced_routing.rb - Complex routing scenarios</p> </li> <li>Multi-level pattern hierarchies</li> <li>Conditional routing based on message content</li> <li>Dynamic subscriber management and pattern updates</li> </ul>"},{"location":"transports/redis-enhanced-transport/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The enhanced examples showcase unique Redis Enhanced Transport capabilities: - Pattern-Based Subscriptions - Wildcard and regex pattern matching - Advanced Channel Routing - Beyond simple class-name channels - Fluent Configuration API - Chainable subscription setup - Dynamic Routing - Runtime pattern modification - Complex Message Filtering - Content-based routing decisions</p>"},{"location":"transports/redis-enhanced-transport/#running-examples","title":"Running Examples","text":"<pre><code># Prerequisites: Start Redis server\nredis-server\n\n# Navigate to the SmartMessage directory\ncd smart_message\n\n# Run enhanced transport examples\nruby examples/redis_enhanced/enhanced_01_basic_patterns.rb\nruby examples/redis_enhanced/enhanced_02_fluent_api.rb\nruby examples/redis_enhanced/enhanced_04_advanced_routing.rb\n\n# Monitor pattern-based routing\nredis-cli PSUBSCRIBE \"*\"\n</code></pre>"},{"location":"transports/redis-enhanced-transport/#example-patterns","title":"Example Patterns","text":"<p>The enhanced examples demonstrate these routing patterns: - Service patterns: <code>user.*</code>, <code>order.*</code>, <code>payment.*</code> - Environment patterns: <code>*.dev</code>, <code>*.staging</code>, <code>*.prod</code> - Priority patterns: <code>urgent.*</code>, <code>normal.*</code>, <code>low.*</code> - Geographic patterns: <code>*.us-east</code>, <code>*.eu-west</code>, <code>*.asia</code></p>"},{"location":"transports/redis-enhanced-transport/#advanced-features","title":"Advanced Features","text":"<p>The enhanced transport examples also show: - Backward compatibility with standard Redis Transport - Performance optimizations for pattern-heavy workloads - Error handling for pattern mismatch scenarios - Testing strategies for pattern-based routing</p> <p>Each example builds on the previous ones, showing progressively more sophisticated routing capabilities that make Redis Enhanced Transport ideal for complex, distributed messaging architectures.</p>"},{"location":"transports/redis-queue-transport/","title":"Redis Queue Transport","text":"<p>The Redis Queue Transport is SmartMessage's most advanced transport implementation, providing RabbitMQ-style queue/exchange routing using Redis Lists as persistent FIFO queues. Built on Ruby's Async framework for modern fiber-based concurrency, it combines Redis's exceptional performance with intelligent message routing capabilities.</p>"},{"location":"transports/redis-queue-transport/#overview","title":"Overview","text":"<p>Redis Queue Transport is perfect for: - High-throughput applications - 100K+ messages/second with minimal latency - Complex routing scenarios - RabbitMQ-style pattern matching with Redis performance - Load-balanced processing - Consumer groups for horizontal scaling - Persistent message queues - Messages survive service restarts - Modern async applications - Built on Ruby's Async framework</p>"},{"location":"transports/redis-queue-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 RabbitMQ-Style Routing - Pattern-based subscriptions with familiar syntax</li> <li>\u26a1 Ultra-High Performance - ~0.5ms latency, 100K+ messages/second  </li> <li>\ud83e\uddec Async/Fiber Architecture - Thousands of concurrent subscriptions</li> <li>\ud83d\udd04 Persistent Queues - Redis Lists (LPUSH/BRPOP) for message durability</li> <li>\u2696\ufe0f Load Balancing - Consumer groups for horizontal scaling</li> <li>\ud83c\udfaf Enhanced Routing - Multi-segment routing keys with from/to addressing</li> <li>\ud83d\udcca Queue Monitoring - Comprehensive statistics and health monitoring</li> <li>\ud83d\udee0\ufe0f Fluent API - Chainable subscription building for complex routing</li> </ul>"},{"location":"transports/redis-queue-transport/#architecture","title":"Architecture","text":"<p>The Redis Queue Transport combines the routing intelligence of message brokers with Redis's performance characteristics. Built on Ruby's Async framework, it uses cooperative fiber-based concurrency for massive scalability with minimal resource overhead.</p>"},{"location":"transports/redis-queue-transport/#performance-comparison","title":"Performance Comparison","text":"Feature RabbitMQ Redis Queue (Async) Performance Advantage Latency ~5ms ~0.5ms Redis 10x faster Throughput 20K-30K msg/sec 100K+ msg/sec Redis 3-5x faster Concurrent Subscribers ~100s ~1000s Async 10x more Memory per Connection ~2MB ~2KB Async 1000x less Pattern Matching Server-side Client-side Same syntax Load Balancing Queue groups Consumer groups Same behavior Setup Complexity High Low Redis simpler"},{"location":"transports/redis-queue-transport/#configuration","title":"Configuration","text":""},{"location":"transports/redis-queue-transport/#basic-configuration","title":"Basic Configuration","text":"<pre><code>SmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: 'redis://localhost:6379',\n    db: 0,\n    queue_prefix: 'smart_message.queue',\n    consumer_group: 'default_workers',\n    block_time: 1000,  # 1 second blocking read\n    max_queue_length: 10000\n  }\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#message-class-configuration","title":"Message Class Configuration","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  transport :redis_queue, {\n    url: 'redis://redis-server:6379',\n    consumer_group: 'order_processors',\n    queue_prefix: 'orders'\n  }\n\n  property :order_id, required: true\n  property :amount, required: true\n\n  def process\n    # Process order logic\n    puts \"Processing order #{order_id} for $#{amount}\"\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#advanced-configuration-options","title":"Advanced Configuration Options","text":"<pre><code>transport = SmartMessage::Transport::RedisQueueTransport.new({\n  # Connection settings\n  url: 'redis://username:password@redis.example.com:6379',\n  db: 2,\n\n  # Queue settings\n  queue_prefix: 'myapp.queues',\n  consumer_group: 'myapp_workers',\n  consumer_id: \"#{Socket.gethostname}_#{Process.pid}\",\n\n  # Performance tuning\n  block_time: 5000,         # 5 second blocking timeout\n  max_queue_length: 50000,  # Trim queues at 50k messages\n  batch_size: 10,           # Process messages in batches\n\n  # Reliability settings\n  max_retries: 3,\n  retry_delay: 5,           # 5 seconds between retries\n  dead_letter_queue: true,\n\n  # Connection pooling\n  pool_size: 5,\n  pool_timeout: 1\n})\n</code></pre>"},{"location":"transports/redis-queue-transport/#async-architecture","title":"Async Architecture","text":"<p>The Redis Queue Transport is built on Ruby's Async framework, providing modern fiber-based concurrency that offers significant advantages over traditional thread-based approaches:</p>"},{"location":"transports/redis-queue-transport/#key-benefits","title":"Key Benefits","text":"<ul> <li>Massive Scalability: Support for thousands of concurrent subscribers with minimal resource overhead</li> <li>Cooperative Concurrency: Fibers yield control voluntarily, eliminating race conditions and reducing context switching overhead  </li> <li>Memory Efficiency: Each fiber uses ~2KB vs ~2MB per thread (1000x less memory)</li> <li>Test-Friendly: Clean async lifecycle management with proper shutdown and cleanup</li> <li>Non-Blocking I/O: All Redis operations are fully asynchronous and non-blocking</li> </ul>"},{"location":"transports/redis-queue-transport/#usage-with-async","title":"Usage with Async","text":"<p>All transport operations should be wrapped in <code>Async</code> blocks for optimal performance:</p> <pre><code># Basic async usage\nAsync do\n  transport = SmartMessage::Transport::RedisQueueTransport.new(\n    url: 'redis://localhost:6379',\n    db: 0,\n    test_mode: false  # Enable consumer tasks\n  )\n\n  # Subscribe to patterns\n  transport.subscribe_pattern(\"#.*.my_service\") do |message_class, data|\n    # Process messages in async fiber\n    puts \"Processing #{message_class} in fiber #{Async::Task.current.object_id}\"\n  end\n\n  # Publish messages\n  MyMessage.new(data: \"test\").publish\n\n  # Keep async context alive\n  sleep\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#async-best-practices","title":"Async Best Practices","text":"<pre><code># Multiple concurrent subscriptions\nAsync do |task|\n  transport = SmartMessage::Transport::RedisQueueTransport.new(...)\n\n  # Each subscription runs in its own fiber\n  task.async do\n    transport.subscribe_pattern(\"#.*.service1\") { |msg, data| ... }\n  end\n\n  task.async do  \n    transport.subscribe_pattern(\"#.*.service2\") { |msg, data| ... }\n  end\n\n  task.async do\n    transport.subscribe_pattern(\"#.*.service3\") { |msg, data| ... }\n  end\n\n  # All subscriptions run concurrently with minimal overhead\n  sleep\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#routing-keys-and-patterns","title":"Routing Keys and Patterns","text":""},{"location":"transports/redis-queue-transport/#routing-key-format","title":"Routing Key Format","text":"<p>Messages are published with enhanced routing keys in the format: <pre><code>namespace.message_type.from_uuid.to_uuid\n</code></pre></p> <p>Examples: - <code>order.ordermessage.user123.service456</code> - <code>emergency.alertmessage.security.broadcast</code> - <code>system.healthcheck.monitor.all_services</code></p>"},{"location":"transports/redis-queue-transport/#wildcard-patterns-rabbitmq-compatible","title":"Wildcard Patterns (RabbitMQ Compatible)","text":"<p>The Redis Queue Transport uses identical wildcard syntax to RabbitMQ:</p> <ul> <li><code>#</code> = Zero or more words (matches <code>a</code>, <code>a.b</code>, <code>a.b.c</code>)  </li> <li><code>*</code> = Exactly one word (matches <code>a</code> but not <code>a.b</code>)</li> <li><code>.</code> = Word separator (literal dot)</li> </ul>"},{"location":"transports/redis-queue-transport/#pattern-examples","title":"Pattern Examples","text":"<pre><code># Recipient-based routing\ntransport.subscribe_pattern(\"#.*.payment_service\")      # All TO payment_service\ntransport.subscribe_pattern(\"#.*.user_#{user_id}\")      # Personal messages\n\n# Sender-based routing  \ntransport.subscribe_pattern(\"#.admin_service.*\")        # All FROM admin_service\ntransport.subscribe_pattern(\"#.#{service_name}.*\")      # All from your service\n\n# Message type routing\ntransport.subscribe_pattern(\"order.#.*.*\")              # All order messages\ntransport.subscribe_pattern(\"alert.#.*.*\")              # All alerts\ntransport.subscribe_pattern(\"#{namespace}.#.*.*\")       # All in namespace\n\n# Complex routing\ntransport.subscribe_pattern(\"emergency.#.security.*\")   # Security emergencies\ntransport.subscribe_pattern(\"#.*.#{env}_services\")      # Environment-specific\n</code></pre>"},{"location":"transports/redis-queue-transport/#pattern-subscriptions","title":"Pattern Subscriptions","text":""},{"location":"transports/redis-queue-transport/#direct-pattern-subscriptions","title":"Direct Pattern Subscriptions","text":"<pre><code># Create transport instance\ntransport = SmartMessage::Transport::RedisQueueTransport.new(options)\n\n# Subscribe to messages TO specific services\ntransport.subscribe_pattern(\"#.*.payment_service\") do |message_class, message_data|\n  puts \"Payment service received: #{message_class}\"\n  # Process payment message\nend\n\n# Subscribe to messages FROM specific services\ntransport.subscribe_pattern(\"#.admin_service.*\") do |message_class, message_data|\n  puts \"Message from admin: #{message_class}\"\n  # Process admin message\nend\n\n# Subscribe to specific message types\ntransport.subscribe_pattern(\"order.#.*.*\") do |message_class, message_data|\n  puts \"Order message received: #{message_class}\"\n  # Process any order message\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#message-class-subscriptions","title":"Message Class Subscriptions","text":"<pre><code># Standard SmartMessage subscription (auto-generates patterns)\nclass OrderMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  # This automatically subscribes to pattern: \"order.ordermessage.*.*\"\nend\n\nOrderMessage.subscribe  # Subscribes to all OrderMessage instances\n\n# Custom pattern subscription for message class\nOrderMessage.subscribe_pattern(\"#.*.order_service\") do |message|\n  # Only process orders directed to order_service\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#convenience-methods","title":"Convenience Methods","text":"<p>The transport provides convenient methods for common routing patterns:</p> <pre><code># Simple recipient/sender filtering\ntransport.subscribe_to_recipient('my_service')          # Messages TO me\ntransport.subscribe_from_sender('payment_service')      # Messages FROM payment\ntransport.subscribe_to_type('OrderMessage')             # All OrderMessage types\n\n# Broadcast and alert patterns\ntransport.subscribe_to_broadcasts                        # All broadcast messages\ntransport.subscribe_to_alerts                           # Emergency/alert messages\n\n# Environment-based subscriptions\ntransport.subscribe_to_environment('production')        # Only prod messages\ntransport.subscribe_to_tenant('tenant_123')             # Tenant-specific messages\n</code></pre>"},{"location":"transports/redis-queue-transport/#fluent-api","title":"Fluent API","text":"<p>The fluent API provides an expressive way to build complex subscriptions:</p>"},{"location":"transports/redis-queue-transport/#basic-fluent-usage","title":"Basic Fluent Usage","text":"<pre><code># Simple FROM subscription\ntransport.where\n  .from('api_service')\n  .subscribe do |message_class, message_data|\n    puts \"Message from API service: #{message_class}\"\n  end\n\n# Simple TO subscription\ntransport.where\n  .to('task_processor')\n  .subscribe do |message_class, message_data|\n    puts \"Task for processor: #{message_class}\"\n  end\n\n# Type-specific subscription\ntransport.where\n  .type('TaskMessage')\n  .subscribe do |message_class, message_data|\n    puts \"Task message received: #{message_class}\"\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#advanced-fluent-combinations","title":"Advanced Fluent Combinations","text":"<pre><code># Combined FROM and TO\ntransport.where\n  .from('web_app')\n  .to('event_processor')\n  .subscribe do |message_class, message_data|\n    puts \"Web app event: #{message_class}\"\n  end\n\n# Consumer group with load balancing\ntransport.where\n  .type('TaskMessage')\n  .consumer_group('task_workers')\n  .subscribe do |message_class, message_data|\n    fiber_id = Async::Task.current.object_id.to_s[-4..-1]\n    puts \"Fiber-#{fiber_id} processing: #{message_class}\"\n  end\n\n# Complex multi-criteria subscription\ntransport.where\n  .from(/^admin_.*/)  # Regex pattern for admin services\n  .to('monitoring_service')\n  .consumer_group('monitoring_workers')\n  .subscribe do |message_class, message_data|\n    puts \"Admin monitoring: #{message_class}\"\n  end\n\n# Type and destination combination\ntransport.where\n  .type('EventMessage')\n  .to(/.*analytics.*/)  # Any service with 'analytics' in name\n  .subscribe do |message_class, message_data|\n    puts \"Analytics event: #{message_class}\"\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#dynamic-subscription-building","title":"Dynamic Subscription Building","text":"<pre><code># Build and modify subscriptions dynamically\nbase_subscription = transport.where.type('TaskMessage')\n\n# Add criteria dynamically\nurgent_tasks = base_subscription.from('urgent_processor')\npattern1 = urgent_tasks.build\nputs \"Urgent tasks pattern: #{pattern1}\"\n\n# Build different variations\nanalytics_tasks = base_subscription.to(/.*analytics.*/)\npattern2 = analytics_tasks.build  \nputs \"Analytics tasks pattern: #{pattern2}\"\n\n# Subscribe with complex pattern\ntransport.where\n  .type('EventMessage')\n  .from(/^(web|mobile)_app$/)  # From web or mobile app\n  .to(/.*analytics.*/)         # To any analytics service\n  .consumer_group('analytics_processors')\n  .subscribe do |message_class, message_data|\n    puts \"Complex pattern match: #{message_class}\"\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#load-balancing","title":"Load Balancing","text":""},{"location":"transports/redis-queue-transport/#consumer-groups","title":"Consumer Groups","text":"<p>Multiple consumers can share the same queue for automatic load distribution:</p> <pre><code># Create multiple workers in the same consumer group\nworker1_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  consumer_group: 'order_workers',\n  consumer_id: 'worker_1'\n})\n\nworker2_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  consumer_group: 'order_workers', \n  consumer_id: 'worker_2'\n})\n\nworker3_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  consumer_group: 'order_workers',\n  consumer_id: 'worker_3'\n})\n\n# All workers subscribe to same pattern\npattern = \"#.*.order_service\"\n\nworker1_transport.subscribe_pattern(pattern) { |msg| puts \"Worker 1: #{msg}\" }\nworker2_transport.subscribe_pattern(pattern) { |msg| puts \"Worker 2: #{msg}\" }  \nworker3_transport.subscribe_pattern(pattern) { |msg| puts \"Worker 3: #{msg}\" }\n\n# Messages published to order_service will be distributed among workers\n</code></pre>"},{"location":"transports/redis-queue-transport/#load-balancing-with-fluent-api","title":"Load Balancing with Fluent API","text":"<pre><code># Multiple workers using fluent API\n3.times do |i|\n  worker_transport = SmartMessage::Transport::RedisQueueTransport.new({\n    consumer_group: 'balanced_workers',\n    consumer_id: \"worker_#{i + 1}\"\n  })\n\n  worker_transport.where\n    .to('shared_service')\n    .consumer_group('balanced_workers')\n    .subscribe do |message_class, message_data|\n      puts \"Worker #{i + 1} processing: #{message_class}\"\n    end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#priority-based-load-balancing","title":"Priority-Based Load Balancing","text":"<pre><code># High-priority worker pool\nhigh_priority_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  consumer_group: 'high_priority_workers'\n})\n\nhigh_priority_transport.where\n  .to('priority_queue')\n  .consumer_group('high_priority_workers')  \n  .subscribe do |message_class, message_data|\n    puts \"HIGH PRIORITY: #{message_class}\"\n  end\n\n# Normal priority worker pool  \nnormal_priority_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  consumer_group: 'normal_workers'\n})\n\nnormal_priority_transport.where\n  .to('normal_queue')\n  .consumer_group('normal_workers')\n  .subscribe do |message_class, message_data|\n    puts \"Normal priority: #{message_class}\"\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#message-publishing","title":"Message Publishing","text":""},{"location":"transports/redis-queue-transport/#basic-publishing","title":"Basic Publishing","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :order_id, required: true\n  property :customer_id, required: true\n  property :amount, required: true\nend\n\n# Publish with automatic routing\nmessage = OrderMessage.new(\n  order_id: 'ORD-001',\n  customer_id: 'CUST-123', \n  amount: 99.99\n)\n\n# Set routing header for enhanced routing\nmessage._sm_header.from = 'order_service'\nmessage._sm_header.to = 'payment_service'\n\nmessage.publish  # Routes to: order.ordermessage.order_service.payment_service\n</code></pre>"},{"location":"transports/redis-queue-transport/#publishing-with-enhanced-headers","title":"Publishing with Enhanced Headers","text":"<pre><code># Explicit header setting\nOrderMessage.new(\n  order_id: 'ORD-002',\n  customer_id: 'CUST-456',\n  amount: 149.99,\n  _sm_header: {\n    from: 'api_gateway',\n    to: 'order_service',\n    correlation_id: SecureRandom.uuid,\n    tenant_id: 'tenant_123'\n  }\n).publish\n\n# Broadcast publishing\nAlertMessage.new(\n  alert_type: 'maintenance',\n  message: 'System maintenance starting in 10 minutes',\n  _sm_header: {\n    from: 'admin_service',\n    to: 'broadcast'  # Routes to all subscribers of broadcasts\n  }\n).publish\n\n# Environment-specific publishing\nDeploymentMessage.new(\n  version: '2.1.0',\n  changelog: 'Bug fixes and performance improvements',\n  _sm_header: {\n    from: 'ci_cd_service',\n    to: 'prod_services'  # Only production services\n  }\n).publish\n</code></pre>"},{"location":"transports/redis-queue-transport/#batch-publishing","title":"Batch Publishing","text":"<pre><code># Publish multiple messages efficiently\nmessages = []\n\n100.times do |i|\n  messages &lt;&lt; TaskMessage.new(\n    task_id: \"BATCH-#{i}\",\n    priority: 'normal',\n    _sm_header: {\n      from: 'batch_processor',\n      to: 'worker_pool'\n    }\n  )\nend\n\n# Batch publish for better performance\nmessages.each(&amp;:publish)  # Redis pipelining automatically optimizes this\n</code></pre>"},{"location":"transports/redis-queue-transport/#queue-management","title":"Queue Management","text":""},{"location":"transports/redis-queue-transport/#queue-statistics","title":"Queue Statistics","text":"<pre><code># Get comprehensive queue statistics\nstats = transport.queue_stats\n\n# Example output:\n# {\n#   \"smart_message.queue.#_*_payment_service\" =&gt; { \n#     length: 42, \n#     pattern: \"#.*.payment_service\",\n#     consumers: 2,\n#     consumer_group: \"payment_workers\",\n#     last_activity: Time.now - 30\n#   },\n#   \"smart_message.queue.order_#_*_*\" =&gt; {\n#     length: 0,\n#     pattern: \"order.#.*.*\", \n#     consumers: 3,\n#     consumer_group: \"order_workers\",\n#     last_activity: Time.now - 5\n#   }\n# }\n\n# Process statistics\nstats.each do |queue_name, info|\n  puts \"Queue: #{queue_name}\"\n  puts \"  Messages: #{info[:length]}\"\n  puts \"  Consumers: #{info[:consumers]}\"\n  puts \"  Pattern: #{info[:pattern]}\"\n  puts \"  Last Activity: #{info[:last_activity]}\"\n  puts \"\"\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#routing-table-inspection","title":"Routing Table Inspection","text":"<pre><code># View active routing patterns and their mappings\nrouting_table = transport.routing_table\n\n# Example output:\n# {\n#   \"#.*.payment_service\" =&gt; [\"smart_message.queue.#_*_payment_service\"],\n#   \"order.#.*.*\" =&gt; [\"smart_message.queue.order_#_*_*\"],\n#   \"#.admin_service.*\" =&gt; [\"smart_message.queue.#_admin_service_*\"]\n# }\n\n# Analyze routing patterns\nrouting_table.each do |pattern, queues|\n  puts \"Pattern '#{pattern}':\"\n  puts \"  Routes to #{queues.size} queue(s):\"\n  queues.each { |queue| puts \"    - #{queue}\" }\n  puts \"\"\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#queue-health-monitoring","title":"Queue Health Monitoring","text":"<pre><code># Monitor queue health and performance\ndef monitor_queue_health(transport)\n  stats = transport.queue_stats\n  health_issues = []\n\n  stats.each do |queue_name, info|\n    # Check for potential issues\n    if info[:length] &gt; 1000\n      health_issues &lt;&lt; \"WARNING: Queue #{queue_name} has #{info[:length]} messages (high load)\"\n    elsif info[:length] &gt; 0 &amp;&amp; info[:consumers] == 0\n      health_issues &lt;&lt; \"ERROR: Queue #{queue_name} has messages but no consumers\"\n    elsif info[:consumers] &gt; 10\n      health_issues &lt;&lt; \"INFO: Queue #{queue_name} has #{info[:consumers]} consumers (possible over-provisioning)\"\n    end\n\n    # Check for stale queues\n    if info[:last_activity] &amp;&amp; info[:last_activity] &lt; Time.now - 300  # 5 minutes\n      health_issues &lt;&lt; \"WARNING: Queue #{queue_name} inactive for #{Time.now - info[:last_activity]} seconds\"\n    end\n  end\n\n  if health_issues.any?\n    puts \"Queue Health Issues:\"\n    health_issues.each { |issue| puts \"  #{issue}\" }\n  else\n    puts \"All queues healthy \u2705\"\n  end\n\n  health_issues\nend\n\n# Run health check\nhealth_issues = monitor_queue_health(transport)\n</code></pre>"},{"location":"transports/redis-queue-transport/#administrative-operations","title":"Administrative Operations","text":"<pre><code># Clear specific queue\ntransport.clear_queue(\"smart_message.queue.#_*_test_service\")\n\n# Clear all queues for consumer group\ntransport.clear_consumer_group_queues(\"test_workers\")\n\n# Get queue length\nlength = transport.queue_length(\"smart_message.queue.order_#_*_*\")\nputs \"Order queue length: #{length}\"\n\n# Pause/resume consumer groups\ntransport.pause_consumer_group(\"maintenance_workers\")\ntransport.resume_consumer_group(\"maintenance_workers\")\n\n# Get consumer group information\nconsumer_info = transport.consumer_group_info(\"order_workers\")\nputs \"Consumer group info: #{consumer_info}\"\n</code></pre>"},{"location":"transports/redis-queue-transport/#error-handling-and-reliability","title":"Error Handling and Reliability","text":""},{"location":"transports/redis-queue-transport/#retry-mechanisms","title":"Retry Mechanisms","text":"<pre><code>class ReliableMessage &lt; SmartMessage::Base\n  transport :redis_queue, {\n    max_retries: 3,\n    retry_delay: 5,           # 5 seconds between retries\n    exponential_backoff: true # 5s, 25s, 125s delays\n  }\n\n  property :data, required: true\n\n  def process\n    begin\n      # Potentially failing operation\n      external_service.process(data)\n    rescue ExternalService::TemporaryError =&gt; e\n      # Retryable error - will be retried automatically\n      raise SmartMessage::Errors::RetryableError, e.message\n    rescue ExternalService::ValidationError =&gt; e\n      # Permanent error - goes to dead letter queue\n      raise SmartMessage::Errors::PermanentError, e.message\n    end\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#dead-letter-queue","title":"Dead Letter Queue","text":"<pre><code># Configure dead letter queue\ntransport = SmartMessage::Transport::RedisQueueTransport.new({\n  dead_letter_queue: true,\n  dead_letter_prefix: 'dlq',\n  max_retries: 3\n})\n\n# Monitor dead letter queue\ndlq_stats = transport.dead_letter_stats\nputs \"Dead letter messages: #{dlq_stats[:count]}\"\nputs \"Recent errors: #{dlq_stats[:recent_errors]}\"\n\n# Process dead letter messages\ntransport.process_dead_letters do |message_data, error_info|\n  puts \"Dead letter: #{message_data}\"\n  puts \"Error: #{error_info[:error_message]}\"\n  puts \"Retry count: #{error_info[:retry_count]}\"\n\n  # Decide whether to retry, route elsewhere, or discard\n  if error_info[:retry_count] &lt; 5 &amp;&amp; fixable_error?(error_info[:error_message])\n    :retry  # Retry the message\n  else\n    :discard  # Discard the message\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<pre><code>class CircuitBreakerMessage &lt; SmartMessage::Base\n  transport :redis_queue, {\n    circuit_breaker: true,\n    failure_threshold: 5,    # Open circuit after 5 failures\n    recovery_timeout: 60,    # Try again after 60 seconds\n    half_open_max_calls: 3   # Allow 3 calls when half-open\n  }\n\n  def process\n    # External service call\n    external_service.call(data)\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#use-cases-and-examples","title":"Use Cases and Examples","text":""},{"location":"transports/redis-queue-transport/#microservices-communication","title":"Microservices Communication","text":"<pre><code># API Gateway routing requests to services\nclass ServiceRequest &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :service_name, required: true\n  property :operation, required: true\n  property :payload, default: {}\nend\n\n# Route based on service name\napi_gateway_transport.where\n  .type('ServiceRequest')\n  .subscribe do |message_class, message_data|\n    request = JSON.parse(message_data)\n\n    # Forward to appropriate service\n    ServiceRequest.new(request.merge(\n      '_sm_header' =&gt; {\n        'from' =&gt; 'api_gateway',\n        'to' =&gt; request['service_name']\n      }\n    )).publish\n  end\n\n# Services subscribe to their own requests\nuser_service_transport.where\n  .to('user_service')\n  .consumer_group('user_workers')\n  .subscribe do |message_class, message_data|\n    # Process user service request\n  end\n\npayment_service_transport.where\n  .to('payment_service')\n  .consumer_group('payment_workers')\n  .subscribe do |message_class, message_data|\n    # Process payment service request  \n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#event-driven-architecture","title":"Event-Driven Architecture","text":"<pre><code># Order processing workflow\nclass OrderPlaced &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :order_id, required: true\n  property :customer_id, required: true\n  property :items, required: true\nend\n\n# Multiple services process order events\ninventory_service.where\n  .type('OrderPlaced')\n  .consumer_group('inventory_workers')\n  .subscribe do |message_class, message_data|\n    # Reserve inventory\n  end\n\npayment_service.where\n  .type('OrderPlaced')\n  .consumer_group('payment_workers')\n  .subscribe do |message_class, message_data|\n    # Process payment\n  end\n\nshipping_service.where\n  .type('OrderPlaced')\n  .consumer_group('shipping_workers')\n  .subscribe do |message_class, message_data|\n    # Arrange shipping\n  end\n\nanalytics_service.where\n  .type('OrderPlaced')\n  .consumer_group('analytics_workers')\n  .subscribe do |message_class, message_data|\n    # Track metrics\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#multi-tenant-systems","title":"Multi-Tenant Systems","text":"<pre><code># Tenant isolation via routing\nclass TenantMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :tenant_id, required: true\n  property :data, required: true\nend\n\n# Each tenant gets isolated message processing\ntenant_transport.where\n  .from(/^tenant_#{tenant_id}_.*/)\n  .to(/^tenant_#{tenant_id}_.*/)\n  .consumer_group(\"tenant_#{tenant_id}_workers\")\n  .subscribe do |message_class, message_data|\n    # Process tenant-specific message\n  end\n\n# Admin messages broadcast to all tenants\nadmin_transport.where\n  .from('admin_service')\n  .to('broadcast')\n  .subscribe do |message_class, message_data|\n    # Process admin broadcast\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#real-time-monitoring-and-alerting","title":"Real-Time Monitoring and Alerting","text":"<pre><code># Monitoring system with alert routing\nclass MetricMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  property :metric_name, required: true\n  property :value, required: true\n  property :threshold, required: true\n  property :severity, default: 'info'\nend\n\n# Route based on severity\nmonitoring_transport.where\n  .type('MetricMessage')\n  .subscribe do |message_class, message_data|\n    metric = JSON.parse(message_data)\n\n    if metric['value'] &gt; metric['threshold']\n      severity = if metric['value'] &gt; metric['threshold'] * 2\n                   'critical'\n                 elsif metric['value'] &gt; metric['threshold'] * 1.5\n                   'warning'\n                 else\n                   'info'\n                 end\n\n      AlertMessage.new(\n        alert_type: metric['metric_name'],\n        message: \"#{metric['metric_name']} is #{metric['value']} (threshold: #{metric['threshold']})\",\n        severity: severity,\n        _sm_header: {\n          from: 'monitoring_service',\n          to: severity == 'critical' ? 'pager_duty' : 'alert_dashboard'\n        }\n      ).publish\n    end\n  end\n</code></pre>"},{"location":"transports/redis-queue-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/redis-queue-transport/#naming-conventions","title":"Naming Conventions","text":"<pre><code># Use descriptive queue prefixes\ntransport = SmartMessage::Transport::RedisQueueTransport.new({\n  queue_prefix: 'myapp.production.queues'  # Environment-specific\n})\n\n# Use meaningful consumer group names\ntransport.where\n  .to('order_service')\n  .consumer_group('order_processors')  # Descriptive group name\n  .subscribe\n</code></pre>"},{"location":"transports/redis-queue-transport/#resource-management","title":"Resource Management","text":"<pre><code># Proper cleanup on shutdown\nat_exit do\n  transport.disconnect\n  transport.cleanup_consumer_groups\nend\n\n# Connection pooling for high-throughput applications\ntransport = SmartMessage::Transport::RedisQueueTransport.new({\n  pool_size: 10,\n  pool_timeout: 5\n})\n</code></pre>"},{"location":"transports/redis-queue-transport/#monitoring-and-observability","title":"Monitoring and Observability","text":"<pre><code># Regular health monitoring with Async\nAsync do\n  loop do\n    stats = transport.queue_stats\n\n    # Log queue lengths\n    stats.each do |queue, info|\n      if info[:length] &gt; 100\n        Rails.logger.warn \"Queue #{queue} backing up: #{info[:length]} messages\"\n      end\n    end\n\n    # Check consumer health\n    dead_consumers = stats.select { |_, info| info[:consumers] == 0 &amp;&amp; info[:length] &gt; 0 }\n    unless dead_consumers.empty?\n      Rails.logger.error \"Queues with no consumers: #{dead_consumers.keys}\"\n    end\n\n    sleep 30\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Batch processing for high throughput\ntransport.where\n  .to('batch_processor')\n  .subscribe do |message_class, message_data|\n    # Process in batches\n    batch = []\n\n    batch &lt;&lt; JSON.parse(message_data)\n\n    if batch.size &gt;= 10  # Process every 10 messages\n      process_batch(batch)\n      batch.clear\n    end\n  end\n\n# Use appropriate block times\nfast_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  block_time: 100  # Low latency, higher CPU usage\n})\n\nefficient_transport = SmartMessage::Transport::RedisQueueTransport.new({\n  block_time: 5000  # Higher latency, lower CPU usage\n})\n</code></pre>"},{"location":"transports/redis-queue-transport/#migration-from-other-transports","title":"Migration from Other Transports","text":""},{"location":"transports/redis-queue-transport/#from-redis-pubsub","title":"From Redis Pub/Sub","text":"<pre><code># Old Redis Pub/Sub approach\nclass OrderMessage &lt; SmartMessage::Base\n  transport :redis  # Simple pub/sub, everyone gets message\nend\n\nOrderMessage.subscribe  # All subscribers get ALL messages\n\n# New Redis Queue approach\nclass OrderMessage &lt; SmartMessage::Base  \n  transport :redis_queue  # Queue-based with routing\nend\n\n# Targeted subscriptions\nOrderMessage.where.to('order_processor').subscribe     # Only my orders\nOrderMessage.where.from('api_gateway').subscribe       # Only from gateway\nOrderMessage.subscribe_pattern(\"#.*.order_service\")    # RabbitMQ-style patterns\n</code></pre>"},{"location":"transports/redis-queue-transport/#from-rabbitmq","title":"From RabbitMQ","text":"<pre><code># RabbitMQ configuration\nclass OrderMessage &lt; SmartMessage::Base\n  transport :rabbitmq, {\n    exchange: 'orders',\n    queue: 'order_processing'\n  }\nend\n\n# Equivalent Redis Queue configuration  \nclass OrderMessage &lt; SmartMessage::Base\n  transport :redis_queue, {\n    queue_prefix: 'orders',\n    consumer_group: 'order_processors'\n  }\nend\n\n# Pattern subscriptions work identically\ntransport.subscribe_pattern(\"#.*.order_service\")  # Same syntax!\n</code></pre>"},{"location":"transports/redis-queue-transport/#troubleshooting","title":"Troubleshooting","text":""},{"location":"transports/redis-queue-transport/#common-issues","title":"Common Issues","text":"<p>Queue Not Processing Messages <pre><code># Check queue stats\nstats = transport.queue_stats\nputs \"Queue stats: #{stats}\"\n\n# Verify pattern matching\npattern = \"#.*.my_service\"\ntest_key = \"order.ordermessage.api_gateway.my_service\"\nmatches = transport.send(:routing_key_matches_pattern?, test_key, pattern)\nputs \"Pattern '#{pattern}' matches '#{test_key}': #{matches}\"\n</code></pre></p> <p>High Memory Usage <pre><code># Monitor queue lengths\nstats = transport.queue_stats\nlong_queues = stats.select { |_, info| info[:length] &gt; 1000 }\nputs \"Long queues: #{long_queues}\"\n\n# Configure queue limits\ntransport = SmartMessage::Transport::RedisQueueTransport.new({\n  max_queue_length: 5000  # Trim at 5k messages\n})\n</code></pre></p> <p>Consumer Not Receiving Messages <pre><code># Check consumer group membership\nconsumer_info = transport.consumer_group_info(\"my_workers\")\nputs \"Consumers: #{consumer_info}\"\n\n# Verify routing table\nrouting_table = transport.routing_table\nputs \"Routing table: #{routing_table}\"\n</code></pre></p>"},{"location":"transports/redis-queue-transport/#debug-mode","title":"Debug Mode","text":"<pre><code># Enable comprehensive debugging\ntransport = SmartMessage::Transport::RedisQueueTransport.new({\n  debug: true,\n  log_level: :debug\n})\n\n# Monitor Redis commands\n# In separate terminal: redis-cli MONITOR\n</code></pre>"},{"location":"transports/redis-queue-transport/#performance-debugging","title":"Performance Debugging","text":"<pre><code># Measure publishing performance\nstart_time = Time.now\n1000.times { |i| TestMessage.new(id: i).publish }\nduration = Time.now - start_time\nputs \"Published 1000 messages in #{duration}s (#{1000/duration} msg/s)\"\n\n# Measure processing performance\nprocessed = 0\nstart_time = Time.now\n\ntransport.subscribe_pattern(\"#.*.*\") do |message_class, message_data|\n  processed += 1\n  if processed % 100 == 0\n    rate = processed / (Time.now - start_time)\n    puts \"Processed #{processed} messages (#{rate} msg/s)\"\n  end\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/redis-queue-transport/#transport-class","title":"Transport Class","text":"<pre><code>class SmartMessage::Transport::RedisQueueTransport &lt; Base\n  # Configuration\n  def initialize(options = {})\n  def configure\n  def connected?\n  def connect\n  def disconnect\n\n  # Publishing\n  def do_publish(message_class, serialized_message)\n\n  # Subscriptions\n  def subscribe(message_class, process_method, filter_options = {})\n  def subscribe_pattern(pattern, &amp;block)\n  def unsubscribe(message_class, process_method)\n  def unsubscribe!(message_class)\n\n  # Convenience methods\n  def subscribe_to_recipient(recipient_id)\n  def subscribe_from_sender(sender_id)\n  def subscribe_to_type(message_type)\n  def subscribe_to_broadcasts\n  def subscribe_to_alerts\n\n  # Fluent API\n  def where\n\n  # Management\n  def queue_stats\n  def routing_table\n  def queue_length(queue_name)\n  def clear_queue(queue_name)\n  def clear_all_queues\n  def consumer_group_info(group_name)\n\n  # Health and monitoring\n  def health_check\n  def performance_metrics\n  def dead_letter_stats\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#fluent-api-builder","title":"Fluent API Builder","text":"<pre><code>class SmartMessage::Transport::RedisQueueSubscriptionBuilder\n  def from(sender_id)\n  def to(recipient_id) \n  def type(message_type)\n  def consumer_group(group_name)\n  def build  # Returns pattern string\n  def subscribe(&amp;block)  # Subscribes with built pattern\nend\n</code></pre>"},{"location":"transports/redis-queue-transport/#configuration-reference","title":"Configuration Reference","text":""},{"location":"transports/redis-queue-transport/#transport-options","title":"Transport Options","text":"Option Type Default Description <code>url</code> String <code>redis://localhost:6379</code> Redis connection URL <code>db</code> Integer <code>0</code> Redis database number <code>queue_prefix</code> String <code>smart_message.queue</code> Prefix for queue names <code>consumer_group</code> String <code>default_workers</code> Consumer group name <code>consumer_id</code> String <code>#{hostname}_#{pid}</code> Unique consumer identifier <code>block_time</code> Integer <code>1000</code> Blocking timeout in milliseconds <code>max_queue_length</code> Integer <code>10000</code> Maximum messages per queue <code>batch_size</code> Integer <code>1</code> Messages to process per batch <code>max_retries</code> Integer <code>3</code> Maximum retry attempts <code>retry_delay</code> Integer <code>5</code> Seconds between retries <code>exponential_backoff</code> Boolean <code>false</code> Use exponential backoff for retries <code>dead_letter_queue</code> Boolean <code>false</code> Enable dead letter queue <code>dead_letter_prefix</code> String <code>dlq</code> Prefix for dead letter queues <code>circuit_breaker</code> Boolean <code>false</code> Enable circuit breaker <code>failure_threshold</code> Integer <code>5</code> Circuit breaker failure threshold <code>recovery_timeout</code> Integer <code>60</code> Circuit breaker recovery timeout <code>pool_size</code> Integer <code>1</code> Connection pool size <code>pool_timeout</code> Integer <code>1</code> Connection pool timeout <code>debug</code> Boolean <code>false</code> Enable debug logging"},{"location":"transports/redis-queue-transport/#examples","title":"Examples","text":"<p>The <code>examples/redis_queue/</code> directory contains comprehensive, production-ready examples demonstrating Redis Queue Transport capabilities:</p>"},{"location":"transports/redis-queue-transport/#core-queue-messaging","title":"Core Queue Messaging","text":"<ul> <li>01_basic_messaging.rb - Foundation queue messaging patterns</li> <li>Basic message publishing and consumption</li> <li>Consumer group configuration</li> <li> <p>Queue-based message processing</p> </li> <li> <p>01_comprehensive_examples.rb - Complete feature demonstration</p> </li> <li>All Redis Queue Transport capabilities in one example</li> <li>Pattern routing, load balancing, error handling</li> <li>Production patterns and best practices</li> </ul>"},{"location":"transports/redis-queue-transport/#advanced-routing-patterns","title":"Advanced Routing &amp; Patterns","text":"<ul> <li>02_pattern_routing.rb - RabbitMQ-style pattern routing</li> <li>Topic-based routing with patterns</li> <li>Wildcard subscriptions (<code>#</code>, <code>*</code>)</li> <li> <p>Complex routing scenarios</p> </li> <li> <p>03_fluent_api.rb - Fluent API usage examples</p> </li> <li>Chain-based subscription configuration</li> <li>Dynamic routing with builder pattern</li> <li>Readable subscription management</li> </ul>"},{"location":"transports/redis-queue-transport/#production-features","title":"Production Features","text":"<ul> <li>04_load_balancing.rb - Load balancing across workers</li> <li>Consumer group scaling</li> <li>Work distribution patterns</li> <li> <p>High-availability setups</p> </li> <li> <p>05_microservices.rb - Microservices communication</p> </li> <li>Service-to-service messaging</li> <li>Distributed system coordination</li> <li> <p>Cross-service event handling</p> </li> <li> <p>06_emergency_alerts.rb - Emergency alert system</p> </li> <li>Priority message handling</li> <li>Alert escalation workflows</li> <li> <p>Critical message processing</p> </li> <li> <p>07_queue_management.rb - Queue management utilities</p> </li> <li>Queue monitoring and statistics</li> <li>Dead letter queue handling</li> <li>Performance optimization techniques</li> </ul>"},{"location":"transports/redis-queue-transport/#enhanced-transport-integration","title":"Enhanced Transport Integration","text":"<ul> <li>enhanced_01_basic_patterns.rb - Enhanced transport patterns</li> <li>enhanced_02_fluent_api.rb - Enhanced fluent API</li> <li>enhanced_03_dual_publishing.rb - Dual publishing strategies</li> <li>enhanced_04_advanced_routing.rb - Advanced routing scenarios</li> </ul>"},{"location":"transports/redis-queue-transport/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The Redis Queue examples showcase enterprise-grade messaging capabilities: - Persistent Queues - Guaranteed message delivery with Redis Streams - Load Balancing - Work distribution across consumer groups - Pattern Routing - RabbitMQ-style topic routing (<code>user.orders.#</code>) - Dead Letter Queues - Failed message handling and replay - Circuit Breakers - Resilient error handling and recovery - Performance Monitoring - Queue statistics and health monitoring - Fluent API - Builder pattern for complex subscriptions</p>"},{"location":"transports/redis-queue-transport/#running-examples","title":"Running Examples","text":"<pre><code># Prerequisites: Start Redis server (version 5.0+)\nredis-server\n\n# Navigate to the SmartMessage directory\ncd smart_message\n\n# Run queue transport examples\nruby examples/redis_queue/01_basic_messaging.rb\nruby examples/redis_queue/02_pattern_routing.rb\nruby examples/redis_queue/04_load_balancing.rb\n\n# Monitor queue activity\nredis-cli XINFO GROUPS smart_message.queue.TestMessage\nredis-cli XLEN smart_message.queue.TestMessage\n</code></pre>"},{"location":"transports/redis-queue-transport/#example-patterns","title":"Example Patterns","text":"<p>The queue examples demonstrate these routing patterns: - Service patterns: <code>user.orders.#</code>, <code>payment.*.processed</code> - Priority routing: <code>urgent.*</code>, <code>normal.*</code>, <code>bulk.*</code> - Geographic routing: <code>*.us-east.#</code>, <code>*.eu-west.#</code> - System patterns: <code>system.alerts.#</code>, <code>monitoring.*.stats</code></p>"},{"location":"transports/redis-queue-transport/#production-features_1","title":"Production Features","text":"<p>The Redis Queue examples demonstrate enterprise requirements: - High Availability - Consumer group failover and recovery - Scalability - Horizontal scaling with multiple workers - Durability - Message persistence with Redis Streams - Observability - Comprehensive monitoring and metrics - Error Handling - Dead letter queues and retry mechanisms</p> <p>Each example includes detailed logging, error handling, and demonstrates production-ready patterns for mission-critical messaging systems.</p>"},{"location":"transports/redis-queue-transport/#additional-resources","title":"Additional Resources","text":"<p>For comprehensive Redis Queue documentation: - Redis Queue Getting Started Guide - Step-by-step setup - Redis Queue Production Guide - Production deployment - Redis Queue Patterns Guide - Advanced messaging patterns</p>"},{"location":"transports/redis-queue-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Redis Transport - Basic Redis pub/sub transport</li> <li>Redis Enhanced Transport - Enhanced routing capabilities  </li> <li>Transport Comparison - Compare all Redis transports</li> <li>Transport Overview - All available transports</li> </ul> <p>The Redis Queue Transport represents the pinnacle of SmartMessage's transport evolution, combining the simplicity of Redis with the sophistication of enterprise message brokers. Its unique architecture delivers both the performance characteristics developers need and the routing intelligence that complex applications demand.</p>"},{"location":"transports/redis-transport-comparison/","title":"Redis Transport Comparison","text":"<p>SmartMessage provides three distinct Redis-based transports, each designed for different use cases and requirements. This document provides a comprehensive comparison to help you choose the right transport for your application.</p>"},{"location":"transports/redis-transport-comparison/#transport-overview","title":"Transport Overview","text":"Transport Type Best For Key Feature Redis Basic Pub/Sub Simple scenarios, legacy compatibility Lightweight, direct Redis pub/sub Redis Enhanced Smart Routing Microservices, pattern-based routing RabbitMQ-style patterns with backwards compatibility Redis Queue Persistent Queues Production systems, load balancing FIFO queues with consumer groups"},{"location":"transports/redis-transport-comparison/#redis-transport-basic","title":"\ud83d\udd27 Redis Transport (Basic)","text":"<p>The foundational Redis transport using native pub/sub channels.</p>"},{"location":"transports/redis-transport-comparison/#architecture","title":"Architecture","text":"<pre><code>Publisher \u2192 Redis Channel \u2192 Subscriber\n         (direct pub/sub)   (thread-based)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Channel Naming: Uses message class name directly (<code>OrderMessage</code>)</li> <li>Pattern Support: None - exact channel name matching only</li> <li>Message Persistence: No - fire-and-forget pub/sub</li> <li>Load Balancing: No - all subscribers receive all messages</li> <li>Threading: Traditional thread-per-subscriber model</li> <li>Backwards Compatibility: Original SmartMessage Redis implementation</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration","title":"Configuration","text":"<pre><code>SmartMessage::Transport.create(:redis,\n  url: 'redis://localhost:6379',\n  db: 0,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 1\n)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#use-cases","title":"Use Cases","text":"<ul> <li>Simple applications with basic pub/sub needs</li> <li>Development/testing environments</li> <li>Legacy systems already using basic Redis transport</li> <li>Scenarios where message loss is acceptable</li> <li>High-performance applications needing minimal overhead</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros","title":"Pros","text":"<ul> <li>\u2705 Simplest implementation and configuration</li> <li>\u2705 Lowest resource overhead</li> <li>\u2705 Direct Redis pub/sub - maximum performance</li> <li>\u2705 No external dependencies beyond Redis</li> <li>\u2705 Battle-tested and stable</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons","title":"Cons","text":"<ul> <li>\u274c No pattern-based routing</li> <li>\u274c No message persistence</li> <li>\u274c No load balancing capabilities</li> <li>\u274c Limited routing intelligence</li> <li>\u274c All-or-nothing message delivery</li> </ul>"},{"location":"transports/redis-transport-comparison/#example","title":"Example","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  transport SmartMessage::Transport.create(:redis, \n    url: 'redis://localhost:6379'\n  )\n\n  property :order_id\n  property :amount\nend\n\n# Publishes to Redis channel \"OrderMessage\"\nOrderMessage.new(order_id: \"123\", amount: 99.99).publish\n\n# Subscribes to Redis channel \"OrderMessage\" \nOrderMessage.subscribe\n</code></pre>"},{"location":"transports/redis-transport-comparison/#redis-enhanced-transport","title":"\ud83c\udfaf Redis Enhanced Transport","text":"<p>Advanced Redis transport with intelligent routing and pattern matching.</p>"},{"location":"transports/redis-transport-comparison/#architecture_1","title":"Architecture","text":"<pre><code>Publisher \u2192 Enhanced Router \u2192 Dual Channels \u2192 Pattern Matcher \u2192 Subscriber\n         (3-part naming)   (orig + enhanced) (wildcard support) (thread-based)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics_1","title":"Key Characteristics","text":"<ul> <li>Channel Naming: Dual format - both <code>MessageClass</code> and <code>messagetype.from.to</code></li> <li>Pattern Support: Full wildcard support (<code>*</code> single segment, multiple patterns)</li> <li>Message Persistence: No - still based on pub/sub</li> <li>Load Balancing: No - all matching subscribers receive messages</li> <li>Threading: Traditional thread-per-subscriber model</li> <li>Backwards Compatibility: Yes - publishes to both channel formats</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration_1","title":"Configuration","text":"<pre><code>SmartMessage::Transport::RedisEnhancedTransport.new(\n  url: 'redis://localhost:6379',\n  db: 0,\n  auto_subscribe: true\n)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#enhanced-features","title":"Enhanced Features","text":""},{"location":"transports/redis-transport-comparison/#pattern-subscriptions","title":"Pattern Subscriptions","text":"<pre><code>transport.subscribe_pattern(\"ordermessage.*.*\")      # All order messages\ntransport.subscribe_pattern(\"*.payment_service.*\")   # All to payment service\ntransport.subscribe_pattern(\"alertmessage.*.*\")      # All alerts\n</code></pre>"},{"location":"transports/redis-transport-comparison/#convenience-methods","title":"Convenience Methods","text":"<pre><code>transport.subscribe_to_recipient('payment-service')  # *.*.payment-service\ntransport.subscribe_from_sender('api-gateway')       # *.api-gateway.*\ntransport.subscribe_to_type('OrderMessage')          # ordermessage.*.*\ntransport.subscribe_to_alerts                        # emergency.*.*, *alert*.*.*\ntransport.subscribe_to_broadcasts                    # *.*.broadcast\n</code></pre>"},{"location":"transports/redis-transport-comparison/#fluent-api","title":"Fluent API","text":"<pre><code>transport.where.from('web-app').to('user-service').subscribe\ntransport.where.type('OrderMessage').from('api').subscribe\ntransport.where.from('monitoring').to('admin').type('AlertMessage').subscribe\n</code></pre>"},{"location":"transports/redis-transport-comparison/#use-cases_1","title":"Use Cases","text":"<ul> <li>Microservices architectures requiring sophisticated routing</li> <li>Migration scenarios from basic Redis transport</li> <li>Development environments needing flexible routing</li> <li>Pattern-based filtering without message persistence requirements</li> <li>Service-to-service communication with routing intelligence</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros_1","title":"Pros","text":"<ul> <li>\u2705 Advanced pattern-based routing</li> <li>\u2705 Fluent, readable subscription API</li> <li>\u2705 Backwards compatible with basic Redis transport</li> <li>\u2705 Sophisticated filtering capabilities</li> <li>\u2705 Service-oriented routing patterns</li> <li>\u2705 RabbitMQ-style routing without RabbitMQ</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons_1","title":"Cons","text":"<ul> <li>\u274c No message persistence</li> <li>\u274c No load balancing</li> <li>\u274c Pattern matching overhead (client-side)</li> <li>\u274c Dual publishing increases Redis traffic</li> <li>\u274c More complex configuration</li> </ul>"},{"location":"transports/redis-transport-comparison/#example_1","title":"Example","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  from 'e-commerce-api'\n  to 'order-processor'\n\n  transport SmartMessage::Transport::RedisEnhancedTransport.new(\n    url: 'redis://localhost:6379'\n  )\n\n  property :order_id\n  property :amount\nend\n\n# Publishes to BOTH:\n# - \"OrderMessage\" (backwards compatibility)  \n# - \"ordermessage.e_commerce_api.order_processor\" (enhanced)\nOrderMessage.new(order_id: \"123\", amount: 99.99).publish\n\n# Pattern-based subscriptions\ntransport.where.from('e-commerce-api').subscribe\ntransport.subscribe_to_type('OrderMessage')\n</code></pre>"},{"location":"transports/redis-transport-comparison/#redis-queue-transport","title":"\ud83d\ude80 Redis Queue Transport","text":"<p>Production-grade transport with persistent queues and load balancing.</p>"},{"location":"transports/redis-transport-comparison/#architecture_2","title":"Architecture","text":"<pre><code>Publisher \u2192 Routing Engine \u2192 Redis List \u2192 Consumer Group \u2192 Async Worker\n         (in-memory)     (LPUSH/BRPOP)  (load balancing) (fiber-based)\n</code></pre>"},{"location":"transports/redis-transport-comparison/#key-characteristics_2","title":"Key Characteristics","text":"<ul> <li>Channel Naming: Enhanced routing keys with queue-based delivery</li> <li>Pattern Support: RabbitMQ-compatible wildcard patterns</li> <li>Message Persistence: Yes - Redis Lists provide FIFO persistence</li> <li>Load Balancing: Yes - consumer groups distribute messages</li> <li>Threading: Async/fiber-based for massive concurrency</li> <li>Backwards Compatibility: No - completely different architecture</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration_2","title":"Configuration","text":"<pre><code>SmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: 'redis://localhost:6379',\n    db: 0,\n    queue_prefix: 'smart_message.queue',\n    exchange_name: 'smart_message',\n    consumer_group: 'workers',\n    consumer_id: SecureRandom.hex(4),\n    consumer_timeout: 1,\n    auto_subscribe: true\n  }\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#advanced-features","title":"Advanced Features","text":""},{"location":"transports/redis-transport-comparison/#load-balancing","title":"Load Balancing","text":"<pre><code># Multiple consumers share work\nconsumer_1 = RedisQueueTransport.new(consumer_group: 'workers', consumer_id: 'worker_1')\nconsumer_2 = RedisQueueTransport.new(consumer_group: 'workers', consumer_id: 'worker_2')\n# Messages distributed between worker_1 and worker_2\n</code></pre>"},{"location":"transports/redis-transport-comparison/#pattern-based-routing","title":"Pattern-based Routing","text":"<pre><code>transport.subscribe_pattern(\"#.*.payment_service\")     # RabbitMQ syntax\ntransport.subscribe_pattern(\"order.#.*.*\")             # Multi-segment wildcards\ntransport.where().from('api').to('db').subscribe       # Fluent API\n</code></pre>"},{"location":"transports/redis-transport-comparison/#queue-management","title":"Queue Management","text":"<pre><code>transport.queue_stats                    # Queue lengths and info\ntransport.routing_table                  # Active pattern mappings\ntransport.where.from('api').build        # Preview pattern without subscribing\n</code></pre>"},{"location":"transports/redis-transport-comparison/#performance-characteristics","title":"Performance Characteristics","text":"Metric Value Comparison Latency ~0.5ms 10x faster than RabbitMQ Throughput 100K+ msg/sec 3-5x faster than RabbitMQ Concurrent Consumers 1000+ 10x more than traditional threading Memory per Consumer ~2KB 1000x less than RabbitMQ connections"},{"location":"transports/redis-transport-comparison/#use-cases_2","title":"Use Cases","text":"<ul> <li>Production systems requiring message persistence</li> <li>Load-balanced processing with multiple consumers</li> <li>High-throughput applications needing maximum performance</li> <li>Fault-tolerant systems where message loss is unacceptable</li> <li>Enterprise applications requiring queue monitoring</li> </ul>"},{"location":"transports/redis-transport-comparison/#pros_2","title":"Pros","text":"<ul> <li>\u2705 Message persistence and reliability</li> <li>\u2705 Load balancing and horizontal scaling</li> <li>\u2705 Exceptional performance (10x faster than RabbitMQ)</li> <li>\u2705 RabbitMQ-compatible routing patterns</li> <li>\u2705 Async/fiber concurrency for massive scale</li> <li>\u2705 Comprehensive queue management and monitoring</li> <li>\u2705 Consumer groups and fault tolerance</li> </ul>"},{"location":"transports/redis-transport-comparison/#cons_2","title":"Cons","text":"<ul> <li>\u274c More complex setup and configuration</li> <li>\u274c No backwards compatibility with pub/sub transports</li> <li>\u274c Requires understanding of async/fiber concepts</li> <li>\u274c Additional memory overhead for queue management</li> <li>\u274c Client-side pattern matching overhead</li> </ul>"},{"location":"transports/redis-transport-comparison/#example_2","title":"Example","text":"<pre><code>class OrderMessage &lt; SmartMessage::Base\n  from 'e-commerce-api'\n  to 'order-processor'\n\n  transport :redis_queue  # Uses global configuration\n\n  property :order_id\n  property :amount\n\n  def self.process(wrapper)\n    header, payload = wrapper.split\n    order_data = JSON.parse(payload)\n    # Process order with guaranteed delivery\n  end\nend\n\n# Messages persist in Redis Lists until consumed\nOrderMessage.new(order_id: \"123\", amount: 99.99).publish\n\n# Load-balanced consumption across consumer group\nOrderMessage.subscribe\n</code></pre>"},{"location":"transports/redis-transport-comparison/#feature-comparison-matrix","title":"\ud83d\udcca Feature Comparison Matrix","text":"Feature Basic Redis Enhanced Redis Redis Queue Message Persistence \u274c No \u274c No \u2705 Yes Pattern Matching \u274c No \u2705 Wildcards \u2705 RabbitMQ-style Load Balancing \u274c No \u274c No \u2705 Consumer Groups Backwards Compatibility N/A \u2705 Dual Publishing \u274c No Fluent API \u274c No \u2705 Yes \u2705 Yes Performance (Latency) ~1ms ~1.2ms ~0.5ms Performance (Throughput) High High Highest Concurrent Consumers ~100s ~100s ~1000s Memory Overhead Low Medium Medium-High Setup Complexity Low Medium High Learning Curve Easy Medium Challenging Production Ready \u2705 Yes \u2705 Yes \u2705 Yes Message Ordering No guarantees No guarantees \u2705 FIFO Dead Letter Queues \u274c No \u274c No \u2705 Yes Message TTL \u274c No \u274c No \u2705 Yes Consumer Acknowledgments \u274c No \u274c No \u2705 Yes Monitoring/Metrics Basic Basic \u2705 Comprehensive"},{"location":"transports/redis-transport-comparison/#choosing-the-right-transport","title":"\ud83c\udfaf Choosing the Right Transport","text":""},{"location":"transports/redis-transport-comparison/#use-basic-redis-when","title":"Use Basic Redis When:","text":"<ul> <li>\u2705 You have simple pub/sub requirements</li> <li>\u2705 Message loss is acceptable</li> <li>\u2705 You need minimal setup and configuration</li> <li>\u2705 You're migrating from existing basic Redis pub/sub</li> <li>\u2705 Performance and simplicity are top priorities</li> <li>\u2705 You don't need sophisticated routing</li> </ul>"},{"location":"transports/redis-transport-comparison/#use-enhanced-redis-when","title":"Use Enhanced Redis When:","text":"<ul> <li>\u2705 You need RabbitMQ-style routing without RabbitMQ</li> <li>\u2705 You have microservices requiring intelligent routing</li> <li>\u2705 You want backwards compatibility with basic Redis</li> <li>\u2705 You need pattern-based message filtering</li> <li>\u2705 Message persistence is not critical</li> <li>\u2705 You want a fluent, readable subscription API</li> </ul>"},{"location":"transports/redis-transport-comparison/#use-redis-queue-when","title":"Use Redis Queue When:","text":"<ul> <li>\u2705 You need message persistence and reliability</li> <li>\u2705 You require load balancing across multiple consumers</li> <li>\u2705 You're building production systems with high throughput</li> <li>\u2705 You need enterprise features (DLQ, monitoring, etc.)</li> <li>\u2705 You can leverage async/fiber concurrency</li> <li>\u2705 You want RabbitMQ features with Redis performance</li> </ul>"},{"location":"transports/redis-transport-comparison/#migration-paths","title":"\ud83d\udd04 Migration Paths","text":""},{"location":"transports/redis-transport-comparison/#from-basic-enhanced","title":"From Basic \u2192 Enhanced","text":"<pre><code># Before (Basic)\ntransport = SmartMessage::Transport.create(:redis, url: 'redis://localhost:6379')\n\n# After (Enhanced) - maintains backwards compatibility\ntransport = SmartMessage::Transport::RedisEnhancedTransport.new(\n  url: 'redis://localhost:6379'\n)\n\n# Add pattern-based subscriptions gradually\ntransport.where.from('api').subscribe\n</code></pre>"},{"location":"transports/redis-transport-comparison/#from-enhanced-queue","title":"From Enhanced \u2192 Queue","text":"<pre><code># Before (Enhanced)\nclass OrderMessage &lt; SmartMessage::Base\n  transport SmartMessage::Transport::RedisEnhancedTransport.new(url: 'redis://localhost:6379')\nend\n\n# After (Queue) - requires architecture changes\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = { url: 'redis://localhost:6379' }\nend\n\nclass OrderMessage &lt; SmartMessage::Base\n  transport :redis_queue\n\n  # Add proper async processing\n  def self.process(wrapper)\n    header, payload = wrapper.split\n    # Handle message processing\n  end\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#from-basic-queue","title":"From Basic \u2192 Queue","text":"<pre><code># Significant architectural changes required\n# Consider Enhanced as intermediate step for easier migration\n</code></pre>"},{"location":"transports/redis-transport-comparison/#performance-testing","title":"\ud83d\udcc8 Performance Testing","text":""},{"location":"transports/redis-transport-comparison/#benchmark-setup","title":"Benchmark Setup","text":"<pre><code># Test all three transports\ntransports = {\n  basic: SmartMessage::Transport.create(:redis, url: 'redis://localhost:6379'),\n  enhanced: SmartMessage::Transport::RedisEnhancedTransport.new(url: 'redis://localhost:6379'),\n  queue: SmartMessage::Transport.create(:redis_queue, url: 'redis://localhost:6379')\n}\n\n# Measure latency, throughput, memory usage\n</code></pre>"},{"location":"transports/redis-transport-comparison/#expected-results","title":"Expected Results","text":"<ul> <li>Basic: Lowest latency, highest throughput for simple scenarios</li> <li>Enhanced: Slight overhead for pattern processing, excellent routing</li> <li>Queue: Best overall performance with persistence and load balancing</li> </ul>"},{"location":"transports/redis-transport-comparison/#configuration-examples","title":"\ud83d\udee0\ufe0f Configuration Examples","text":""},{"location":"transports/redis-transport-comparison/#development-environment","title":"Development Environment","text":"<pre><code># Use Enhanced for flexible development routing\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisEnhancedTransport.new(\n    url: 'redis://localhost:6379',\n    db: 1  # Separate dev database\n  )\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#production-environment","title":"Production Environment","text":"<pre><code># Use Queue for production reliability\nSmartMessage.configure do |config|\n  config.transport = :redis_queue\n  config.transport_options = {\n    url: ENV['REDIS_URL'],\n    db: 0,\n    queue_prefix: 'prod.smart_message',\n    consumer_group: ENV['CONSUMER_GROUP'] || 'default_workers',\n    consumer_timeout: 5,\n    reconnect_attempts: 10\n  }\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#hybrid-approach","title":"Hybrid Approach","text":"<pre><code># Different transports for different message types\nclass LogMessage &lt; SmartMessage::Base\n  transport SmartMessage::Transport.create(:redis, url: 'redis://localhost:6379')  # Fire-and-forget\nend\n\nclass OrderMessage &lt; SmartMessage::Base  \n  transport :redis_queue  # Persistent and reliable\nend\n\nclass HealthCheckMessage &lt; SmartMessage::Base\n  transport SmartMessage::Transport::RedisEnhancedTransport.new(\n    url: 'redis://localhost:6379'\n  )  # Pattern-based routing\nend\n</code></pre>"},{"location":"transports/redis-transport-comparison/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<ul> <li>Basic Redis Transport Examples</li> <li>Enhanced Redis Transport Examples</li> <li>Queue Redis Transport Examples</li> <li>Redis Queue Production Guide</li> <li>Redis Queue Patterns Guide</li> <li>Transport Reference</li> </ul> <p>This comparison should help you choose the right Redis transport for your specific use case. Each transport has its strengths and is optimized for different scenarios within the SmartMessage ecosystem.</p>"},{"location":"transports/redis-transport/","title":"Redis Transport","text":"<p>The Redis Transport is the foundational Redis-based transport implementation for SmartMessage. It uses Redis pub/sub channels for message distribution and provides reliable, high-performance messaging with minimal setup.</p>"},{"location":"transports/redis-transport/#overview","title":"Overview","text":"<p>Redis Transport is perfect for: - Simple pub/sub scenarios - Basic message broadcasting - Development and testing - Quick Redis-based messaging - Legacy compatibility - Original SmartMessage Redis implementation - High performance - Direct Redis pub/sub with minimal overhead</p>"},{"location":"transports/redis-transport/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Direct Redis Pub/Sub - Uses native Redis PUBLISH/SUBSCRIBE</li> <li>\u26a1 High Performance - ~1ms latency, 80K+ messages/second</li> <li>\ud83d\udd04 Auto-Reconnection - Automatic Redis connection recovery</li> <li>\ud83e\uddf5 Thread-Based Subscribers - Traditional thread-per-subscriber model</li> <li>\ud83c\udff7\ufe0f Simple Channel Names - Uses message class name as channel</li> <li>\ud83d\udce1 Broadcast Delivery - All subscribers receive all messages</li> </ul>"},{"location":"transports/redis-transport/#architecture","title":"Architecture","text":"<pre><code>Publisher \u2192 Redis Channel \u2192 All Subscribers\n         (class name)     (thread-based)\n</code></pre> <p>The Redis Transport uses the message class name directly as the Redis channel name. For example, <code>OrderMessage</code> publishes to the <code>OrderMessage</code> channel.</p>"},{"location":"transports/redis-transport/#configuration","title":"Configuration","text":""},{"location":"transports/redis-transport/#basic-setup","title":"Basic Setup","text":"<pre><code># Minimal configuration\ntransport = SmartMessage::Transport::RedisTransport.new\n\n# With Redis URL\ntransport = SmartMessage::Transport::RedisTransport.new(\n  url: 'redis://localhost:6379'\n)\n\n# Full configuration\ntransport = SmartMessage::Transport::RedisTransport.new(\n  url: 'redis://redis.example.com:6379',\n  db: 1,\n  auto_subscribe: true,\n  reconnect_attempts: 5,\n  reconnect_delay: 2\n)\n</code></pre>"},{"location":"transports/redis-transport/#using-with-smartmessage","title":"Using with SmartMessage","text":"<pre><code># Configure as default transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: ENV['REDIS_URL'] || 'redis://localhost:6379'\n  )\nend\n\n# Use in message class\nclass OrderMessage &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :customer_email, required: true\n\n  transport :redis\n\n  def process\n    puts \"Processing order: #{order_id} for #{customer_email}\"\n    # Business logic here\n  end\nend\n</code></pre>"},{"location":"transports/redis-transport/#configuration-options","title":"Configuration Options","text":"Option Type Default Description <code>url</code> String <code>redis://localhost:6379</code> Redis connection URL <code>db</code> Integer <code>0</code> Redis database number <code>auto_subscribe</code> Boolean <code>true</code> Automatically start subscriber thread <code>reconnect_attempts</code> Integer <code>5</code> Number of reconnection attempts <code>reconnect_delay</code> Integer <code>1</code> Seconds between reconnection attempts"},{"location":"transports/redis-transport/#usage-examples","title":"Usage Examples","text":""},{"location":"transports/redis-transport/#basic-message-processing","title":"Basic Message Processing","text":"<pre><code># Define message\nclass UserNotification &lt; SmartMessage::Base\n  property :user_id, required: true\n  property :message, required: true\n  property :type, default: 'info'\n\n  def process\n    user = User.find(user_id)\n    user.notifications.create!(\n      message: message,\n      type: type\n    )\n    puts \"Notification sent to user #{user_id}: #{message}\"\n  end\nend\n\n# Publish notification\nUserNotification.new(\n  user_id: 123,\n  message: \"Your order has been shipped!\",\n  type: \"success\"\n).publish\n\n# Output: Notification sent to user 123: Your order has been shipped!\n</code></pre>"},{"location":"transports/redis-transport/#multiple-publishers-and-subscribers","title":"Multiple Publishers and Subscribers","text":"<pre><code># Publisher 1 (Web Application)\nclass OrderCreated &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :user_id, required: true\n  property :total, required: true\n\n  def process\n    # This runs on all subscribers\n    puts \"Order #{order_id} created for user #{user_id}: $#{total}\"\n  end\nend\n\n# Publisher 2 (Admin Panel)\nclass OrderCancelled &lt; SmartMessage::Base\n  property :order_id, required: true\n  property :reason, required: true\n\n  def process\n    puts \"Order #{order_id} cancelled: #{reason}\"\n  end\nend\n\n# Both services will receive both message types\n# All subscribers get all messages - broadcast behavior\n\n# Publish from web app\nOrderCreated.new(\n  order_id: \"ORD-001\", \n  user_id: 456, \n  total: 99.99\n).publish\n\n# Publish from admin panel\nOrderCancelled.new(\n  order_id: \"ORD-002\", \n  reason: \"Customer request\"\n).publish\n</code></pre>"},{"location":"transports/redis-transport/#connection-management","title":"Connection Management","text":"<pre><code># Check connection status\ntransport = SmartMessage::Transport::RedisTransport.new\nputs \"Connected: #{transport.connected?}\"\n\n# Manual connection control\ntransport.stop_subscriber\ntransport.start_subscriber\n\n# Access Redis connections directly\npub_redis = transport.redis_pub\nsub_redis = transport.redis_sub\n\n# Test connection\nbegin\n  pub_redis.ping\n  puts \"Redis connection healthy\"\nrescue Redis::ConnectionError\n  puts \"Redis connection failed\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#error-handling","title":"Error Handling","text":"<pre><code>class ReliableMessage &lt; SmartMessage::Base\n  property :data, required: true\n\n  def process\n    begin\n      # Potentially failing operation\n      external_api_call(data)\n    rescue =&gt; e\n      logger.error \"Failed to process message: #{e.message}\"\n      # Message processing failed, but won't retry\n      # Use dead letter queue for failed messages\n    end\n  end\n\n  private\n\n  def external_api_call(data)\n    # Simulate external API call\n    raise \"API unavailable\" if rand &lt; 0.1\n    puts \"Processed: #{data}\"\n  end\nend\n\n# Publish messages - some may fail processing\n10.times do |i|\n  ReliableMessage.new(data: \"item-#{i}\").publish\nend\n</code></pre>"},{"location":"transports/redis-transport/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Latency: ~1ms average message delivery</li> <li>Throughput: 80,000+ messages/second</li> <li>Memory per Subscriber: ~1MB baseline</li> <li>Concurrent Subscribers: ~200 practical limit</li> <li>Connection Overhead: 2 Redis connections (pub + sub)</li> <li>Message Persistence: None (fire-and-forget)</li> <li>Message Ordering: No guarantees</li> </ul>"},{"location":"transports/redis-transport/#api-reference","title":"API Reference","text":""},{"location":"transports/redis-transport/#instance-methods","title":"Instance Methods","text":""},{"location":"transports/redis-transport/#connected","title":"<code>#connected?</code>","text":"<p>Checks if Redis connections are healthy.</p> <pre><code>if transport.connected?\n  puts \"Redis transport ready\"\nelse\n  puts \"Redis transport offline\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#start_subscriber","title":"<code>#start_subscriber</code>","text":"<p>Manually starts the subscriber thread (if <code>auto_subscribe: false</code>).</p> <pre><code>transport = SmartMessage::Transport::RedisTransport.new(auto_subscribe: false)\n# ... do setup ...\ntransport.start_subscriber\n</code></pre>"},{"location":"transports/redis-transport/#stop_subscriber","title":"<code>#stop_subscriber</code>","text":"<p>Stops the subscriber thread gracefully.</p> <pre><code>transport.stop_subscriber\nputs \"Subscriber stopped\"\n</code></pre>"},{"location":"transports/redis-transport/#subscriber_running","title":"<code>#subscriber_running?</code>","text":"<p>Checks if the subscriber thread is active.</p> <pre><code>if transport.subscriber_running?\n  puts \"Actively listening for messages\"\nend\n</code></pre>"},{"location":"transports/redis-transport/#channel-naming","title":"Channel Naming","text":"<p>Redis Transport uses simple channel naming: - Message Class: <code>OrderMessage</code> - Redis Channel: <code>\"OrderMessage\"</code> - Subscription: Exact channel name match</p> <pre><code># These all use the \"UserMessage\" channel\nclass UserMessage &lt; SmartMessage::Base\n  property :user_id\nend\n\n# Publishing\nUserMessage.new(user_id: 123).publish\n# \u2192 Publishes to Redis channel \"UserMessage\"\n\n# Subscribing  \nUserMessage.subscribe\n# \u2192 Subscribes to Redis channel \"UserMessage\"\n</code></pre>"},{"location":"transports/redis-transport/#use-cases","title":"Use Cases","text":""},{"location":"transports/redis-transport/#simple-applications","title":"Simple Applications","text":"<pre><code># Perfect for straightforward pub/sub needs\nclass SystemAlert &lt; SmartMessage::Base\n  property :level, required: true\n  property :message, required: true\n\n  def process\n    case level\n    when 'critical'\n      send_pager_alert(message)\n    when 'warning'  \n      log_warning(message)\n    else\n      log_info(message)\n    end\n  end\nend\n\nSystemAlert.new(level: 'critical', message: 'Database offline').publish\n</code></pre>"},{"location":"transports/redis-transport/#development-environment","title":"Development Environment","text":"<pre><code># config/environments/development.rb\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new(\n    url: 'redis://localhost:6379',\n    db: 1  # Separate dev database\n  )\n  config.logger.level = Logger::DEBUG\nend\n</code></pre>"},{"location":"transports/redis-transport/#legacy-system-integration","title":"Legacy System Integration","text":"<pre><code># Maintaining compatibility with existing Redis pub/sub systems\nclass LegacyEvent &lt; SmartMessage::Base\n  property :event_type, required: true\n  property :payload, required: true\n\n  def process\n    # Process in SmartMessage format\n    LegacyEventProcessor.new(event_type, payload).process\n  end\nend\n\n# External systems can still publish to \"LegacyEvent\" channel\n# SmartMessage will automatically process them\n</code></pre>"},{"location":"transports/redis-transport/#performance-tuning","title":"Performance Tuning","text":""},{"location":"transports/redis-transport/#connection-pooling","title":"Connection Pooling","text":"<pre><code># For high-throughput applications, consider connection pooling\nrequire 'connection_pool'\n\nredis_pool = ConnectionPool.new(size: 10) do\n  Redis.new(url: 'redis://localhost:6379')\nend\n\n# Use custom Redis instance\ntransport = SmartMessage::Transport::RedisTransport.new\ntransport.instance_variable_set(:@redis_pub, redis_pool.with { |r| r })\n</code></pre>"},{"location":"transports/redis-transport/#monitoring","title":"Monitoring","text":"<pre><code># Monitor Redis transport health\nclass HealthCheck\n  def self.redis_transport_status\n    transport = SmartMessage.configuration.default_transport\n    {\n      connected: transport.connected?,\n      subscriber_running: transport.subscriber_running?,\n      redis_info: transport.redis_pub.info\n    }\n  end\nend\n\nputs HealthCheck.redis_transport_status\n</code></pre>"},{"location":"transports/redis-transport/#best-practices","title":"Best Practices","text":""},{"location":"transports/redis-transport/#configuration_1","title":"Configuration","text":"<ul> <li>Use environment variables for Redis URLs</li> <li>Set appropriate database numbers for different environments</li> <li>Configure reasonable reconnection settings</li> </ul>"},{"location":"transports/redis-transport/#error-handling_1","title":"Error Handling","text":"<ul> <li>Implement proper error handling in message processing</li> <li>Use logging to track message failures</li> <li>Consider implementing dead letter queue pattern</li> </ul>"},{"location":"transports/redis-transport/#monitoring_1","title":"Monitoring","text":"<ul> <li>Monitor Redis connection health</li> <li>Track message throughput and processing times</li> <li>Set up alerts for subscriber thread failures</li> </ul>"},{"location":"transports/redis-transport/#testing","title":"Testing","text":"<ul> <li>Use separate Redis databases for testing</li> <li>Clear Redis data between tests</li> <li>Mock Redis for unit tests</li> </ul>"},{"location":"transports/redis-transport/#limitations","title":"Limitations","text":""},{"location":"transports/redis-transport/#no-pattern-matching","title":"No Pattern Matching","text":"<p>Redis Transport requires exact channel name matches:</p> <pre><code># This works - exact match\nOrderMessage.subscribe  # Subscribes to \"OrderMessage\"\n\n# This doesn't work - no wildcard support\n# Can't subscribe to \"Order*\" or \"*Message\"\n</code></pre>"},{"location":"transports/redis-transport/#no-message-persistence","title":"No Message Persistence","text":"<p>Messages are lost if no subscribers are listening:</p> <pre><code># If no subscribers are running, this message is lost\nOrderMessage.new(order_id: 'ORD-001').publish\n</code></pre>"},{"location":"transports/redis-transport/#broadcasting-only","title":"Broadcasting Only","text":"<p>All subscribers receive all messages:</p> <pre><code># If 3 services subscribe to OrderMessage,\n# all 3 will process every OrderMessage\n# No load balancing between subscribers\n</code></pre>"},{"location":"transports/redis-transport/#migration-to-enhanced-transport","title":"Migration to Enhanced Transport","text":"<p>When you need advanced routing, consider upgrading to Enhanced Transport:</p> <pre><code># From Redis Transport\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisTransport.new\nend\n\n# To Enhanced Transport (with backward compatibility)\nSmartMessage.configure do |config|\n  config.default_transport = SmartMessage::Transport::RedisEnhancedTransport.new\nend\n\n# All existing messages continue to work\n# New messages gain pattern-matching capabilities\n</code></pre>"},{"location":"transports/redis-transport/#examples","title":"Examples","text":"<p>The <code>examples/redis/</code> directory contains production-ready examples demonstrating Redis Transport capabilities:</p>"},{"location":"transports/redis-transport/#iot-and-real-time-messaging","title":"IoT and Real-Time Messaging","text":"<ul> <li>01_smart_home_iot_demo.rb - Complete smart home IoT system with Redis pub/sub</li> <li>Real-time sensor data publishing (temperature, motion, battery levels)</li> <li>Device command routing with prefix-based filtering</li> <li>Alert generation and dashboard monitoring</li> <li>Multi-process distributed architecture</li> </ul>"},{"location":"transports/redis-transport/#key-features-demonstrated","title":"Key Features Demonstrated","text":"<p>The IoT example showcases all Redis Transport capabilities: - Direct Redis Pub/Sub - High-performance message broadcasting - Channel-Based Routing - Each message type uses dedicated channels - Device-Specific Filtering - Commands routed by device ID prefixes - Real-Time Data Flow - Continuous sensor data streaming - Multi-Process Communication - Distributed system simulation</p>"},{"location":"transports/redis-transport/#running-examples","title":"Running Examples","text":"<pre><code># Prerequisites: Start Redis server\nredis-server\n\n# Navigate to the SmartMessage directory\ncd smart_message\n\n# Run the Redis Transport IoT demo\nruby examples/redis/01_smart_home_iot_demo.rb\n\n# Monitor Redis channels during the demo\nredis-cli MONITOR\n</code></pre>"},{"location":"transports/redis-transport/#example-architecture","title":"Example Architecture","text":"<p>The IoT demo creates a complete distributed system: - 5 IoT processes - Sensors publishing data every 3-5 seconds - Dashboard process - Aggregating and displaying system status - Redis channels - <code>SensorDataMessage</code>, <code>DeviceCommandMessage</code>, <code>AlertMessage</code> - Device filtering - THERM-, CAM-, LOCK- prefix routing</p> <p>Each example includes comprehensive logging and demonstrates production-ready patterns for Redis-based messaging systems.</p>"},{"location":"transports/redis-transport/#additional-resources","title":"Additional Resources","text":"<p>For more Redis Transport examples and patterns, also see: - Memory Transport Examples - Can be adapted to Redis Transport by changing configuration - Complete Documentation - Detailed data flow analysis with SVG diagrams</p>"},{"location":"transports/redis-transport/#related-documentation","title":"Related Documentation","text":"<ul> <li>Redis Enhanced Transport - Advanced routing with patterns</li> <li>Redis Queue Transport - Persistent queues with load balancing  </li> <li>Transport Comparison - Compare all Redis transports</li> <li>Transport Overview - All available transports</li> </ul>"}]}